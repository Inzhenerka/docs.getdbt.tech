---

title: Клонировать или откладывать, вот в чем вопрос
description: "В dbt версии 1.6 мы представляем поддержку клонирования без копирования данных с помощью новой команды dbt clone. В этом блоге Кшитидж расскажет, что такое клонирование, чем оно отличается от откладывания и когда использовать каждое из них."
slug: to-defer-or-to-clone

image: /img/blog/2023-10-31-to-defer-or-to-clone/preview.png

authors: [kshitij_aranke, doug_beatty]

tags: [analytics craft]
hide_table_of_contents: false

date: 2023-10-31
is_featured: true

---

Привет всем, я Кшитидж, старший инженер-программист в команде Core в dbt Labs.
Одним из самых крутых моментов в моей карьере здесь было внедрение новой команды `dbt clone` в рамках выпуска dbt-core v1.6.

Однако один из самых частых вопросов, которые я получаю, касается рекомендаций о том, "когда" клонировать, выходящих за рамки [документации о "как" клонировать](https://docs.getdbt.com/reference/commands/clone).
В этом блоге я постараюсь дать эти рекомендации, ответив на следующие часто задаваемые вопросы:

1. Что такое `dbt clone`?
2. Чем это отличается от откладывания?
3. Должен ли я откладывать или клонировать?
<!--truncate-->
## Что такое `dbt clone`?

`dbt clone` — это новая команда в dbt 1.6, которая использует нативную функциональность клонирования без копирования данных на поддерживаемых хранилищах для **копирования целых схем бесплатно и почти мгновенно**.

### Как это возможно?

Хранилище "читит", копируя только метаданные из схемы `source` в схему `target`; исходные данные остаются на месте во время этой операции.
Эти метаданные включают материализованные объекты, такие как таблицы и представления, поэтому вы видите **клон** этих объектов в целевой схеме.

На языке информатики, `clone` создает копию указателя из схемы `source` на исходные данные; после операции теперь есть два указателя (схемы `source` и `target`), которые указывают на одни и те же исходные данные.

## Чем клонирование отличается от откладывания?

На первый взгляд, клонирование и откладывание кажутся похожими — **оба способа экономии затрат в хранилище данных.**
Они делают это, обходя дорогостоящие пересчеты моделей — клонирование [активно копирует](https://en.wikipedia.org/wiki/Evaluation_strategy#Eager_evaluation) всю схему в целевую схему, а откладывание [лениво ссылается](https://en.wikipedia.org/wiki/Lazy_evaluation) на предварительно построенные модели в исходной схеме.

Давайте разберем это предложение и исследуем его первичные эффекты:

|                           | defer                                                                                                                                                              | clone                                                                                                                                    |
|---------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------|
| **Как это использовать?** | Неявно через флаг `--defer`                                                                                                                                        | Явно через команду `dbt clone`                                                                                                           |
| **Каковы его результаты?**| Не создает никаких объектов сам по себе, но dbt может создать объекты в целевой схеме, если они изменились по сравнению с исходной схемой.                          | Копирует объекты из исходной схемы в целевую схему в хранилище данных, которые сохраняются после завершения операции.                     |
| **Как это работает?**     | Сравнивает манифесты между исходными и целевыми запусками dbt и переопределяет ref, чтобы разрешить модели, не построенные в целевом запуске, указывая на объекты, построенные в исходном запуске. | Использует клонирование без копирования, если доступно, для копирования объектов из исходных в целевые схемы, иначе создает указательные представления (`select * from my_model`) |

Эти первичные эффекты приводят к следующим вторичным эффектам, которые действительно отличают клонирование от откладывания:

|                                                                          | defer                                                                                                                              | clone                                                                                  |
|--------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
| **Где я могу использовать объекты, построенные в целевой схеме?**        | Только в контексте dbt                                                                                                             | В любом инструменте downstream (например, BI)                                          |
| **Могу ли я безопасно изменять объекты, построенные в целевой схеме?**   | Нет, так как это изменит производственные данные                                                                                   | Да, клонирование — это дешевый способ создать песочницу производственных данных для экспериментов |
| **Будут ли данные в целевой схеме отличаться от данных в исходной схеме?** | Нет, так как откладывание всегда будет указывать на последнюю версию исходной схемы                                                | Да, так как клонирование — это операция в определенный момент времени                  |
| **Могу ли я использовать несколько исходных схем одновременно?**         | Да, откладывание может динамически переключаться между исходными схемами, например, ссылаться на неизмененные модели из производства и измененные модели из стадии | Нет, клонирование копирует объекты из одной исходной схемы в одну целевую схему        |

## Должен ли я откладывать или клонировать?

Собрав все вышеперечисленные пункты, вот удобная шпаргалка, когда откладывать и когда клонировать:

|                                                                           | defer | clone |
|---------------------------------------------------------------------------|-------|-------|
| **Экономия времени и затрат за счет избежания пересчета**                 | ✅     | ✅     |
| **Создание объектов базы данных для использования в downstream инструментах (например, BI)** | ❌     | ✅     |
| **Безопасное изменение объектов в целевой схеме**                         | ❌     | ✅     |
| **Избегание создания новых объектов базы данных**                         | ✅     | ❌     |
| **Избегание дрейфа данных**                                               | ✅     | ❌     |
| **Поддержка нескольких динамических источников**                          | ✅     | ❌     |

Чтобы окончательно закрепить эту мысль:

1. Если вы отправляете кому-то эту шпаргалку, ссылаясь на эту страницу, вы откладываете на эту страницу
2. Если вы распечатываете эту страницу и пишете заметки на полях, вы клонировали эту страницу

## Применение на практике

Используя приведенную выше шпаргалку, давайте рассмотрим несколько распространенных сценариев и выясним, следует ли использовать откладывание или клонирование для каждого из них:

1. **Тестирование стадийных наборов данных в BI**

    В этом сценарии мы хотим:
    1. Сделать копию нашего производственного набора данных доступной в нашем downstream BI инструменте
    2. Безопасно итеративно работать с этой копией, не нарушая производственные наборы данных
    
    Поэтому в этом сценарии мы должны использовать **клонирование**.
    
2. **[Slim CI](https://discourse.getdbt.com/t/how-we-sped-up-our-ci-runs-by-10x-using-slim-ci/2603)**

    В этом сценарии мы хотим:
    1. Ссылаться на производственные модели, где это возможно, чтобы ускорить запуски непрерывной интеграции (CI)
    2. Запускать и тестировать только те модели в CI стадии, которые изменились по сравнению с производственной средой
    3. Ссылаться на модели из разных сред — prod для неизмененных моделей и staging для измененных моделей
    
    Поэтому в этом сценарии мы должны использовать **откладывание**.

:::tip Используйте `dbt clone` в CI задачах для тестирования инкрементальных моделей
Узнайте, как [использовать `dbt clone` в CI задачах](/best-practices/clone-incremental-models) для эффективного тестирования измененных инкрементальных моделей, имитируя поведение после слияния, избегая затрат на полное обновление.
:::
    
3. **[Blue/Green Deployments](https://discourse.getdbt.com/t/performing-a-blue-green-deploy-of-your-dbt-project-on-snowflake/1349)**

    В этом сценарии мы хотим:
    1. Убедиться, что все тесты всегда проходят на производственном наборе данных, даже если этот набор данных немного устарел
    2. Атомарно откатить продвижение в производство, если тесты не проходят по всему стадийному набору данных
    
    В этом сценарии мы можем использовать **клонирование** для реализации стратегии развертывания, известной как blue-green deployments, где мы строим весь стадийный набор данных, а затем запускаем тесты против него, и только клонируем его в производство, если все тесты проходят.
    

Как правило, откладывание лучше подходит для случаев использования непрерывной интеграции (CI), тогда как клонирование лучше подходит для случаев использования непрерывного развертывания (CD).

## Завершение

В этом посте мы рассмотрели, что такое `dbt clone`, чем оно отличается от откладывания и когда использовать каждое из них. Часто они могут использоваться вместе в рамках одного проекта на разных этапах жизненного цикла развертывания.

Спасибо за чтение, и я с нетерпением жду, что вы создадите с помощью `dbt clone`.

*Спасибо [Джейсон Ганц](https://docs.getdbt.com/author/jason_ganz) и [Гвен Виндфлауэр](https://www.linkedin.com/in/gwenwindflower/) за рецензирование черновиков этой статьи*