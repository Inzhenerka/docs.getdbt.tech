---
title: "Недостающий гид по debug() в dbt"
description: Jinja приносит много автоматизации и радости в dbt — но также добавляет дополнительную сложность и требует навыков для успешной работы с ним. В этом блоге разработчика Бенуа рассказывает о полезной команде debug() в Jinja, чтобы сделать отладку макросов более эффективной и интуитивной.
authors: [benoit_perigaud]
slug: guide-to-jinja-debug
tags: [analytics craft]
hide_table_of_contents: false
date: 2023-03-29
is_featured: true
---

*Примечание редактора — этот пост предполагает средний уровень знаний Jinja и разработки макросов в dbt. Для введения в Jinja в dbt ознакомьтесь с [документацией](https://docs.getdbt.tech/docs/build/jinja-macros) и бесплатным курсом [Jinja, Macros, Packages](https://learn.getdbt.com/courses/jinja-macros-and-packages).*

Jinja приносит много возможностей в dbt, позволяя нам использовать `ref()`, `source()`, условный код и [макросы](https://docs.getdbt.tech/docs/build/jinja-macros). Но, хотя Jinja приносит гибкость, она также добавляет сложность, и, как часто бывает с кодом, вещи могут работать не так, как ожидалось.

Макрос [`debug()`](https://docs.getdbt.tech/reference/dbt-jinja-functions/debug-method) в dbt — отличный инструмент для тех, кто пишет много кода на Jinja, но может быть сложно понять, как его использовать и какие преимущества он приносит.

Давайте погрузимся в последний случай, когда я использовал `debug()` и как он помог мне решить ошибки в моем коде.

<!--truncate-->

## Jinja в dbt {#jinja-in-dbt}

Работая над функцией для [пакета dbt_project_evaluator](https://github.com/dbt-labs/dbt-project-evaluator), мои запуски dbt начали постоянно завершаться сбоем, предоставляя мне следующее сообщение:

```plain text
16:49:26  Database error while running on-run-end
16:49:26  Encountered an error:
Runtime Error
  Parser Error:
```
И всё!?!?
<center>
<iframe src="https://giphy.com/embed/l4JyNPwLCWt6mSxlS" width="480" height="276" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/comedy-bbc-three-l4JyNPwLCWt6mSxlS">via GIPHY</a></p>
</center>

Так как моя конфигурация `on-run-end` в `dbt_project.yml` была следующей, я, по крайней мере, мог определить, что проблема была в моем макросе `print_dbt_project_evaluator_issues`:

```yaml
on-run-end: "{{ dbt_project_evaluator.print_dbt_project_evaluator_issues() }}"
```

Но, кроме этого понимания, не было упоминания о конкретной строке или неудачном макросе — поэтому первым шагом было попытаться понять, какая часть моего кода вызывает ошибку. У меня было два варианта:

1. Написать кучу операторов `print("Here")` или `log("there", info=true)` в моих макросах и посмотреть, какие из них будут напечатаны, а какие нет.
2. Использовать команду `debug()`, чтобы как найти, где мой код не работает, так и посмотреть на мои переменные во время выполнения кода.

Как вы могли догадаться, это руководство о варианте №2.

## Введение в `debug()` в Jinja {#intro-to-debug-in-jinja}

`debug()` — это команда, доступная в dbt, используемая для установки точек останова в вашем коде Jinja. Эти точки останова останавливают выполнение вашего кода и предоставляют возможность исследовать переменные и выполнять следующую часть вашего кода шаг за шагом.

### Как использовать {#how-to-use-it}

Прежде всего, `debug()` недоступен в dbt Cloud, так как он не предоставляет полный доступ к терминалу, поэтому вам придется установить и использовать `dbt-core` локально.

Затем, чтобы войти в режим отладки, вам нужно:

- Написать `{{ debug() }}` в вашем коде — там, где вы хотите начать отладку — и
- установить переменную окружения `DBT_MACRO_DEBUGGING` в любое значение. Это можно сделать для всей сессии оболочки, введя `export DBT_MACRO_DEBUGGING=1` в командной строке, или для каждой команды, добавив переменную окружения перед всей командой, например, `DBT_MACRO_DEBUGGING=1 dbt build`. Без этой переменной команда `debug()` не будет оценена, и вы не войдете в режим отладки.

### Вернемся к нашей первоначальной проблеме, давайте используем `debug`, чтобы определить, где в нашем коде есть ошибки {#back-to-our-original-issue-lets-use-debug-to-pinpoint-where-our-code-has-bugs}

Если вы поместите `{{ debug() }}` в одну или несколько секций вашего кода и в режиме отладки нажмете `c`, отладчик остановится на каждой из ваших точек останова, позволяя вам найти, какая часть кода не работает.

В моем случае,

```sql
{% set my_results = run_query(sql_statement) %}
{{ debug() }}
```
не удалось войти в режим отладки, но
```sql
{{ debug() }}
{% set my_results = run_query(sql_statement) %}
```
вошел в режим отладки, сообщив мне, что что-то не так с выполнением моего фактического запроса.

Теперь, когда мы нашли, где проблема, может ли `debug()` помочь нам ее исправить? Давайте посмотрим на различные команды, доступные в отладчике.

## Использование полной мощности отладки Jinja {#using-the-full-power-of-jinja-debugging}

### команды отладки {#debugging-commands}

С кодом в режиме отладки мы получаем полностью функциональный интерактивный отладчик Python, показывающий нам эту информацию: `ipdb>` (технически, `ipdb` означает [IPython отладчик](https://github.com/gotcha/ipdb)).

Первая команда, которую мы можем ввести, это `h`, чтобы получить список помощи и доступных команд:

```plain text
Documented commands (type help <topic>):
========================================
EOF    clear      display  l         pfile    return           tbreak     where
a      commands   down     list      pinfo    retval           u
alias  condition  enable   ll        pinfo2   run              unalias
args   cont       exit     longlist  pp       rv               undisplay
b      context    h        n         psource  s                unt
break  continue   help     next      q        skip_hidden      until
bt     d          ignore   p         quit     skip_predicates  up
c      debug      j        pdef      r        source           w
cl     disable    jump     pdoc      restart  step             whatis

Miscellaneous help topics:
==========================
exec  pdb

Undocumented commands:
======================
interact
```

Это руководство не будет описывать все команды `ipdb`, доступные нам, существует множество онлайн-руководств по этой теме, но мы сосредоточимся на самых полезных в большинстве случаев отладки Jinja:

- `a`: Список текущих параметров для функций, в которых вы находитесь.
- `c`: Продолжить выполнение кода до следующей точки останова или до конца программы, если других точек останова нет.
- `p` и `pp`: Печать и красивая печать данных.
    - `p` часто будет печатать данные в одной строке, обернутой на несколько строк.
    - `pp` напечатает ту же информацию, но добавит новые строки, чтобы было легче быстро взглянуть на переменную; `pp` особенно полезен для печати списков и словарей.

### Использование интерактивной подсказки для решения нашей проблемы {#using-the-interactive-prompt-to-solve-our-problem}

Находясь в `ipdb`, вы также можете ввести некоторый код на Python, чтобы исследовать вашу программу и текущее значение ваших переменных. Например, ввод `locals().keys()` или `p locals().keys()` возвращает список текущих локальных переменных (ввод просто `locals()` печатает как имена переменных, так и их значения, что, скорее всего, полностью заполнит ваш терминал).

`ipdb` в Jinja не вернет список переменных с точно такими же именами, как в вашем коде, но вы увидите переменные с очень похожими именами, с просто префиксом, как `l_1_<my_variable>` или `l_2_<my_variable>` в зависимости от циклов в вашем коде Jinja.

В моем случае отладчик возвращает следующий (сокращенный) список:

```plain text
dict_keys(['l_1_schema_project_evaluator', 'l_1_db_project_evaluator', 't_2', ..., 'l_1_results', ..., 'l_2_graph', ..., 'l_2_sql_statement', 'environment', 'missing', 'resolve', 't_1', 'undefined'])
```

Советую искать переменные с похожими именами на переменные, которые я либо сам определил, либо прочитал из своего кода. Здесь я вижу `l_2_sql_statement` как часть моего списка переменных и могу также напечатать его значение в своем терминале, введя `p l_2_sql_statement`.

Ввод `p l_2_sql_statement` вернул следующее в мой терминал:
```sql
`'\n select * from duck.main.model.dbt_project_evaluator.fct_documentation_coverage\n '`
```

Мы можем сразу увидеть, что есть проблема в SQL, сгенерированном в рамках моего макроса, так как я пытаюсь прочитать из `duck.main.model.dbt_project_evaluator.fct_documentation_coverage` (конкатенируя базу данных, схему и уникальный идентификатор модели) вместо `duck.main.fct_documentation_coverage` (конкатенируя базу данных, схему и имя таблицы модели). Мы нашли проблему.

Чтобы исправить это, мы можем воспользоваться возможностью изменять переменные в режиме отладки. Сначала мы можем присвоить новое значение переменной, введя `l_2_sql_statement = '\n select * from duck.main.fct_documentation_coverage\n '`, а затем ввести `c` в отладчике, чтобы позволить макросу выполняться до завершения или достижения новой точки останова. В моем случае оператор сработал после того, как я изменил `l_2_sql_statement`, и я могу вернуться к логике в своем коде, чтобы увидеть, почему его значение не такое, как я ожидал.

### Использование отладчика для анализа переменных Jinja в dbt {#using-the-debugger-to-analyze-dbt-jinja-variables}

Отладчик также можно использовать для исследования [встроенных переменных и функций Jinja, доступных в dbt](https://docs.getdbt.tech/reference/dbt-jinja-functions).

В моем коде я также смотрел на [объект результатов](https://docs.getdbt.tech/reference/dbt-jinja-functions/on-run-end-context#results), доступный в контексте `on-run-end`. Мы можем фактически увидеть его в предыдущем списке, названном `l_1_results`.

В отладчике, если я введу `type(l_1_results)`, программа скажет мне, что это `list`. Затем я могу выполнить `type(l_1_results[0])`, и dbt теперь скажет мне, что тип переменной — это `dbt.contracts.results.RunResult`.

Мой последний шаг для анализа объекта результатов — ввести `pp l_1_results[0].to_dict()`, и CLI затем вернет красиво отформатированную версию всех полей и значений, доступных в первом элементе моего объекта `results`.

## Заключительные мысли {#parting-thoughts}

Надеюсь, это краткое руководство дало вам представление о том, как `debug()` может помочь вам более эффективно разрабатывать код Jinja и исследовать потенциальные ошибки. И не стесняйтесь переходить в [#advice-dbt-for-power-users](https://getdbt.slack.com/archives/C2JRRQDTL) в [сообществе dbt в Slack](https://www.getdbt.com/community/join-the-community/), если вы хотите обсудить более подробно отладку!