---
title: "Функция LOWER в SQL: Почему мы её любим"
description: "Функция LOWER в SQL позволяет вернуть строковое значение в виде строки, состоящей из строчных букв. Это эффективный способ создать единообразное написание строковых значений в ваших данных."
slug: lower-sql-love-letter
canonical_url: https://docs.getdbt.tech/sql-reference/lower

authors: [kira_furuichi]

tags: [sql magic]
hide_table_of_contents: false

date: 2022-05-11
is_featured: false
---

Мы все были в такой ситуации:

* В форме регистрации пользователь A ввел своё имя как `Kira Furuichi`, пользователь B ввел его как `john blust`, а пользователь C написал `DAvid KrevitT` (что это было, Дэвид??)
* Ваши инженеры бэкенда настаивают, чтобы электронные адреса клиентов были написаны заглавными буквами
* Все ваши имена для отслеживания событий написаны строчными буквами

В реальном мире человеческих несовершенств, мнений и ошибок строковые значения, вероятно, будут иметь непоследовательное написание заглавными и строчными буквами в разных источниках данных (или даже в одном и том же источнике данных). Всегда есть немного хаоса в том, почему некоторые значения передаются в верхнем или нижнем регистре, и не стоит ломать голову, чтобы это выяснить.

Итак, как создать единообразие для строковых значений, которые вы собираете из всех ваших источников данных? Функция LOWER!

<!--truncate-->

Использование функции LOWER для строкового значения вернет ввод в виде строки, состоящей из строчных букв. Это эффективный способ создать единообразное написание строковых значений в ваших данных.

> **Что такое функция SQL?** 
> На высоком уровне функция принимает входные данные (или несколько входных данных) и возвращает манипуляцию с этими данными. Некоторые распространенные функции SQL — это [COALESCE](https://docs.getdbt.tech/blog/coalesce-sql-love-letter/), [EXTRACT](https://docs.getdbt.tech/blog/extract-sql-love-letter) и [DATEDIFF](https://docs.getdbt.tech/blog/datediff-sql-love-letter/). Например, функция COALESCE принимает группу значений и возвращает первое ненулевое значение из этой группы.

## Как использовать функцию LOWER

Синтаксис для использования функции LOWER выглядит следующим образом:

```sql
lower('<string_value>')
```

Выполнение этой команды в операторе SELECT вернет строку ввода в нижнем регистре. Вы также можете использовать функцию LOWER в предложениях WHERE и соединениях.

### Поддержка функции LOWER в хранилищах данных

[Google BigQuery](https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions#lower), [Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/dg/r_LOWER.html), [Snowflake](https://docs.snowflake.com/en/sql-reference/functions/lower.html), [Postgres](https://www.postgresqltutorial.com/postgresql-string-functions/postgresql-letter-case-functions/) и [Databricks](https://docs.databricks.com/sql/language-manual/functions/lower.html) поддерживают функцию LOWER. Кроме того, синтаксис использования LOWER одинаков для всех них.

## Пример использования функции LOWER в SQL

Давайте рассмотрим реальный пример! Ниже вы увидите первые три строки из таблицы `customers` в [jaffle_shop](https://github.com/dbt-labs/jaffle_shop), простом наборе данных и проекте dbt, который имеет три столбца: `customer_id`, `first_name` и `last_name`.

| **customer_id** | **first_name** | **last_name** |
| --------------- | -------------- | ------------- |
| 1               | Michael        | P.            |
| 2               | Shawn          | M.            |
| 3               | Kathleen       | P.            |

Вы можете привести к нижнему регистру имена и фамилии в модели `customers`, используя следующий код:

```sql
select 
	customer_id,
	lower(first_name) as first_name,
	lower(last_name) as last_name
from {{ ref('customers') }}
```

После выполнения этого запроса таблица `customers` будет выглядеть примерно так:

| **customer_id** | **first_name** | **last_name** |
| --------------- | -------------- | ------------- |
| 1               | michael        | p.            |
| 2               | shawn          | m.            |
| 3               | kathleen       | p.            |

Теперь все символы в столбцах `first_name` и `last_name` написаны строчными буквами.

> **Где использовать LOWER?**
> Изменение всех строковых столбцов на строчные для создания единообразия между источниками данных обычно происходит в [стейджинговых моделях](https://docs.getdbt.tech/best-practices/how-we-structure/2-staging) нашего проекта dbt. Есть несколько причин для этого: очистка и стандартизация данных, такие как создание псевдонимов, приведение типов и приведение к нижнему регистру, должны происходить в стейджинговых моделях для создания единообразия на следующих этапах. Это также более производительно в моделях, которые объединяются по строковым значениям, чтобы объединяться по строкам с одинаковым регистром, а не выполнять объединение и приведение к нижнему регистру одновременно.

## Почему мы её любим

Вернемся к нашему хаотичному трио пользователей A, B и C, которые все использовали разные регистры для ввода своих имен. Если вы не создадите единообразное написание строковых значений, как бизнес-пользователь узнает, что именно фильтровать в своем BI-инструменте? Бизнес-пользователь может отфильтровать поле имени по "John Blust", так как он ожидает, что оно будет выглядеть именно так, и не получить никаких результатов. Создавая единообразный формат написания (верхний или нижний регистр) для всех строковых значений в ваших моделях данных, вы создаете определенные ожидания для бизнес-пользователей в вашем BI-инструменте.

Скорее всего, никогда не будет 100% согласованности в ваших моделях данных, но делая все возможное, чтобы уменьшить этот хаос, вы облегчите жизнь себе и вашим бизнес-пользователям. Используйте функцию LOWER, чтобы создать единообразное написание для всех строк в ваших источниках данных.