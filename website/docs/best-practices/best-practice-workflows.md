---
title: "Лучшие практики для рабочих процессов"
id: "best-practice-workflows"
---

Эта страница содержит коллективную мудрость опытных пользователей dbt о том, как лучше всего использовать его в вашей аналитической работе. Соблюдение этих лучших практик поможет вашей аналитической команде работать максимально эффективно, а внедрение профессиональных советов добавит изящества вашим проектам dbt!

## Лучшие практики рабочих процессов

### Управляйте своим проектом dbt с помощью системы контроля версий
Все проекты dbt должны управляться с помощью системы контроля версий. Следует создавать ветки Git для управления разработкой новых функций и исправлений ошибок. Все изменения кода должны быть проверены коллегой (или вами) в Pull Request перед слиянием с вашей производственной веткой, такой как `main`.

:::info Руководство по Git

Мы зафиксировали наши лучшие практики в Git в нашем [руководстве по Git](https://github.com/dbt-labs/corp/blob/main/git-guide.md).

:::

### Используйте отдельные среды разработки и производства
dbt упрощает поддержание отдельных производственных и развивающихся сред с помощью использования целей в профиле. Мы рекомендуем использовать цель `dev`, когда вы запускаете dbt из командной строки, и запускать только против цели `prod`, когда вы работаете из производственного развертывания. Вы можете узнать больше [о управлении средами здесь](/docs/environments-in-dbt).

### Используйте стиль для вашего проекта
Стиль SQL, соглашения о наименовании полей и другие правила для вашего проекта dbt должны быть зафиксированы, особенно в проектах, где несколько пользователей dbt пишут код.

:::info Наш стиль

Мы сделали наше [руководство по стилю](/best-practices/how-we-style/0-how-we-style-our-dbt-projects) публичным – это может стать хорошей отправной точкой для вашего собственного руководства по стилю.

:::


## Лучшие практики в проектах dbt
### Используйте функцию ref
Функция [ref](/reference/dbt-jinja-functions/ref) делает dbt таким мощным! Использование функции `ref` позволяет dbt выводить зависимости, обеспечивая правильный порядок построения моделей. Это также гарантирует, что ваша текущая модель выбирает из вышестоящих таблиц и <Term id="view">представлений</Term> в той же среде, в которой вы работаете. Всегда используйте функцию `ref`, когда выбираете из другой модели, а не используйте прямую ссылку на отношение (например, `my_schema.my_table`).

### Ограничьте ссылки на необработанные данные
Ваш проект dbt будет зависеть от необработанных данных, хранящихся в вашей базе данных. Поскольку эти данные обычно загружаются третьими сторонами, их структура может изменяться со временем – таблицы и столбцы могут добавляться, удаляться или переименовываться. Когда это происходит, обновлять модели проще, если необработанные данные ссылаются только в одном месте.

:::info Использование источников для ссылок на необработанные данные

Мы рекомендуем определять ваши необработанные данные как [источники](/docs/build/sources) и выбирать из источника, а не использовать прямую ссылку на отношение. В наших проектах dbt нет никаких прямых ссылок на отношения в моделях.

:::

### Переименовывайте и переклассифицируйте поля один раз
Необработанные данные обычно хранятся в структуре, соответствующей источнику, то есть следуют схеме и соглашениям о наименовании, которые определяет источник. Эта структура не только будет отличаться между различными источниками, но также, вероятно, будет отличаться от соглашений о наименовании, которые вы хотите использовать для аналитики.

Первый уровень преобразований в проекте dbt должен:
* Выбирать только из одного источника
* Переименовывать поля и таблицы, чтобы соответствовать соглашениям, которые вы хотите использовать в своем проекте, например, гарантируя, что все временные метки называются `<event>_at`. Эти соглашения должны быть зафиксированы в ваших кодовых соглашениях проекта (см. выше).
* Переклассифицировать поля в правильный тип данных, например, изменяя даты на UTC и цены на долларовые суммы.

Все последующие модели данных должны строиться на основе этих моделей, уменьшая количество дублируемого кода.

:::info Что произошло с базовыми моделями?

Ранее в этой документации рекомендовалось реализовывать "базовые модели" как первый уровень преобразования и давались советы по SQL внутри этих моделей. Мы поняли, что хотя причины, стоящие за этой конвенцией, были обоснованными, конкретные советы по "базовым моделям" представляли собой мнение, поэтому мы убрали это из официальной документации.

Вы можете вместо этого найти наши мнения о [том, как мы структурируем наши проекты dbt](/best-practices/how-we-structure/1-guide-overview).

:::

### Разделяйте сложные модели на более мелкие части
Сложные модели часто включают несколько Общих Табличных Выражений (<Term id="cte">CTE</Term>). В dbt вы можете вместо этого разделить эти CTE на отдельные модели, которые строятся друг на друге. Часто разумно разбивать сложные модели, когда:
* CTE дублируется в двух моделях. Разделение CTE на отдельную модель позволяет вам ссылаться на модель из любого количества последующих моделей, уменьшая дублирование кода.
* CTE изменяет <Term id="grain" /> данных, из которых он выбирает. Часто полезно тестировать любые преобразования, которые изменяют зерно (то есть, что представляет собой одна запись) ваших данных. Разделение CTE на отдельную модель позволяет вам тестировать это преобразование независимо от более крупной модели.
* SQL в запросе содержит много строк. Разделение CTE на отдельные модели может уменьшить когнитивную нагрузку, когда другой пользователь dbt (или ваше будущее "я") смотрит на код.

### Группируйте свои модели в директории
Внутри вашей директории `models/` вы можете иметь любое количество вложенных поддиректорий. Мы активно используем директории, так как использование вложенной структуры в директориях упрощает:
* Настройку групп моделей, указывая конфигурации в вашем файле `dbt_project.yml`.
* Запуск подсекций вашего DAG, используя [синтаксис выбора модели](/reference/node-selection/syntax).
* Общение шагов моделирования с коллегами
* Создание соглашений о допустимых вышестоящих зависимостях модели, например, "модели в директории `marts` могут выбирать только из других моделей в директории `marts` или из моделей в директории `staging`".

### Добавляйте тесты к вашим моделям
dbt предоставляет структуру для тестирования предположений о результатах, генерируемых моделью. Добавление тестов в проект помогает обеспечить уверенность в том, что как:
* ваш SQL преобразует данные так, как вы ожидаете, и
* ваши исходные данные содержат ожидаемые значения

:::info Рекомендуемые тесты

Наше [руководство по стилю](https://github.com/dbt-labs/corp/blob/main/dbt_style_guide.md) рекомендует, чтобы как минимум каждая модель имела <Term id="primary-key" />, который тестируется на уникальность и отсутствие нулевых значений.

:::

### Учитывайте информационную архитектуру вашего хранилища данных
Когда пользователь подключается к <Term id="data-warehouse" /> через SQL-клиент, он часто полагается на названия схем, отношений и столбцов, чтобы понять данные, которые ему представлены. Для улучшения информационной архитектуры хранилища данных мы:

* Используем [пользовательские схемы](/docs/build/custom-schemas) для разделения отношений на логические группы или скрытия промежуточных моделей в отдельной схеме. Обычно эти пользовательские схемы соответствуют директориям, которые мы используем для группировки наших моделей, и настраиваются из файла `dbt_project.yml`.
* Используем префиксы в названиях <Term id="table" /> (например, `stg_`, `fct_` и `dim_`), чтобы указать, какие отношения должны запрашиваться конечными пользователями.

### Обдумайте свои материализации
[<Term id="materialization" />](/docs/build/materializations) определяют способ построения моделей через конфигурацию. В общем случае:
* Представления быстрее строятся, но медленнее запрашиваются по сравнению с таблицами.
* Инкрементальные модели обеспечивают такую же производительность запросов, как таблицы, быстрее строятся по сравнению с таблицей <Term id="materialization" />, однако они вводят сложность в проект.

Мы часто:
* Используем представления по умолчанию
* Используем эфемерные модели для легких преобразований, которые не должны быть доступны конечным пользователям
* Используем таблицы для моделей, которые запрашиваются BI-инструментами
* Используем таблицы для моделей, которые имеют несколько потомков
* Используем инкрементальные модели, когда время сборки для таблиц превышает допустимый порог 

## Профессиональные советы для рабочих процессов
### Используйте синтаксис выбора модели при локальном запуске
При разработке часто имеет смысл запускать только ту модель, над которой вы активно работаете, и любые последующие модели. Вы можете выбрать, какие модели запускать, используя [синтаксис выбора модели](/reference/node-selection/syntax).

### Запускайте только измененные модели для тестирования изменений ("узкий CI")
Чтобы с уверенностью объединить изменения кода, вы хотите знать, что эти изменения не вызовут сбоев в других частях вашего проекта. По этой причине мы рекомендуем запускать модели и тесты в изолированной среде, отделенной от ваших производственных данных, в качестве автоматической проверки в вашем рабочем процессе git. (Если вы используете GitHub и dbt Cloud, прочитайте о [настройке CI задач](/docs/deploy/ci-jobs).

В то же время, запуск и тестирование всех моделей в вашем проекте занимает время (и деньги). Эта неэффективность особенно болезненно ощущается, если ваш PR предлагает изменения только для нескольких моделей.

Сравнивая с артефактами из предыдущего производственного запуска, dbt может определить, какие модели были изменены, и построить их на основе их неизмененных родителей.

```bash
dbt run -s state:modified+ --defer --state path/to/prod/artifacts
dbt test -s state:modified+ --defer --state path/to/prod/artifacts
```

Сравнивая с артефактами из предыдущего производственного запуска, dbt может определить статусы моделей и результатов тестов.

- `result:fail`
- `result:error`
- `result:warn`
- `result:success`
- `result:skipped`
- `result:pass`

Для более умных повторных запусков используйте селектор `result:<status>` вместо того, чтобы вручную переопределять команды dbt с моделями в области действия.
```bash
dbt run --select state:modified+ result:error+ --defer --state path/to/prod/artifacts
```
  - Повторно запустите все мои ошибочные модели И запустите изменения, которые я сделал одновременно, которые могут относиться к ошибочным моделям для последующего использования

```bash
dbt build --select state:modified+ result:error+ --defer --state path/to/prod/artifacts
```
  - Повторно запустите и протестируйте все мои ошибочные модели И запустите изменения, которые я сделал одновременно, которые могут относиться к ошибочным моделям для последующего использования

```bash
dbt build --select state:modified+ result:error+ result:fail+ --defer --state path/to/prod/artifacts
```
  - Повторно запустите все мои ошибочные модели И все мои неудачные тесты
  - Повторно запустите все мои ошибочные модели И запустите изменения, которые я сделал одновременно, которые могут относиться к ошибочным моделям для последующего использования
  - Есть неудавшийся тест, который не связан с измененными или ошибочными узлами (например, тест источника, который нужно обновить, чтобы пройти)

```bash
dbt test --select result:fail --exclude <example test> --defer --state path/to/prod/artifacts
```
  - Повторно запустите все мои неудавшие тесты и исключите тесты, которые я знаю, что все равно потерпят неудачу
  - Это может относиться к обновлениям в исходных данных во время процесса "EL", которые необходимо повторно запустить после их обновления

> Примечание: Если вы используете флаг `--state target/`, флаги `result:error` и `result:fail` могут быть выбраны одновременно (в одной команде) только при использовании команды `dbt build`. `dbt test` перезапишет `run_results.json` из `dbt run` в предыдущем вызове команды.

Поддерживается только в версиях 1.1 или новее.

Сравнивая с артефактом `sources.json` из предыдущего производственного запуска с текущим артефактом `sources.json`, dbt может определить, какие источники более свежие, и запустить последующие модели на их основе.

```bash
# задача 1
dbt source freshness # должен быть запущен, чтобы получить предыдущее состояние
```

Проверьте все мои источники, которые более свежие, чем предыдущий запуск, и запустите и протестируйте все модели, находящиеся ниже них:

```bash
# задача 2
dbt source freshness # должен быть запущен снова, чтобы сравнить текущее с предыдущим состоянием
dbt build --select source_status:fresher+ --state path/to/prod/artifacts
```

Чтобы узнать больше, прочитайте документацию о [состоянии](/reference/node-selection/syntax#about-node-selection).

## Профессиональные советы для проектов dbt
### Ограничьте обрабатываемые данные при разработке
В среде разработки более быстрые времена выполнения позволяют вам быстрее итеративно разрабатывать код. Мы часто ускоряем наши запуски, используя шаблон, который ограничивает данные на основе имени [target](/reference/dbt-jinja-functions/target):
```sql
select
*
from event_tracking.events
{% if target.name == 'dev' %}
where created_at >= dateadd('day', -3, current_date)
{% endif %}
```

### Используйте хуки для управления привилегиями на объекты, которые создает dbt
Используйте операторы `grant` из [хуков](/docs/build/hooks-operations), чтобы гарантировать, что разрешения применяются к объектам, созданным dbt. Зафиксировав эти операторы grant в хуках, вы можете управлять версиями и повторно применять эти разрешения.

:::info Рекомендуемые операторы grant

Мы поделились точными операторами grant, которые мы используем, на [Discourse](https://discourse.getdbt.com/t/the-exact-grant-statements-we-use-in-a-dbt-project/430)

:::

### Разделяйте трансформации, ориентированные на источник, и трансформации, ориентированные на бизнес
При моделировании данных мы часто обнаруживаем, что есть два этапа:

1. Трансформации, ориентированные на источник, для преобразования данных из различных источников в согласованную структуру, например, переименование и переклассификация столбцов, объединение, соединение или дедупликация исходных данных, чтобы гарантировать, что ваша модель имеет правильное зерно; и
2. Трансформации, ориентированные на бизнес, которые преобразуют данные в модели, представляющие сущности и процессы, относящиеся к вашему бизнесу, или реализуют бизнес-определения в SQL.

Мы находим наиболее полезным разделять эти два типа трансформаций на разные модели, чтобы сделать различие между логикой, ориентированной на источник, и логикой, ориентированной на бизнес, ясным.

### Управление пробелами, создаваемыми Jinja
Если вы используете макросы или другие элементы Jinja в своих моделях, ваш скомпилированный SQL (находится в директории `target/compiled`) может содержать нежелательные пробелы. Ознакомьтесь с [документацией Jinja](http://jinja.pocoo.org/docs/2.10/templates/#whitespace-control), чтобы узнать, как контролировать создаваемые пробелы.