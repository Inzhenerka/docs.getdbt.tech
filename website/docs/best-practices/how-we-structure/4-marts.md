---
title: "Марты: Определенные бизнесом сущности"
id: "4-marts"
---

:::info
Наши рекомендации здесь различаются в зависимости от того, используете ли вы dbt Semantic Layer. В проекте без Semantic Layer мы рекомендуем сильно денормализовать данные, согласно приведенным ниже лучшим практикам. С другой стороны, если вы используете Semantic Layer, мы хотим оставаться как можно более нормализованными, чтобы предоставить MetricFlow максимальную гибкость. Рекомендации по мартам в контексте Semantic Layer находятся на следующей странице.
:::

Это уровень, где все собирается вместе, и мы начинаем организовывать все наши атомы (модели подготовки) и молекулы (промежуточные модели) в полноценные ячейки, которые имеют свою идентичность и цель. Мы иногда называем это _слоем сущностей_ или _концептуальным слоем_, чтобы подчеркнуть, что все наши марты предназначены для представления конкретной сущности или концепции на ее уникальном уровне детализации. Например, заказ, клиент, территория, событие клика, платеж — каждая из этих сущностей будет представлена отдельным мартом, и каждая строка будет представлять собой отдельный экземпляр этих концепций. В отличие от традиционной схемы звезды Кимбала, в современных хранилищах данных — где хранение данных дешевое, а вычисления дорогие — мы с радостью заимствуем и добавляем любые данные из других концепций, которые имеют отношение к ответам на вопросы о основной сущности марта. Создание одних и тех же данных в нескольких местах, как мы делаем с `orders` в нашем примере с мартом `customers` ниже, более эффективно в этой парадигме, чем многократное повторное соединение этих концепций (это базовое определение денормализации в этом контексте). Давайте посмотрим, как мы подходим к этому первому слою, предназначенному специально для представления конечным пользователям.

### Марты: Файлы и папки

Последний слой наших основных преобразований представлен ниже, предоставляя модели как для финансового, так и для маркетингового отделов.

```shell
models/marts
├── finance
│   ├── _finance__models.yml
│   ├── orders.sql
│   └── payments.sql
└── marketing
    ├── _marketing__models.yml
    └── customers.sql
```

✅ **Группируйте по отделам или областям интересов.** Если у вас меньше 10 мартов, вам может не понадобиться много подпапок, поэтому, как и на промежуточном уровне, не переусердствуйте с оптимизацией слишком рано. Если вы все же обнаружите, что вам нужно добавить больше структуры и группировки, используйте полезные бизнес-концепции. На уровне мартов нас больше не беспокоит согласованность данных источников, поэтому группировка по отделам (маркетинг, финансы и т.д.) является наиболее распространенной структурой на этом этапе.

✅ **Назовите по сущности.** Используйте простой английский язык для названия файла на основе концепции, которая формирует уровень детализации марта, например `customers`, `orders`. Марты, которые не включают временные агрегаты (чистые марты), не должны иметь временное измерение (`orders_per_day`), которое обычно лучше всего фиксируется через метрики.

❌ **Создавайте одну и ту же концепцию по-разному для разных команд.** `finance_orders` и `marketing_orders` обычно считаются антипаттерном. Как всегда, есть исключения — распространенный паттерн, который мы наблюдаем, заключается в том, что у финансов могут быть специфические потребности, например, отчетность по доходам для правительства, которая отличается от того, как компания в целом измеряет доход в повседневной жизни. Просто убедитесь, что эти концепции четко спроектированы и понятны как _отдельные_ концепции, а не как представления по отделам одной и той же концепции: `tax_revenue` и `revenue`, а не `finance_revenue` и `marketing_revenue`.

### Марты: Модели

Наконец, мы рассмотрим лучшие практики для моделей в каталоге мартов, изучив две модели наших мартов. Это бизнес-согласованные — то есть, созданные в соответствии с нашим видением и потребностями — сущности, которые мы собирали вместе, чтобы создать.

```sql
-- orders.sql

with

orders as  (

    select * from {{ ref('stg_jaffle_shop__orders' )}}

),

order_payments as (

    select * from {{ ref('int_payments_pivoted_to_orders') }}

),

orders_and_order_payments_joined as (

    select
        orders.order_id,
        orders.customer_id,
        orders.order_date,
        coalesce(order_payments.total_amount, 0) as amount,
        coalesce(order_payments.gift_card_amount, 0) as gift_card_amount

    from orders

    left join order_payments on orders.order_id = order_payments.order_id

)

select * from orders_and_payments_joined
```

```sql
-- customers.sql

with

customers as (

    select * from {{ ref('stg_jaffle_shop__customers')}}

),

orders as (

    select * from {{ ref('orders')}}

),

customer_orders as (

    select
        customer_id,
        min(order_date) as first_order_date,
        max(order_date) as most_recent_order_date,
        count(order_id) as number_of_orders,
        sum(amount) as lifetime_value

    from orders

    group by 1

),

customers_and_customer_orders_joined as (

    select
        customers.customer_id,
        customers.first_name,
        customers.last_name,
        customer_orders.first_order_date,
        customer_orders.most_recent_order_date,
        coalesce(customer_orders.number_of_orders, 0) as number_of_orders,
        customer_orders.lifetime_value

    from customers

    left join customer_orders on customers.customer_id = customer_orders.customer_id

)

select * from customers_and_customer_orders_joined
```

- ✅ **Материализуйте как таблицы или инкрементальные модели.** Как только мы достигаем уровня мартов, пора начинать строить не только нашу логику в хранилище, но и сами данные. Это обеспечивает конечным пользователям гораздо более быструю производительность для этих более поздних моделей, которые на самом деле предназначены для их использования, и экономит нам затраты на повторные вычисления этих цепочек моделей каждый раз, когда кто-то обновляет панель инструментов или запускает регрессию в Python. Хорошее общее правило по материализации — всегда начинать с представления (так как оно занимает практически нулевое место для хранения и всегда дает актуальные результаты), как только это представление начинает слишком долго _запрашиваться_, преобразуйте его в таблицу, и, наконец, когда эта таблица начинает слишком долго _строиться_ и замедляет ваши запуски, [настройте ее как инкрементальную модель](https://docs.getdbt.com/docs/build/incremental-models/). Как всегда, начинайте с простого и добавляйте сложность только по мере необходимости. Модели с наибольшими объемами данных и вычислительно интенсивными преобразованиями должны обязательно использовать отличные возможности инкрементальной материализации dbt, но стремление сделать все ваши модели мартов инкрементальными по умолчанию приведет к излишним трудностям. Мы рекомендуем прочитать этот [классический пост Тристана о пределах инкрементального моделирования](https://discourse.getdbt.com/t/on-the-limits-of-incrementality/303).
- ✅ **Широкие и денормализованные.** В отличие от старых хранилищ данных, в современном стеке данных хранение данных дешевое, а вычисления дорогие и должны быть приоритетом, упаковывая их в очень широкие денормализованные концепции, которые могут предоставить все, что кому-то нужно о концепции как цели.
- ❌ **Слишком много соединений в одном марте.** Одно хорошее правило при построении преобразований dbt — избегать объединения слишком многих концепций в одном марте. Что считается «слишком многим» может варьироваться. Если вам нужно объединить 8 моделей подготовки с простыми соединениями, это может быть нормально. Напротив, если у вас есть 4 концепции, которые вы связываете с помощью сложных и вычислительно тяжелых оконных функций, это может быть слишком много. Вам нужно взвесить количество моделей, которые вы соединяете, против сложности логики внутри марта, и если это слишком сложно для восприятия и построения четкой ментальной модели, то стоит рассмотреть возможность модульного подхода. Хотя это не жесткое правило, если вы объединяете более 4 или 5 концепций для создания вашего марта, вам может быть полезно добавить несколько промежуточных моделей для большей ясности. Две промежуточные модели, которые объединяют по три концепции каждая, и март, который объединяет эти две промежуточные модели, обычно приведут к гораздо более читаемой цепочке логики, чем один март с шестью соединениями.
- ✅ **Стройте на отдельных мартов с умом.** Хотя мы стремимся сохранить сужающуюся DAG до уровня мартов, как только мы здесь, вещи могут стать немного менее строгими. Распространенный пример — передача информации между мартами на разных уровнях детализации, как мы видели выше, когда мы переносим наш март `orders` в наши март `customers`, чтобы агрегировать критические данные о заказах в уровне детализации `customer`. Теперь, когда мы действительно «тратим» вычисления и хранение, фактически создавая данные в наших выходных данных, разумно использовать ранее построенные ресурсы, чтобы ускорить и сэкономить затраты на выходные данные, которые требуют аналогичных данных, вместо того чтобы повторно вычислять одни и те же представления и CTE с нуля. Правильный подход здесь сильно зависит от вашей уникальной DAG, моделей и целей — важно отметить, что использование марта при построении другого, более позднего марта допустимо, но требует тщательного рассмотрения, чтобы избежать ненужных затрат ресурсов или циклических зависимостей.

:::tip Марты имеют уровень детализации сущностей.
Самый важный аспект мартов заключается в том, что они содержат все полезные данные о _конкретной сущности_ на детализированном уровне. Это не означает, что мы не включаем множество других сущностей и концепций, например, много данных о `user` в наш март `orders`, мы это делаем! Это просто означает, что отдельные `orders` остаются основной деталью нашей таблицы. Если мы начинаем группировать `users` и `orders` вдоль [даты](https://github.com/dbt-labs/dbt-utils#date_spine-source), в нечто вроде `user_orders_per_day`, мы выходим за рамки мартов в _метрики_.
:::

### Марты: Другие соображения

- **Устранение неполадок через таблицы.** Хотя идеальным вариантом в производстве является создание стеков представлений и эфемерных моделей до наших мартов — только создавая данные в хранилище в конце цепочки, когда у нас есть модели, с которыми мы действительно хотим, чтобы конечные пользователи работали — это может создать некоторые трудности в разработке. В частности, определенные ошибки могут казаться возникающими в наших более поздних моделях, которые на самом деле происходят из гораздо более ранних зависимостей в нашей цепочке моделей (модели-предки в нашей DAG, которые создаются до того, как модель вызывает ошибки). Если у вас возникают трудности с определением того, где или что говорит вам ошибка базы данных, может быть полезно временно создать конкретную цепочку моделей в виде таблиц, чтобы хранилище выдало ошибку там, где она на самом деле происходит.

### dbt Semantic Layer и марты

Наши структурные рекомендации сильно зависят от того, используете ли вы dbt Semantic Layer. Если вы используете Semantic Layer, мы рекомендуем более нормализованный подход к вашим мартам. Если вы не используете Semantic Layer, мы рекомендуем более денормализованный подход, который стал типичным в проектах dbt. Для полного списка рекомендаций по структуре, наименованию и организации в Semantic Layer ознакомьтесь с руководством [Как мы строим наши метрики](/best-practices/how-we-build-our-metrics/semantic-layer-1-intro), особенно с разделом [Рефакторинг существующего агрегата](/best-practices/how-we-build-our-metrics/semantic-layer-8-refactor-a-rollup).
