---
title: "Промежуточный: Специально разработанные шаги трансформации"
id: "3-intermediate"
description: Специально разработанные шаги трансформации.
displayText: Специально разработанные шаги трансформации.
hoverSnippet: Специально разработанные шаги трансформации.
---

Как только мы подготовим наши атомы к работе, мы начнем объединять их в более сложные, взаимосвязанные молекулы. Промежуточный уровень — это место, где живут эти молекулы, создавая разнообразные формы с конкретными целями на пути к более сложным белкам и клеткам, которые мы будем использовать для оживления наших данных.

### Промежуточный: Файлы и папки

Давайте взглянем на промежуточный уровень нашего проекта, чтобы более конкретно понять цель этого этапа.

```shell
models/intermediate
└── finance
    ├── _int_finance__models.yml
    └── int_payments_pivoted_to_orders.sql
```

- **Папки**
  - ✅ **Подкаталоги на основе бизнес-групп.** Подобно уровню подготовки, мы разместим этот уровень моделей внутри собственного подпапки `intermediate`. В отличие от уровня подготовки, здесь мы переходим к бизнес-ориентированным концепциям, разделяя наши модели не по источнику данных, а по области бизнес-заинтересованности.
- **Имена файлов**
  - `✅ int_[сущность]s_[глагол]s.sql` - разнообразие трансформаций, которые могут происходить на промежуточном уровне, затрудняет строгое определение имен. Лучший принцип — думать о _глаголах_ (например, `pivoted`, `aggregated_to_user`, `joined`, `fanned_out_by_quantity`, `funnel_created` и т.д.) на промежуточном уровне. В нашем примере проекта мы используем промежуточную модель для преобразования платежей в зерно заказов, поэтому мы называем нашу модель `int_payments_pivoted_to_orders`. Это позволяет любому быстро понять, что происходит в этой модели, даже если они не знают [SQL](https://mode.com/sql-tutorial/). Эта ясность стоит длинного имени файла. Важно отметить, что на этом уровне мы убрали двойные подчеркивания. Переходя к бизнес-ориентированным концепциям, нам больше не нужно разделять систему и сущность, и мы просто ссылаемся на объединенную сущность, если это возможно. В случаях, когда вам нужно, чтобы промежуточные модели работали на уровне источника данных (например, `int_shopify__orders_summed`, `int_core__orders_summed`, которые вы позже объедините), вы сохраните двойные подчеркивания. Некоторые предпочитают разделять сущность и глаголы двойными подчеркиваниями. Это вопрос предпочтения, но на нашем опыте часто существует внутренняя связь между сущностями и глаголами на этом уровне, что делает это трудным для поддержания.

:::tip Не переусердствуйте с оптимизацией слишком рано!
Пример проекта очень прост для иллюстративных целей. Этот уровень разделения в наших пост-стадийных слоях, вероятно, излишен, когда речь идет о таком небольшом количестве моделей. Помните, наша цель — это _единственный_ _источник правды._ Мы не хотим, чтобы финансы и маркетинг работали с отдельными моделями `orders`, мы хотим использовать наш проект dbt как средство для объединения этих определений! Поэтому не разделяйте и не оптимизируйте слишком рано. Если у вас менее 10 моделей marts и у вас нет проблем с их разработкой и использованием, не стесняйтесь полностью отказаться от подкаталогов (за исключением уровня подготовки, где вы всегда должны их реализовывать, добавляя новые источники данных в ваш проект) до тех пор, пока проект не вырастет до того, что они действительно понадобятся. Использование dbt всегда связано с упрощением сложности.
:::

### Промежуточный: Модели

Ниже представлена единственная промежуточная модель из нашего небольшого примера проекта. Это представляет собой отличный случай использования в соответствии с нашими принципами, служа четкой единой цели: группировка и преобразование модели подготовки в другое зерно. Она использует немного Jinja, чтобы сделать модель более DRY (стремление к DRY относится к коду, который мы пишем внутри одной модели, а также к трансформациям по всему коду), но не пугайтесь, если вы еще не совсем уверены в [Jinja](/docs/build/jinja-macros). Смотря на имя <Term id="cte">CTE</Term>, `pivot_and_aggregate_payments_to_order_grain`, мы получаем очень четкое представление о том, что происходит внутри этого блока. Называя трансформации, происходящие внутри наших CTE в модели, так же описательно, как мы делаем это с нашими файлами и папками, даже заинтересованное лицо, не знающее SQL, сможет понять цель этого раздела, если не сам код. Когда вы начинаете писать более сложные трансформации, выходя из уровня подготовки, имейте это в виду. Таким же образом, как наши модели соединяются в DAG и рассказывают историю наших трансформаций на макроуровне, CTE могут делать это на меньшем уровне внутри наших файлов модели.

```sql
-- int_payments_pivoted_to_orders.sql

{%- set payment_methods = ['bank_transfer','credit_card','coupon','gift_card'] -%}

with

payments as (

   select * from {{ ref('stg_stripe__payments') }}

),

pivot_and_aggregate_payments_to_order_grain as (

   select
      order_id,
      {% for payment_method in payment_methods -%}

         sum(
            case
               when payment_method = '{{ payment_method }}' and
                    status = 'success'
               then amount
               else 0
            end
         ) as {{ payment_method }}_amount,

      {%- endfor %}
      sum(case when status = 'success' then amount end) as total_amount

   from payments

   group by 1

)

select * from pivot_and_aggregate_payments_to_order_grain
```

- ❌ **Доступно конечным пользователям.** Промежуточные модели обычно не должны быть доступны в основной производственной схеме. Они не предназначены для вывода в конечные цели, такие как панели управления или приложения, поэтому лучше держать их отдельно от моделей, которые предназначены для этого, чтобы вы могли легче контролировать управление данными и их обнаружение.
- ✅ **Материализованы эфемерно.** Учитывая вышеизложенное, одним из популярных вариантов является установка промежуточных моделей по умолчанию как [эфемерных](/docs/build/materializations#ephemeral). Это, как правило, лучшее место для начала для простоты. Это позволит избежать ненужных моделей в вашем хранилище с минимальной конфигурацией. Однако имейте в виду, что простота эфемерных моделей немного усложняет отладку, так как они интерполируются в модели, которые ссылаются на них, а не существуют самостоятельно, так что вы можете просмотреть их вывод.
- ✅ **Материализованы как представления в пользовательской схеме с особыми правами.** Более надежный вариант — материализовать ваши промежуточные модели как представления в определенной [пользовательской схеме](/docs/build/custom-schemas), вне вашей основной производственной схемы. Это дает вам дополнительное понимание разработки и упрощает отладку по мере роста числа и сложности ваших моделей, оставаясь при этом простым в реализации и занимая незначительное пространство.

:::tip Держите ваше хранилище в порядке!
Существует три интерфейса для организационной графовой структуры знаний, которую мы кодируем в dbt: DAG, структура файлов и папок нашего кода и вывод в хранилище. Поэтому очень важно, чтобы мы намеренно рассматривали этот вывод! Рассматривайте схемы, таблицы и представления, которые мы создаем в хранилище, как _часть UX_, помимо панелей управления, ML, приложений и других случаев использования, которые вы можете нацеливать на данные. Обеспечение того, чтобы наш вывод был хорошо назван и сгруппирован, а модели, не предназначенные для широкого использования, либо не материализовались, либо строились в специальных областях с определенными правами, имеет решающее значение для достижения этой цели.
:::

- Цели промежуточных моделей, так как они служат для разбиения сложности наших моделей marts, могут принимать множество форм, которые могут потребоваться для [трансформации данных](https://www.getdbt.com/analytics-engineering/transformation/). Некоторые из самых распространенных случаев использования промежуточных моделей включают:

  - ✅ **Структурное упрощение.** Объединение разумного количества (обычно от 4 до 6) сущностей или концепций (моделей подготовки или, возможно, других промежуточных моделей), которые будут объединены с другой промежуточной моделью аналогичного назначения для генерации marts — вместо того, чтобы иметь 10 соединений в нашем marts, мы можем объединить две промежуточные модели, каждая из которых содержит часть сложности, что дает нам повышенную читаемость, гибкость, область тестирования и понимание наших компонентов.
  - ✅ **Изменение зерна.** Промежуточные модели часто используются для разветвления или сжатия моделей до правильного составного зерна — если мы строим marts для `order_items`, который требует разветвления наших `orders` на основе столбца `quantity`, создание новой строки для каждого элемента было бы идеальным для выполнения в конкретной промежуточной модели, чтобы сохранить ясность в нашем marts и легче увидеть, что наше зерно правильно, прежде чем мы смешаем его с другими компонентами.
  - ✅ **Изоляция сложных операций.** Полезно переместить любые особенно сложные или трудные для понимания логические части в их собственные промежуточные модели. Это не только упрощает их уточнение и отладку, но и упрощает последующие модели, которые могут ссылаться на эту концепцию более читаемым образом. Например, в приведенном выше примере разветвления `quantity` мы выигрываем, изолируя этот сложный логический элемент, чтобы мы могли быстро отлаживать и тщательно тестировать эту трансформацию, а последующие модели могут ссылаться на `order_items` таким образом, который интуитивно легко понять.

:::tip Уменьшите DAG, увеличьте таблицы.
Пока мы не дойдем до уровня marts и не начнем строить наши различные выходы, мы, как правило, хотим, чтобы наш DAG выглядел как стрелка, направленная вправо. Переходя от источника к бизнесу, мы также переходим от многочисленных, узких, изолированных концепций к меньшему количеству, более широким, объединенным концепциям. Мы объединяем наши компоненты в более широкие, более богатые концепции, и это создает такую форму в нашем DAG. Таким образом, когда мы дойдем до уровня marts, у нас будет надежный набор компонентов, которые можно быстро и легко настроить в любую конфигурацию для ответа на различные вопросы и удовлетворения конкретных потребностей. Одно из правил, чтобы убедиться, что вы следуете этой схеме на уровне отдельной модели, — это позволить нескольким _входам_ в модель, но **не** нескольким _выходам_. Несколько стрелок, идущих _в_ наши пост-стадийные модели, — это хорошо и ожидаемо, несколько стрелок, выходящих _из_ них, — это тревожный сигнал. Безусловно, есть ситуации, когда вам нужно нарушить это правило, но это то, о чем стоит помнить, быть осторожным и избегать, когда это возможно.
:::