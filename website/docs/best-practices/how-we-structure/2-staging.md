---
title: "Стадия: Подготовка наших атомных строительных блоков"
id: 2-staging
description: Подготовка наших атомных строительных блоков.
displayText: Подготовка наших атомных строительных блоков.
hoverSnippet: Подготовка наших атомных строительных блоков.
---

Стадия — это место, где начинается наше путешествие. Это основа нашего проекта, где мы собираем все отдельные компоненты, которые будем использовать для создания более сложных и полезных моделей.

В этом руководстве мы будем использовать аналогию для работы с dbt: мыслить модульно в терминах атомов, молекул и более сложных выходов, таких как белки или клетки (приносим извинения заранее всем химикам или биологам за наше неизбежное преувеличение этой метафоры). В рамках этой аналогии, если данные из нашей исходной системы — это суп из сырой энергии и кварков, то вы можете рассматривать стадию как процесс конденсации и очистки этого материала в отдельные атомы, из которых мы позже будем строить более сложные и полезные структуры.

### Стадия: Файлы и папки

Давайте подробнее рассмотрим директорию стадии в нашем дереве файлов `models` [в обзоре](/best-practices/how-we-structure/1-guide-overview) и разберемся, что здесь происходит.

- **Папки.** Структура папок имеет огромное значение в dbt. Нам нужна последовательная структура, чтобы ориентироваться в кодовой базе, как и в любом программном проекте, но наша структура папок также является одним из ключевых интерфейсов для понимания графа знаний, закодированного в нашем проекте (наряду с DAG и данными, выводимыми в нашем хранилище). Она должна отражать, как данные перемещаются, шаг за шагом, от множества моделей, соответствующих источнику, к меньшему количеству более богатых моделей, соответствующих бизнесу. Более того, мы можем использовать нашу структуру папок как средство выбора в синтаксисе dbt [selector syntax](https://docs.getdbt.com/reference/node-selection/syntax). Например, с вышеуказанной структурой, если мы загрузили свежие данные из Stripe и хотим запустить все модели, которые строятся на наших данных Stripe, мы можем легко выполнить `dbt build --select staging.stripe+`, и мы готовы к созданию более актуальных отчетов о платежах.
  - ✅ **Подкаталоги на основе системы источника.** Наша внутренняя транзакционная база данных — это одна система, данные, которые мы получаем из API Stripe — это другая, и, наконец, события из нашей Snowplow-инструментации. Мы обнаружили, что это лучшее группирование для большинства компаний, так как системы источников, как правило, имеют схожие методы загрузки и свойства между таблицами, и это позволяет нам легко работать с этими схожими наборами.
  - ❌ **Подкаталоги на основе загрузчика.** Некоторые люди пытаются группировать по тому, как данные загружаются (Fivetran, Stitch, пользовательские синхронизации), но это слишком обширно, чтобы быть полезным в проекте реального размера.
  - ❌ **Подкаталоги на основе бизнес-группировки.** Другой подход, который мы не рекомендуем, — это разделение по бизнес-группам на стадии и создание подкаталогов, таких как 'маркетинг', 'финансы' и т.д. Ключевой целью любого отличного проекта dbt должно быть установление единого источника правды. Разделяя вещи слишком рано, мы открываем себя для создания перекрытий и конфликтующих определений (подумайте о том, что у маркетинга и финансирования могут быть разные основные таблицы для заказов). Мы хотим, чтобы все строили с одним набором атомов, поэтому, по нашему опыту, начинать наши преобразования с нашей структуры стадии, отражающей структуры системы источника, — это лучший уровень группировки для этого этапа.
- **Имена файлов.** Создание последовательного шаблона именования файлов является [критически важным в dbt](https://docs.getdbt.com/blog/on-the-importance-of-naming). Имена файлов должны быть уникальными и соответствовать имени модели, когда они выбираются и создаются в хранилище. Мы рекомендуем включать как можно больше четкой информации в имя файла, включая префикс для слоя, в котором существует модель, важную информацию о группировке и конкретную информацию о сущности или преобразовании в модели.
  - ✅ `stg_[source]__[entity]s.sql` - двойное подчеркивание между системой источника и сущностью помогает визуально различать отдельные части в случае, если имя источника состоит из нескольких слов. Например, `google_analytics__campaigns` всегда понятно, в то время как для незнакомого человека `google_analytics_campaigns` может быть `analytics_campaigns` из системы источника `google` так же легко, как и `campaigns` из системы источника `google_analytics`. Подумайте об этом как о [оксфордской запятой](https://www.youtube.com/watch?v=P_i1xk07o4g), дополнительная ясность стоит дополнительной пунктуации.
  - ❌ `stg_[entity].sql` - может быть достаточно специфичным в начале, но со временем это станет проблемой. Добавление системы источника в имя файла помогает в обнаружении и позволяет понять, откуда пришла компонентная модель, даже если вы не смотрите на дерево файлов.
  - ✅ **Множественное число.** SQL, и особенно SQL в dbt, должен читаться как можно более прозрачно. Мы хотим использовать широкую ясность и декларативную природу SQL, когда это возможно. Таким образом, если в вашей таблице `orders` есть только один заказ, множественное число — это правильный способ описать то, что находится в таблице с несколькими строками.

### Стадия: Модели

Теперь, когда мы поняли, как файлы и папки сочетаются, давайте заглянем внутрь одного из этих файлов и разберемся, что делает стадию модели хорошо структурированной.

Ниже приведен пример стандартной модели стадии (из нашей модели `stg_stripe__payments`), которая иллюстрирует общие шаблоны в стадии. Мы организовали нашу модель в два <Term id='cte'>CTE</Term>: один извлекает таблицу источника через [source macro](https://docs.getdbt.com/docs/build/sources#selecting-from-a-source), а другой применяет наши преобразования.

Хотя наши последующие слои преобразования будут сильно различаться от модели к модели, каждая из наших моделей стадии будет следовать этому же шаблону. Поэтому нам нужно убедиться, что установленный нами шаблон надежен и последователен.

- На основе вышеизложенного, наиболее стандартные типы преобразований моделей стадии:
  - ✅ **Переименование**
  - ✅ **Приведение типов**
  - ✅ **Базовые вычисления** (например, центы в доллары)
  - ✅ **Категоризация** (использование условной логики для группировки значений в категории или булевы значения, как в приведенных выше операторах `case when`)
  - ❌ **Объединения** — цель моделей стадии состоит в том, чтобы очистить и подготовить отдельные концепции, соответствующие источнику, для дальнейшего использования. Мы создаем наиболее полезную версию таблицы системы источника, которую можем использовать как новый модульный компонент для нашего проекта. По нашему опыту, объединения почти всегда являются плохой идеей здесь — они создают немедленное дублирование вычислений и запутанные отношения, которые распространяются вниз по потоку — хотя иногда бывают исключения (обратитесь к [базовым моделям](#staging-other-considerations) для получения дополнительной информации).
  - ❌ **Агрегации** — агрегации предполагают группировку, и мы не делаем этого на этом этапе. Помните — модели стадии — это ваше место для создания строительных блоков, которые вы будете использовать на протяжении всего остального проекта — если мы начнем изменять зерно наших таблиц, группируя на этом уровне, мы потеряем доступ к исходным данным, которые, вероятно, нам понадобятся в какой-то момент. Мы просто хотим очистить и подготовить наши отдельные концепции для использования, а агрегацию значений будем обрабатывать позже.
- ✅ **Материализованы как представления.** Посмотрев на частичное представление нашего `dbt_project.yml` ниже, мы можем увидеть, что мы настроили всю директорию стадии для материализации как <Term id='view'>представления</Term>. Поскольку они не предназначены быть окончательными артефактами, а скорее строительными блоками для последующих моделей, модели стадии обычно должны быть материализованы как представления по двум ключевым причинам:

  - Любая модель, использующая наши модели стадии (более подробно обсуждается в [marts](/best-practices/how-we-structure/4-marts)), всегда будет получать самые свежие данные из всех компонентных представлений, которые она собирает и материализует.
  - Это позволяет избежать ненужного расхода места в хранилище на моделях, которые не предназначены для запроса потребителями данных и, следовательно, не нуждаются в быстрой или эффективной работе.

    ```yaml
    # dbt_project.yml

    models:
      jaffle_shop:
        staging:
          +materialized: view
    ```

- Модели стадии — это единственное место, где мы будем использовать [`source` macro](/docs/build/sources), и наши модели стадии должны иметь отношение 1:1 к нашим таблицам источников. Это означает, что для каждой таблицы системы источника у нас будет одна модель стадии, ссылающаяся на нее, действующая как ее точка входа — _стадия_ ее — для использования ниже по потоку.

:::tip Не повторяйте себя.
Модели стадии помогают нам поддерживать наш код <Term id='dry'>DRY</Term>. Модульная, повторно используемая структура dbt означает, что мы можем и должны переносить любые преобразования, которые мы всегда хотим использовать для данной компонентной модели, как можно выше по потоку. Это избавляет нас от потенциальной траты кода, сложности и вычислений, выполняя одно и то же преобразование более одного раза. Например, если мы знаем, что всегда хотим наши денежные значения в виде чисел с плавающей запятой в долларах, но система источника предоставляет их в виде целых чисел и центов, мы хотим выполнить деление и приведение типов как можно раньше, чтобы мы могли ссылаться на это, а не повторять это снова и снова ниже по потоку.
:::

Это приятное изменение для многих из нас, кто привык применять одни и те же наборы SQL-преобразований в разных местах из-за необходимости! Для нас самой ранней точкой для этих 'всегда нужных' преобразований является стадия, начальная точка в нашем процессе преобразования. Принцип DRY в конечном итоге является тестом на то, должны ли преобразования происходить на стадии. Если они нам понадобятся в каждой модели ниже по потоку и помогают нам избежать повторного кода, они, вероятно, приемлемы.

### Стадия: Другие соображения

- **Базовые модели, когда объединения необходимы для стадии концепций.** Иногда, чтобы поддерживать чистую и <Term id='dry'>DRY</Term> стадию, нам действительно нужно реализовать некоторые объединения, чтобы создать надежную концепцию для наших строительных блоков. В этих случаях мы рекомендуем создать подкаталог в директории стадии для соответствующей системы источника и построить `base` модели. Они будут иметь все те же свойства, которые обычно находятся в стадии, они будут напрямую извлекать сырые данные и выполнять преобразования без объединений, а затем в моделях стадии мы будем объединять необходимые базовые модели. Наиболее распространенные случаи использования для создания базового слоя под папкой стадии:

  - ✅ **Объединение в отдельных таблицах для удаления.** Иногда система источника может хранить удаления в отдельной таблице. Обычно мы хотим убедиться, что можем пометить или отфильтровать удаленные записи для всех наших компонентных моделей, поэтому нам нужно будет объединить эти записи удаления с любыми из наших сущностей, которые следуют этой схеме. Это пример, показанный ниже для иллюстрации.

    ```sql
    -- base_jaffle_shop__customers.sql

    with

    source as (

        select * from {{ source('jaffle_shop','customers') }}

    ),

    customers as (

        select
            id as customer_id,
            first_name,
            last_name

        from source

    )

    select * from customers
    ```

    ```sql
    -- base_jaffle_shop__deleted_customers.sql

    with

    source as (

        select * from {{ source('jaffle_shop','customer_deletes') }}

    ),

    deleted_customers as (

        select
            id as customer_id,
            deleted as deleted_at

        from source

    )

    select * from deleted_customers
    ```

    ```sql
    -- stg_jaffle_shop__customers.sql

    with

    customers as (

        select * from {{ ref('base_jaffle_shop__customers') }}

    ),

    deleted_customers as (

        select * from {{ ref('base_jaffle_shop__deleted_customers') }}

    ),

    join_and_mark_deleted_customers as (

        select
            customers.*,
            case
                when deleted_customers.deleted_at is not null then true
                else false
            end as is_deleted

        from customers

        left join deleted_customers on customers.customer_id = deleted_customers.customer_id

    )

    select * from join_and_mark_deleted_customers
    ```

  - ✅ **Объединение разрозненных, но симметричных источников.** Типичный пример здесь — если вы работаете с несколькими платформами электронной коммерции в различных регионах через SaaS-платформу, такую как Shopify. У вас будут совершенно идентичные схемы, но все загружены отдельно в ваше хранилище. В этом случае легче рассуждать о наших заказах, если _все_ наши магазины объединены, поэтому мы хотели бы обработать объединение в базовой модели, прежде чем продолжить с нашими обычными преобразованиями модели стадии на (теперь полной) выборке — вы можете углубиться в [более подробную информацию об этом случае использования здесь](https://discourse.getdbt.com/t/unioning-identically-structured-data-sources/921).

- **[Codegen](https://github.com/dbt-labs/dbt-codegen) для автоматизации генерации таблиц стадии.** Очень хорошая практика — научиться писать модели стадии вручную, они просты и многочисленны, поэтому могут быть отличным способом впитать стиль написания SQL в dbt. Кроме того, мы неизбежно столкнемся с необходимостью добавлять специальные элементы в конкретные модели время от времени — например, в одной из ситуаций выше, требующих базовых моделей — поэтому полезно глубоко понимать, как они работают. Однако, как только это понимание установлено, поскольку модели стадии в значительной степени строятся по одним и тем же шаблонам и должны строиться 1:1 для каждой таблицы источника в системе источника, предпочтительнее начать автоматизировать их создание. Для этого у нас есть пакет [codegen](https://github.com/dbt-labs/dbt-codegen). Это позволит вам автоматически генерировать весь исходный YAML и шаблон модели стадии, чтобы ускорить этот шаг, и мы рекомендуем использовать его в каждом проекте.
- **Папка утилит.** Хотя это не находится в папке `staging`, полезно рассматривать это как часть наших основных строительных блоков. Директория `models/utilities` — это место, где мы можем хранить любые модели общего назначения, которые мы генерируем из макросов или на основе семян, которые предоставляют инструменты, помогающие нам в моделировании, а не данные для самого моделирования. Наиболее распространенный случай использования — это [date spine](https://github.com/dbt-labs/dbt-utils#date_spine-source), сгенерированный с помощью [пакета dbt utils](https://hub.getdbt.com/dbt-labs/dbt_utils/latest/).

:::info Поток разработки против порядка DAG.
Это руководство следует порядку DAG, чтобы мы могли получить целостное представление о том, как эти три основных слоя строятся друг на друге для создания значимых продуктов данных. Важно отметить, что разработка моделей обычно не движется линейно через DAG. Чаще всего мы должны начать с создания макета дизайна в электронной таблице, чтобы убедиться, что мы согласованы с нашими заинтересованными сторонами по целям вывода. Затем мы захотим написать SQL для генерации этого вывода и определить, какие таблицы участвуют. Как только у нас есть наша логика и зависимости, мы убедимся, что мы подготовили все необходимые атомные элементы в проекте, а затем объединим их на основе логики, которую мы написали для генерации нашего марта. Наконец, с работающей моделью в dbt мы можем начать рефакторинг и оптимизацию этого марта. Разделяя логику и перемещая части обратно вверх по потоку в промежуточные модели, мы обеспечиваем чистоту и читаемость всех наших моделей, ясность истории нашего DAG и больше возможностей для тщательного тестирования.
:::