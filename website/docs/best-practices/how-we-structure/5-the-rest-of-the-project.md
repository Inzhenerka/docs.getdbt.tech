---
title: "Остальная часть проекта"
id: "5-the-rest-of-the-project"
description: Остальная часть проекта.
displayText: Остальная часть проекта.
hoverSnippet: Остальная часть проекта.
---

### Обзор структуры проекта

До сих пор мы сосредоточились на папке `models`, основной директории нашего проекта dbt. Далее мы расширим наш взгляд и рассмотрим, как остальные файлы и папки нашего проекта вписываются в эту структуру, начиная с того, как мы подходим к YAML конфигурационным файлам.

```shell
models
├── intermediate
│   └── finance
│       ├── _int_finance__models.yml
│       └── int_payments_pivoted_to_orders.sql
├── marts
│   ├── finance
│   │   ├── _finance__models.yml
│   │   ├── orders.sql
│   │   └── payments.sql
│   └── marketing
│       ├── _marketing__models.yml
│       └── customers.sql
├── staging
│   ├── jaffle_shop
│   │   ├── _jaffle_shop__docs.md
│   │   ├── _jaffle_shop__models.yml
│   │   ├── _jaffle_shop__sources.yml
│   │   ├── base
│   │   │   ├── base_jaffle_shop__customers.sql
│   │   │   └── base_jaffle_shop__deleted_customers.sql
│   │   ├── stg_jaffle_shop__customers.sql
│   │   └── stg_jaffle_shop__orders.sql
│   └── stripe
│       ├── _stripe__models.yml
│       ├── _stripe__sources.yml
│       └── stg_stripe__payments.sql
└── utilities
    └── all_dates.sql
```

### Углубление в YAML

При структурировании ваших YAML конфигурационных файлов в проекте dbt важно найти баланс между централизацией и размером файла, чтобы сделать конкретные конфигурации как можно более доступными. Важно отметить, что хотя файлы верхнего уровня YAML (`dbt_project.yml`, `packages.yml`) должны иметь определенные названия и находиться в определенных местах, файлы, содержащие ваши словари `sources` и `models`, могут называться, располагаться и организовываться так, как вам удобно. Важны внутренние содержимое. Таким образом, мы изложим нашу основную рекомендацию, а также плюсы и минусы популярной альтернативы. Как и многие другие аспекты структурирования вашего проекта dbt, здесь наиболее важны последовательность, ясные намерения и тщательная документация о том, как и почему вы делаете то, что делаете.

- ✅ **Конфигурация по папкам.** Как в приведенном выше примере, создайте `_[directory]__models.yml` для каждой директории в вашей папке моделей, которая настраивает все модели в этой директории. Для папок staging также включите `_[directory]__sources.yml` для каждой директории.
  - Ведущий символ подчеркивания гарантирует, что ваши YAML файлы будут отсортированы в верхней части каждой папки, чтобы их было легко отделить от ваших моделей.
  - YAML файлы не требуют уникальных имен так, как это делают SQL файлы моделей, но включение директории (вместо простого `_sources.yml` в каждой папке) означает, что вы сможете быстрее найти нужный файл.
  - Мы рекомендовали несколько различных соглашений о наименовании на протяжении многих лет, и в последнее время мы называем эти файлы `schema.yml`. Мы упростили рекомендацию, чтобы они просто обозначались в зависимости от содержащегося в них словаря YAML.
  - Если вы используете [doc blocks](https://docs.getdbt.com/docs/build/documentation#using-docs-blocks) в вашем проекте, мы рекомендуем следовать той же схеме и создавать `_[directory]__docs.md` markdown файл для каждой директории, содержащий все ваши doc blocks для этой папки моделей.
- ❌ **Конфигурация по проекту.** Некоторые люди помещают _все_ свои YAML для источников и моделей в один файл. Хотя вы технически можете это сделать, и это, безусловно, упрощает понимание, в каком файле будет нужная вам конфигурация (так как есть только один файл), это значительно усложняет поиск конкретных конфигураций в этом файле. Мы рекомендуем сбалансировать эти два аспекта.
- ⚠️ **Конфигурация по модели.** С другой стороны, некоторые люди предпочитают создавать один YAML файл для каждой модели. Это создает меньше проблем, чем один монолитный файл, так как вы можете быстро искать файлы, точно знать, где находятся конкретные конфигурации, обнаруживать модели без конфигураций (и, следовательно, без тестов), глядя на дерево файлов, и получать различные другие преимущества. На наш взгляд, дополнительные файлы, вкладки и окна, которые необходимо создать, скопировать, вставить, закрыть, открыть и управлять ими, создают несколько более медленный процесс разработки, который перевешивает преимущества. Определение конфигурации по директории является наиболее сбалансированным подходом для большинства проектов, но если у вас есть убедительные причины использовать конфигурацию по модели, определенно есть отличные проекты, которые следуют этой парадигме.
- ✅ **Каскадные конфигурации.** Используйте ваш `dbt_project.yml`, чтобы установить конфигурации по умолчанию на уровне директории. Используйте хорошо организованную структуру папок, которую мы создали до сих пор, чтобы определить базовые схемы и материализации, и используйте каскадный приоритет области действия dbt, чтобы определить вариации. Например, как показано ниже, определите ваши marts как таблицы по умолчанию, определите отдельные схемы для наших отдельных подпапок, и любые модели, которые должны использовать инкрементальную материализацию, могут быть определены на уровне модели.

```yaml
-- dbt_project.yml

models:
  jaffle_shop:
    staging:
      +materialized: view
    intermediate:
      +materialized: ephemeral
    marts:
      +materialized: table
      finance:
        +schema: finance
      marketing:
        +schema: marketing
```

:::tip Определите ваши значения по умолчанию.
Одним из многих преимуществ этого последовательного подхода к структуре проекта является возможность каскадирования поведения по умолчанию. Тщательная организация наших папок и определение конфигурации на этом уровне, когда это возможно, освобождает нас от необходимости настраивать такие вещи, как схема и материализация в каждой модели (что не очень DRY!) — нам нужно настраивать только исключения из наших общих правил. Тегирование — это еще одна область, где этот принцип проявляется. Многие новички в dbt полагаются на теги, а не на строгую структуру папок, и быстро оказываются в ситуации, когда каждая модель _требует_ тег. Это создает ненужную сложность. Мы хотим полагаться на наши папки как на основные селекторы и механизм группировки, и использовать теги для определения групп, которые являются _исключениями._ Выбор на основе папок, такой как \*\*`dbt build --select marts.marketing`, гораздо проще, чем пытаться тегировать каждую модель, связанную с маркетингом, надеясь, что все разработчики помнят добавить этот тег для новых моделей, и использовать `dbt build --select tag:marketing`.
:::

### Как мы используем другие папки

```shell
jaffle_shop
├── analyses
├── seeds
│   └── employees.csv
├── macros
│   ├── _macros.yml
│   └── cents_to_dollars.sql
├── snapshots
└── tests
└── assert_positive_value_for_total_amount.sql
```

Мы до сих пор сосредоточились на основной области действия в нашем проекте dbt, папке `models`. Однако, как вы, вероятно, заметили, в нашем проекте есть несколько других папок. Хотя они, по замыслу, очень гибкие в зависимости от ваших потребностей, мы обсудим наиболее распространенные случаи использования этих других папок, чтобы помочь вам начать.

- ✅ `seeds` для таблиц справочников. Наиболее распространенный случай использования seeds — это загрузка таблиц справочников, которые полезны для моделирования, но не существуют в каких-либо системах источников — подумайте о сопоставлении почтовых индексов с штатами или UTM параметров с маркетинговыми кампаниями. В этом примере проекта у нас есть небольшой seed, который сопоставляет наших сотрудников с их `customer_id`, чтобы мы могли обрабатывать их покупки с помощью специальной логики.
- ❌ `seeds` для загрузки исходных данных. Не используйте seeds для загрузки данных из системы источника в ваш хранилище. Если данные существуют в системе, к которой у вас есть доступ, вы должны загружать их с помощью подходящего инструмента EL в область сырых данных вашего хранилища. dbt предназначен для работы с данными в хранилище, а не как инструмент загрузки данных.
- ✅ `analyses` для хранения аудиторских запросов. Папка `analyses` позволяет вам хранить любые запросы, которые вы хотите использовать с Jinja и контролировать версии, но не строить в модели в вашем хранилище. Здесь есть бесконечные возможности, но наиболее распространенный случай использования, когда мы настраиваем проекты в dbt Labs, — это хранение запросов, которые используют пакет [audit helper](https://github.com/dbt-labs/dbt-audit-helper). Этот пакет невероятно полезен для поиска несоответствий в выводе при миграции логики из другой системы в dbt.
- ✅ `tests` для тестирования нескольких конкретных таблиц одновременно. Поскольку тесты dbt развивались, написание единичных тестов стало менее необходимым. Это крайне полезно для отработки логики тестирования, но чаще всего вы обнаружите, что либо переносите эту логику в свои собственные настраиваемые общие тесты, либо находите заранее созданный тест, который соответствует вашим потребностям из постоянно расширяющейся вселенной пакетов dbt (между дополнительными тестами в [`dbt-utils`](https://github.com/dbt-labs/dbt-utils) и [`dbt-expectations`](https://github.com/calogica/dbt-expectations) почти любая ситуация покрыта). Однако одна область, где единичные тесты все еще блестят, — это гибкое тестирование вещей, которые требуют различных конкретных моделей. Если вы знакомы с разницей между [модульными тестами](https://en.wikipedia.org/wiki/Unit_testing) [и](https://www.testim.io/blog/unit-test-vs-integration-test/) [интеграционными](https://www.codecademy.com/resources/blog/what-is-integration-testing/) [тестами](https://en.wikipedia.org/wiki/Integration_testing) в программной инженерии, вы можете думать о общих и единичных тестах аналогичным образом. Если вам нужно протестировать результаты того, как несколько конкретных моделей взаимодействуют или соотносятся друг с другом, единичный тест, вероятно, будет самым быстрым способом закрепить вашу логику.
- ✅ `snapshots` для создания записей [Type 2 медленно изменяющейся размерности](https://en.wikipedia.org/wiki/Slowly_changing_dimension#Type_2:_add_new_row) из [Type 1](https://en.wikipedia.org/wiki/Slowly_changing_dimension#Type_1:_overwrite) (разрушающе обновленных) исходных данных. Это [подробно описано в документации dbt](/docs/build/snapshots), в отличие от этих других папок, имеет более четко определенную цель и выходит за рамки этого руководства, но упоминается для полноты.
- ✅ `macros` для упрощения трансформаций, которые вы выполняете повторно. Как и в случае со снимками, полное погружение в макросы выходит за рамки этого руководства и хорошо [освещено в другом месте](/docs/build/jinja-macros), но одна важная рекомендация, связанная со структурой, заключается в том, чтобы [написать документацию для ваших макросов](https://docs.getdbt.com/faqs/docs/documenting-macros). Мы рекомендуем создать `_macros.yml` и задокументировать цель и аргументы для ваших макросов, как только они будут готовы к использованию.

### Разделение проекта

Одним из важных, растущих соображений в экосистеме аналитической инженерии является то, как и когда разделить кодовую базу на несколько проектов dbt. В настоящее время наш совет для большинства команд, особенно тех, кто только начинает, довольно прост: в большинстве случаев мы рекомендуем делать это с помощью [dbt Mesh](/best-practices/how-we-mesh/mesh-1-intro)! dbt Mesh позволяет организациям справляться со сложностью, соединяя несколько проектов dbt, а не полагаясь на один большой монолитный проект. Этот подход предназначен для ускорения разработки при сохранении управления.

Поскольку разделение монолитных проектов dbt на более мелкие, связанные проекты, потенциально в рамках современного моно репозитория становится проще, сценарии, против которых мы в настоящее время советуем, могут вскоре стать осуществимыми. Так что следите за обновлениями!

- ✅ **Бизнес-группы или отделы.** Концептуальные разделения внутри проекта являются основной причиной для его разделения. Это позволяет вашим бизнес-доменам владеть своими собственными продуктами данных и при этом сотрудничать, используя dbt Mesh. Для получения дополнительной информации о dbt Mesh, пожалуйста, обратитесь к нашим [dbt Mesh FAQs](/best-practices/how-we-mesh/mesh-5-faqs).
- ✅ **Управление данными.** Структурные, организационные потребности — такие как управление данными и безопасность — являются одной из немногих стоящих причин для разделения проекта. Если, например, вы работаете в компании здравоохранения с небольшой командой, имеющей доступ к сырым данным с PII, вам может потребоваться выделить ваши модели staging в отдельные проекты, чтобы сохранить эти политики. В этом случае вы импортируете ваш проект staging в проект, который строится на этих моделях staging, как [приватный пакет](https://docs.getdbt.com/docs/build/packages/#private-packages).
- ✅ **Размер проекта.** В какой-то момент ваш проект может вырасти до такого количества моделей, что это создаст нецелесообразный опыт разработки. Если у вас есть тысячи моделей, абсолютно имеет смысл найти способ разделить ваш проект.
- ❌ **Случаи использования ML против отчетности.** Аналогично предыдущему пункту, разделение проекта на основе различных случаев использования, особенно более стандартных BI против ML функций, является распространенной идеей. Мы склонны отговаривать от этого на данный момент. Как и в предыдущем пункте, основной целью внедрения dbt является создание единого источника правды в вашей организации. Функции, которые вы предоставляете своим командам по данным, должны исходить из тех же marts и метрик, которые обслуживают отчеты на исполнительных панелях.

## Заключительные соображения

В целом, последовательность важнее любых из этих конкретных соглашений. По мере роста вашего проекта и углубления вашего опыта с dbt вы, безусловно, найдете аспекты вышеуказанной структуры, которые хотите изменить. Хотя мы рекомендуем этот подход для большинства проектов, каждая организация уникальна! Единственный догматический совет, который мы можем дать здесь, заключается в том, что когда вы находите аспекты вышеуказанной структуры, которые хотите изменить, тщательно подумайте о своих причинах и задокументируйте для вашей команды _как_ и _почему_ вы отклоняетесь от этих соглашений. В этой связи мы настоятельно рекомендуем вам сделать форк этого руководства и добавить его в README, вики или документацию вашего проекта, чтобы вы могли быстро создать и настроить эти артефакты.

Наконец, мы подчеркиваем, что это руководство является живым документом! Оно, безусловно, будет изменяться и развиваться по мере эволюции dbt и dbt Labs. Мы приглашаем вас присоединиться — обсуждать, комментировать и вносить предложения по изменениям или новым элементам для освещения.