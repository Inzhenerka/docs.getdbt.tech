---
title: Решение о структуре вашего dbt Mesh
description: Начало работы с шаблонами dbt Mesh
hoverSnippet: Узнайте, как начать работу с dbt Mesh
---
## Изучение шаблонов mesh

При принятии архитектуры с несколькими проектами, где провести границы между проектами?

Как организовать рабочие процессы с данными в мире, где вместо одной DAG dbt у вас есть несколько проектов, взаимодействующих друг с другом, каждый из которых состоит из своей DAG?

Принятие шаблона dbt Mesh — это не универсальный процесс. На самом деле, это противоположное! Это о том, как настроить структуру вашего проекта, чтобы она соответствовала _вашей_ команде и _вашим_ данным. Теперь вы можете адаптировать свою организационную графовую модель знаний к графовой модели людей вашей организации, сближая людей и данные, а не жертвуя одним ради другого.

Хотя нет единственно правильного способа реализации этого шаблона, есть несколько общих точек принятия решений, которые будут полезны для вас.

На высоком уровне вам нужно будет решить:

- Где провести границы между вашими проектами dbt — т.е. как определить, где разделить вашу DAG и какие модели должны находиться в каком проекте?
- Как управлять вашим кодом — хотите ли вы, чтобы несколько проектов dbt находились в одном репозитории (моно-репозиторий) или хотите иметь несколько репозиториев, по одному на проект?

## Определите интерфейсы вашего проекта, разделив вашу DAG

Первое (и, возможно, самое сложное!) решение при переходе к архитектуре с несколькими проектами — это решение о том, где провести границу в вашей DAG, чтобы определить интерфейсы между вашими проектами. Давайте рассмотрим некоторые термины для обсуждения дизайна этих шаблонов.

### Вертикальные разделения

Вертикальные разделения отделяют слои трансформации в порядке DAG. Рассмотрим несколько примеров.

- **Разделение слоев staging и mart** для создания более строго контролируемого, общего набора компонентов, на основе которых строятся другие проекты, но которые нельзя редактировать.
- **Изоляция более ранних моделей для требований безопасности и управления** для отделения и маскировки PII данных, чтобы downstream-пользователи не могли к ним получить доступ — это распространенный случай использования вертикального разделения.
- **Защита сложных или дорогостоящих данных** для изоляции больших или сложных моделей, которые дорого запускать, чтобы они были защищены от случайного выбора, могли быть развернуты независимо и легче отлаживались в случае возникновения проблем.

<Lightbox src="/img/best-practices/how-we-mesh/vertical_split.png" title="Упрощенная DAG dbt с пунктирной линией, представляющей вертикальное разделение." />

### Горизонтальные разделения

Горизонтальные разделения разделяют вашу DAG на основе источника или домена. Эти разделения часто основаны на форме и размере данных и том, как они используются. Рассмотрим некоторые возможности для горизонтального разделения.

- **Шаблоны потребления команд.** Например, выделение потока данных маркетинговой команды в отдельный проект.
- **Данные из разных источников.** Например, данные о событиях кликов и транзакционные данные электронной коммерции могут потребовать независимого моделирования.
- **Рабочие процессы команд.** Например, если две встроенные группы работают с разной скоростью, вы можете захотеть разделить проекты, чтобы они могли двигаться независимо.

<Lightbox src="/img/best-practices/how-we-mesh/horizontal_split.png" title="Упрощенная DAG dbt с пунктирной линией, представляющей горизонтальное разделение." />

### Сочетание этих стратегий

- **Это не методы «или/или».** Вам следует рассмотреть оба типа разделений и комбинировать их любым способом, который имеет смысл для вашей организации.
- **Выберите один тип разделения и сосредоточьтесь на нем в первую очередь.** Если у вас, например, топология команды «центр-спица», сначала разберитесь с выделением центрального платформенного проекта, прежде чем разделять остальные на домены. Затем, если вам нужно разбить эти домены горизонтально, вы можете сосредоточиться на этом позже.
- **DRY применимо к исходным данным, а не только к коду.** Независимо от вашей стратегии, вы не должны использовать одни и те же строки и столбцы в нескольких узлах. При работе в шаблоне mesh становится все более важным, чтобы мы не дублировали логику или данные.

<Lightbox src="/img/best-practices/how-we-mesh/combined_splits.png" title="Упрощенная DAG dbt с двумя пунктирными линиями, представляющими как вертикальное, так и горизонтальное разделение." />

## Определите свою стратегию git

Архитектура с несколькими проектами может существовать в одном репозитории (моно-репозиторий) или как несколько проектов, каждый из которых находится в своем собственном репозитории (мульти-репозиторий).

- Если вы **меньшая команда**, стремящаяся в первую очередь ускорить и упростить разработку, **моно-репозиторий** вероятно будет правильным выбором, но может стать неудобным по мере роста числа проектов, моделей и участников.
- Если вы **большая команда с несколькими группами** и вам нужно разъединить проекты для обеспечения безопасности и возможности различных стилей и ритмов разработки, **мульти-репозиторий** — ваш лучший выбор.

## Проекты, разделения и команды

С момента запуска dbt Mesh наиболее распространенным шаблоном, который мы наблюдали, является тот, где проекты 1:1 соответствуют командам, и каждый проект имеет свою собственную кодовую базу в своем собственном репозитории. Это не жесткое правило: некоторые организации хотят, чтобы несколько команд работали из одного репозитория, а некоторые команды владеют несколькими доменами, которые неудобно держать вместе.

Пользователи могут потребоваться вносить модели в нескольких проектах, и это нормально. Это может вызвать некоторые трения по сравнению с одним репозиторием, но это _полезное_ трение, особенно если нужно передать изменение от «спицы» к «центру». Это следует рассматривать как внесение изменения в API, с которым другая команда будет работать в течение некоторого времени. Вам следует беспокоиться, если ваши коллеги обнаружат, что им часто (каждую неделю) нужно вносить согласованные изменения в нескольких проектах или это является ключевым предварительным условием для ~20%+ их работы.

### Обнаружение циклов

import CycleDetection from '/snippets/_mesh-cycle-detection.md';

<CycleDetection />

### Советы и рекомендации

Страница [реализации](/best-practices/how-we-mesh/mesh-4-implementation) предоставляет более подробные примеры того, как разделить монолитный проект на несколько проектов. Вот несколько советов, чтобы помочь вам начать, когда вы рассматриваете методы разделения, перечисленные выше, для ваших собственных проектов:

1. Начните с рисования диаграммы ваших команд, работающих с данными. Соотнесите каждую команду с одним проектом dbt. Если у вас уже есть существующий монолитный проект и вы вводите _новые команды_, это может быть так же просто, как объявить существующий проект вашим «центром» и создать новые «спицы» песочницы для каждой команды.
2. Разделите общие основы, когда вы знаете, что нескольким downstream-командам потребуется один и тот же источник данных. Эти данные могут быть переданы в централизованный хаб или выделены в отдельный базовый проект. Вам могут понадобиться некоторые разделения для облегчения других разделений, например, модели исходного staging в A, которые используются как в B, так и в C (отсутствие циклов проектов).
3. Разделите снова, чтобы ввести преднамеренное трение и инкапсулировать определенный набор моделей (например, для внешнего экспорта).
4. Объедините снова, если у вас есть подмножества «горячего пути» DAG, которые необходимо развернуть с низкой задержкой, потому что они поддерживают отчетность в приложении или операционную аналитику. Может иметь смысл, чтобы другая специализированная команда владела этими моделями данных (см. принцип 1), аналогично тому, как программные сервисы с существенно различающимися характеристиками производительности часто требуют специализированной инфраструктуры, архитектуры и кадров.