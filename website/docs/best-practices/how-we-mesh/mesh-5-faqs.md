---
title: "Часто задаваемые вопросы о dbt Mesh"
description: "Прочитайте часто задаваемые вопросы, чтобы узнать больше о dbt Mesh, как он работает, совместимости и многом другом."
hoverSnippet: "Часто задаваемые вопросы о dbt Mesh"
sidebar_label: "Часто задаваемые вопросы о dbt Mesh"
---

<Constant name="mesh" /> — это новая архитектура, включаемая с помощью <Constant name="cloud" />. Она позволяет эффективнее управлять сложностью за счёт развертывания нескольких взаимосвязанных проектов dbt вместо одного большого монолитного проекта. Архитектура спроектирована так, чтобы ускорять разработку без ущерба для управления и контроля (governance).

## Обзор Mesh

<DetailsToggle alt_header="Каковы основные преимущества внедрения dbt Mesh?">
  
Вот некоторые преимущества внедрения dbt Mesh:

* **Быстрее выпускать продукты данных**: Благодаря более модульной архитектуре команды могут быстро и независимо вносить изменения в конкретные области без воздействия на всю систему, что приводит к более быстрым циклам разработки.
* **Улучшение доверия к данным**: Применение dbt Mesh помогает гарантировать, что изменения в моделях данных одного домена не нарушат неожиданно зависимости в других областях домена, что приводит к более безопасной и предсказуемой среде данных.
* **Снижение сложности**: Организуя логику трансформации в отдельные домены, dbt Mesh снижает сложность, присущую большим монолитным проектам, делая их более управляемыми и понятными.
* **Улучшение сотрудничества**: Команды могут делиться и развивать работу друг друга без дублирования усилий.

Самое главное, все это можно достичь без потери центральной командой данных возможности видеть родословную по всей организации или компрометации механизмов управления.

</DetailsToggle>

<DetailsToggle alt_header="Что такое контракты моделей?">

dbt [model contracts](/docs/mesh/govern/model-contracts) служат инструментом управления, который позволяет определять и обеспечивать соблюдение стандартов структуры данных в ваших моделях dbt. Они дают возможность задавать и поддерживать гарантии для моделей данных, включая типы данных колонок, что обеспечивает стабильность зависимых моделей. Если модель не соответствует установленным для неё контрактам, она не будет успешно собрана.

</DetailsToggle>

<DetailsToggle alt_header="Что такое версии моделей?">

dbt [model versions](/docs/mesh/govern/model-versions) — это итерации ваших dbt-моделей, создаваемые с течением времени. Во многих случаях вы можете осознанно решить изменить структуру модели таким образом, что это «сломает» предыдущий контракт модели и может нарушить работу downstream‑запросов, зависящих от структуры этой модели. В таких ситуациях создание новой версии модели полезно для явного обозначения этого изменения.

Вы можете использовать версии моделей для:

- Тестирования изменений "предрелизной" версии (в производстве, в последующих системах).
- Повышения последней версии, чтобы использовать ее в качестве канонического "источника истины".
- Предоставления окна миграции от "старой" версии.

</DetailsToggle>

<DetailsToggle alt_header="Что такое модификаторы доступа к моделям?">

[Model access modifier](/docs/mesh/govern/model-access) в dbt определяет, может ли модель быть доступна как входная (input) для других моделей и проектов dbt. Он указывает, где именно модель может быть использована с помощью [функции `ref`](/reference/dbt-jinja-functions/ref). Существует три типа access modifiers:

* **Частный:** Модель с частным модификатором доступа может быть упомянута только моделями в той же группе. Это предназначено для моделей, которые являются деталями реализации и предназначены для использования только в определенной группе связанных моделей.
* **Защищенный:** Модели с защищенным модификатором доступа могут быть упомянуты любой другой моделью в том же проекте dbt или когда проект установлен как пакет. Это настройка по умолчанию для всех моделей, обеспечивающая обратную совместимость, особенно когда группы назначаются существующему набору моделей.
* **Публичный:** Публичная модель может быть упомянута в разных группах, пакетах или проектах. Это подходит для стабильных и зрелых моделей, которые служат интерфейсами для других команд или проектов.

</DetailsToggle>

<DetailsToggle alt_header="Что такое группы моделей?">

[Model group](/docs/mesh/govern/model-access#groups) в dbt — это концепция, используемая для организации моделей в рамках общей категории или по признаку владения. Такая категоризация может основываться на различных критериях, например на команде, ответственной за модели, или на конкретном источнике данных, который эти модели описывают.

</DetailsToggle>

<DetailsToggle alt_header="Какие потенциальные проблемы могут возникнуть при использовании dbt Mesh?">

Это новый способ работы, и намеренность, необходимая для создания и поддержания интерфейсов и зависимостей между проектами, может показаться замедлением по сравнению с тем, к чему привыкли некоторые разработчики. Введенное намеренное трение способствует обдуманным изменениям, формируя мышление, которое ценит стабильность и систематические корректировки больше, чем быстрые трансформации.

Оркестрация между несколькими проектами также, вероятно, будет немного более сложной для многих организаций, хотя мы в настоящее время разрабатываем новую функциональность, которая упростит этот процесс.

</DetailsToggle>

<DetailsToggle alt_header="Как это связано с концепцией data mesh?">

dbt Mesh позволяет вам лучше _операционализировать_ data mesh, обеспечивая децентрализованное, доменно-специфическое владение данными и сотрудничество.

В data mesh каждый бизнес-домен отвечает за свои данные как за продукт. Это та же цель, которую dbt Mesh облегчает, позволяя организациям разбивать большие, монолитные проекты данных на более мелкие, доменно-специфические проекты dbt. Каждая команда или домен может независимо разрабатывать, поддерживать и делиться своими моделями данных, способствуя децентрализованной среде данных.

dbt Mesh также улучшает интероперабельность и повторное использование данных в разных доменах, что является ключевым аспектом философии data mesh. Позволяя перекрестные ссылки на проекты и совместное управление через контракты моделей и контроль доступа, dbt Mesh гарантирует, что, хотя владение данными децентрализовано, существует все же управляемая структура для общей архитектуры данных.

</DetailsToggle>

## Как работает dbt Mesh

<DetailsToggle alt_header="Может ли dbt Mesh обрабатывать циклические зависимости между проектами?">

import CycleDetection from '/snippets/_mesh-cycle-detection.md';

<CycleDetection />

</DetailsToggle>

<DetailsToggle alt_header="Возможно ли, чтобы несколько проектов напрямую ссылались на общий источник?">

Хотя в настоящее время невозможно делиться источниками между проектами, можно иметь общий базовый проект с моделями стадии поверх этих источников, которые выставлены как "публичные" модели для других команд/проектов.

</DetailsToggle>

<DetailsToggle alt_header="Что если модель, на которую я уже построил из другого проекта, позже становится защищенной?">

Это будет нарушением для потребителей этой модели. Если поддерживающие проект хотят удалить модель (или "понизить" ее модификатор доступа, что фактически одно и то же), они должны пометить эту модель для устаревания (используя [deprecation_date](/reference/resource-properties/deprecation_date)), что выдаст предупреждение всем потребителям этой модели.

В будущем мы планируем, что dbt Cloud также сможет проактивно отмечать этот сценарий в [непрерывной интеграции](/docs/deploy/continuous-integration) для поддерживающих публичную модель.

</DetailsToggle>

<DetailsToggle alt_header="Если я запущу `dbt build --select +model`, вызовет ли это запуск моделей в других проектах?">

Это будет **breaking change** для downstream‑потребителей этой модели. Если мейнтейнеры upstream‑проекта хотят удалить модель (или «понизить» её модификатор доступа, что по сути то же самое), им следует пометить эту модель как устаревающую, используя [deprecation_date](/reference/resource-properties/deprecation_date). В этом случае всем downstream‑потребителям этой модели будет выдано предупреждение.

В будущем мы планируем, что <Constant name="cloud" /> также сможет проактивно сигнализировать о такой ситуации в [continuous integration](/docs/deploy/continuous-integration) для мейнтейнеров upstream‑публичной модели.

</DetailsToggle>

<DetailsToggle alt_header="Если у каждого проекта/домена есть собственное хранилище данных, возможно ли все еще строить модели между ними?">

Нет, если только апстрим‑проекты не установлены как [packages](/docs/build/packages) (исходный код). В этом случае модели в проекте, установленном как пакет, становятся «вашими» моделями, и вы можете выбирать или запускать их. В некоторых ситуациях это может быть полезно; см. документацию по [project dependencies](/docs/mesh/govern/project-dependencies).

</DetailsToggle>

<DetailsToggle alt_header="Могу ли я запускать тесты, которые включают таблицы из нескольких разных проектов?">

Да, поскольку перекрестное сотрудничество между проектами осуществляется с использованием макроса `{{ ref() }}`, вы можете использовать эти модели от других команд в [единичных тестах](/docs/build/data-tests#singular-data-tests).

</DetailsToggle>

<DetailsToggle alt_header="Какую схему данных создаст dbt Mesh для команды?">

Каждая команда определяет свое подключение к хранилищу данных и имена схем по умолчанию, которые dbt будет использовать при материализации наборов данных.

По умолчанию каждый проект, принадлежащий команде, создаст:

- Одну схему для производственных запусков (например, `finance`).
- Одну схему на разработчика (например, `dev_jerco`).

В зависимости от потребностей каждой команды это можно настроить с помощью [конфигураций схем](/docs/build/custom-schemas) на уровне модели, включая возможность определения различных правил по средам.

</DetailsToggle>

<DetailsToggle alt_header="Можно ли применять контракты моделей к исходным данным?">

Нет, контракты могут быть применены только на [уровне модели](/docs/collaborate/govern/model-contracts). Рекомендуется [определять модели стадии](/best-practices/how-we-structure/2-staging) поверх источников, и возможно определять контракты поверх этих моделей стадии.

</DetailsToggle>

<DetailsToggle alt_header="Можно ли частично применять контракты?">

Нет, контракты можно применять только на [уровне модели](/docs/mesh/govern/model-contracts). Рекомендуемой лучшей практикой является [определение staging‑моделей](/best-practices/how-we-structure/2-staging) поверх источников, и на эти staging‑модели можно определять контракты.

</DetailsToggle>

<DetailsToggle alt_header="Могу ли я иметь нескольких владельцев в группе?">

Нет, [группа](/docs/collaborate/govern/model-access#groups) может быть назначена только одному владельцу. Однако назначенный владелец может быть _командой_, а не отдельным лицом.

</DetailsToggle>

<DetailsToggle alt_header="Можно ли назначить контракты индивидуальным владельцам?">

Нет, [group](/docs/mesh/govern/model-access#groups) может быть назначен только одному owner. Однако назначенным owner может быть _team_, а не отдельный человек.

</DetailsToggle>

<DetailsToggle alt_header="Могу ли я сделать модель “публичной” только для использования определенными командами?">

Непосредственно — нет, но контракты [назначаются моделям](/docs/mesh/govern/model-contracts), а модели могут быть назначены отдельным владельцам. Для этой цели можно использовать поля `meta`.

</DetailsToggle>

<DetailsToggle alt_header="Возможно ли оркестровать выполнение заданий между несколькими разными проектами?">

dbt Cloud вскоре предложит возможность запускать задания по завершении другого задания, включая задание в другом проекте. Это предлагает один из механизмов выполнения конвейера от начала до конца между проектами.

</DetailsToggle>

<DetailsToggle alt_header="Доступны ли интеграции между dbt Discovery API и другими инструментами для кросс-проектного lineage?" />

Да. Помимо нативного просмотра через [<Constant name="explorer" />](https://www.getdbt.com/product/dbt-explorer), также существует возможность просматривать межпроектную lineage с использованием партнёрских интеграций с инструментами каталогизации данных. Список доступных интеграций <Constant name="cloud" /> см. на странице [Integrations](https://www.getdbt.com/product/integrations).

</DetailsToggle>

<DetailsToggle alt_header="Как работает пересчёт данных (data restatement) в dbt Mesh, особенно при исправлении бага в датасете?">

Тесты и контракты моделей в dbt помогают изначально снизить необходимость пересчёта данных. С помощью этих инструментов вы можете встроить проверки на уровне источников и выходных данных в ваших dbt-проектах, чтобы оценивать качество данных в самых критичных местах. Когда меняется логика трансформаций (например, изменяется определение конкретной колонки), пересчёт данных сводится к простому мерджу обновлённого кода и запуску задания в <Constant name="cloud" />.

Если проблема с качеством данных всё же проскочила, у вас также есть возможность просто откатить git-коммит и заново запустить задание <Constant name="cloud" /> с предыдущей версией кода.

</DetailsToggle>

<DetailsToggle alt_header="Как dbt обрабатывает логи выполнения заданий и может ли он передавать их в стандартные инструменты мониторинга, отчеты и т.д.?">

Да, все эти метаданные доступны через [Admin API <Constant name="cloud" />](/docs/dbt-cloud-apis/admin-cloud-api). Эти данные можно передавать в инструменты мониторинга или использовать для построения отчётов и дашбордов.

Часть этой информации также отображается непосредственно в <Constant name="cloud" /> — в разделе [jobs](/docs/deploy/jobs), [environments](/docs/environments-in-dbt), а также в [<Constant name="explorer" />](https://www.getdbt.com/product/dbt-explorer).

</DetailsToggle>

<DetailsToggle alt_header="Может ли dbt Mesh ссылаться на модели в других аккаунтах в рамках одной платформы данных?">

Вы можете ссылаться на модели в других аккаунтах в рамках одной и той же платформы данных, используя возможности шаринга данных этой платформы, при условии что идентификатор базы данных публичной модели совпадает у продюсера и консюмера.

Например, это могут быть [кросс-аккаунтные data shares в Snowflake](https://docs.snowflake.com/en/user-guide/data-sharing-intro), [Databricks Unity Catalog между разными workspace](https://docs.databricks.com/en/data-governance/unity-catalog/index.html) или несколько проектов BigQuery.

</DetailsToggle>

## Разрешения и доступ

<DetailsToggle alt_header="Как работают разрешения на доступ пользователей в dbt Mesh? ">

Существование проектов, в которых есть хотя бы одна публичная модель, будет видно всем в организации с [доступом только для чтения](/docs/cloud/manage-access/seats-and-users).

Частные или защищенные модели требуют, чтобы пользователь имел доступ только для чтения к конкретному проекту, чтобы увидеть его существование.

</DetailsToggle>

<DetailsToggle alt_header="Как взаимодействуют между собой разные типы «доступа»?">

Существует доступ на уровне моделей в dbt, ролевой доступ для пользователей и групп в <Constant name="cloud" />, а также доступ к базовым данным на стороне платформы данных.

Прежде всего: доступ к базовым данным всегда определяется и обеспечивается самой платформой данных (например, BigQuery, Databricks, Redshift, Snowflake, Starburst и т.д.). Такой доступ управляется через выполнение DCL-команд (в первую очередь `grant`). dbt упрощает этот процесс, позволяя [настраивать `grants` для моделей](/reference/resource-configs/grants), чтобы выдавать доступ к данным другим ролям, пользователям или группам в хранилище данных. При этом dbt _не_ определяет и не синхронизирует такие права автоматически, если они не настроены явно. Ориентируйтесь на внутренние процессы вашей организации для управления правами доступа в хранилище данных.

[Тарифы <Constant name="cloud" /> Enterprise и Enterprise+](https://www.getdbt.com/pricing) поддерживают [ролевую модель доступа (RBAC)](/docs/cloud/manage-access/about-user-access#role-based-access-control-), которая позволяет управлять детальными правами пользователей и групп. Вы можете контролировать, какие пользователи могут просматривать или редактировать различные части проекта в <Constant name="cloud" />. Уровень доступа пользователя к проектам в <Constant name="cloud" /> также определяет, может ли он детально «исследовать» (explore) этот проект. Роли, пользователи и группы настраиваются внутри приложения <Constant name="cloud" /> через интерфейс или через интеграцию с провайдером идентификации.

[Доступ к моделям](/docs/mesh/govern/model-access) определяет, где именно модели могут быть использованы через `ref`. Он также влияет на их обнаруживаемость в <Constant name="explorer" />. Параметр `access` для модели задаётся в коде — так же, как и любые другие настройки модели (`materialized`, `tags` и т.д.).

* **Public:** Модели с уровнем доступа `public` могут использоваться везде. Это «продукты данных» вашей организации.

* **Protected:** Модели с уровнем доступа `protected` могут использоваться только внутри одного проекта. Это уровень доступа по умолчанию.  
В будущем мы обсуждаем расширение `protected`, чтобы такие модели можно было использовать в _определённых_ downstream-проектах. Подробнее см. [GitHub issue](https://github.com/dbt-labs/dbt-core/issues/9340). Если этот сценарий вам интересен — поставьте апвоут или оставьте комментарий.

* **Private:** Механизм `groups` позволяет более тонко контролировать использование `private`-моделей. Определив группу и назначив модели в эту группу, вы можете запретить другим моделям (не входящим в ту же группу) ссылаться на любые `private`-модели внутри неё. Группы также предоставляют стандартный механизм для задания `owner` всех ресурсов, которые они содержат.

В <Constant name="explorer" /> модели с уровнем доступа `public` доступны для обнаружения всем пользователям аккаунта <Constant name="cloud" /> — каждая публичная модель отображается в режиме «multi-project». В отличие от них, `protected` и `private`-модели видны только тем пользователям, у которых есть доступ к соответствующему проекту (включая доступ только для чтения).

Поскольку dbt не синхронизирует автоматически `grants` на уровне хранилища данных с параметром `access` на уровне моделей, между ними возможны расхождения. Например, метаданные `public`-модели видны всем пользователям <Constant name="cloud" />, любой может написать `ref` на такую модель, но при фактическом запуске или предпросмотре выясняется, что у пользователя нет доступа к данным в хранилище. **Это сделано намеренно.** Такой подход позволяет сохранять принцип минимально необходимого доступа к данным, одновременно обеспечивая прозрачность и обнаруживаемость данных для всей организации. Зная, какие «продукты данных» (публичные модели) существуют — их описания, владельцев и набор колонок — аналитик из другой команды может подготовить обоснованный запрос на доступ к исходным данным.

</DetailsToggle>

<DetailsToggle alt_header="Можно ли запрашивать права доступа у других команд прямо в dbt?">

На данный момент — нет. Но мы рассматриваем возможность добавить такую функциональность в будущем.

</DetailsToggle>

<DetailsToggle alt_header="Как участник центральной data-команды, могу ли я сохранять видимость всего DAG организации?">

Да! Если у пользователя есть права доступа (как минимум доступ только для чтения) ко всем проектам в аккаунте <Constant name="cloud" />, он может перемещаться по всему DAG организации в <Constant name="explorer" /> и просматривать модели на всех уровнях детализации.

</DetailsToggle>

<DetailsToggle alt_header="Как ограничить доступ разработчиков к чувствительным production-данным при ссылках на другие проекты?">

По умолчанию кросс-проектные ссылки разрешаются на deployment-окружение «Production» апстрим-проекта. Если в вашей организации данные в production и non-production окружениях действительно различаются, это может стать проблемой.

Поэтому мы ввели канонический тип deployment-окружения — «[Staging](/docs/deploy/deploy-environments#staging-environment)». Если в проекте определены и «Production», и «Staging» окружения, то кросс-проектные ссылки из development- и «Staging»-окружений будут указывать на «Staging», а только ссылки из «Production»-окружений — на «Production». Таким образом обеспечивается строгая изоляция окружений данных без необходимости дублировать конфигурации проектов.

</DetailsToggle>

<DetailsToggle alt_header="Работает ли dbt Mesh, если проекты 'дублируются' (проект разработки <> проект производства)?">

Краткий ответ: "нет." Перекрестные ссылки на проекты требуют, чтобы каждое имя проекта было уникальным в вашем аккаунте dbt Cloud.

Исторические ограничения требовали от клиентов "дублировать" проекты, чтобы один фактический проект dbt (кодовая база) соответствовал более чем одному проекту dbt Cloud. В этой связи мы работаем над устранением исторических ограничений, которые требовали от клиентов "дублировать" проекты в dbt Cloud — Стадии для изоляции данных, разрешения на уровне среды и подключения к хранилищу данных на уровне среды (скоро появится). Как только эти элементы будут на месте, больше не будет необходимости определять отдельные проекты dbt Cloud для изоляции сред данных или разрешений.

</DetailsToggle>

## Совместимость с другими возможностями

<DetailsToggle alt_header="Как dbt Semantic Layer связан с dbt Mesh и как они работают вместе?">

import SLMeshFAQs from '/snippets/_sl-dbt-mesh-faq.md';

[<Constant name="semantic_layer" />](/docs/use-dbt-semantic-layer/dbt-sl) и dbt Mesh — это взаимодополняющие механизмы, предоставляемые <Constant name="cloud" />, которые совместно улучшают управление, удобство использования и управление данными (governance) в масштабных средах данных.

<Constant name="semantic_layer" /> в <Constant name="cloud" /> позволяет командам централизованно определять бизнес‑метрики и измерения. Это обеспечивает единообразие и надежность определений метрик в различных аналитических инструментах и платформах.

<Constant name="mesh" /> позволяет организациям разделять архитектуру данных на несколько доменно‑ориентированных проектов, сохраняя при этом возможность ссылаться на «публичные» модели между проектами. Также возможно ссылаться на «публичную» модель из другого проекта с целью определения семантических моделей и метрик. Ваша организация может иметь несколько dbt‑проектов, которые наполняют единый семантический слой, обеспечивая согласованное и однозначное определение и понимание метрик и измерений во всех этих доменах.

<SLMeshFAQs/>

</DetailsToggle>

<DetailsToggle alt_header="Как dbt Catalog соотносится с dbt Mesh и как они работают вместе?">

**[<Constant name="explorer" />](/docs/explore/explore-projects)** — это инструмент внутри <Constant name="cloud" />, который выступает в роли базы знаний и платформы визуализации lineage. Он предоставляет полное представление обо всех dbt-артефактах, включая модели, тесты, источники и их взаимозависимости.

В сочетании с dbt Mesh, <Constant name="explorer" /> становится мощным инструментом для визуализации и понимания связей и зависимостей между моделями в нескольких dbt-проектах.

</DetailsToggle>

<DetailsToggle alt_header="Как dbt CLI соотносится с dbt Mesh и как они работают вместе?" />

[CLI <Constant name="cloud" />](/docs/cloud/cloud-cli-installation) позволяет пользователям разрабатывать и запускать dbt-команды из предпочитаемых сред разработки, таких как VS Code, Sublime Text или терминал. Эта гибкость особенно полезна в конфигурации dbt Mesh, где управление несколькими проектами может быть сложным. Разработчики могут работать в привычных инструментах, одновременно используя централизованные возможности <Constant name="cloud" />.

</DetailsToggle>

</DetailsToggle>

## Доступность

<DetailsToggle alt_header="Требует ли dbt Mesh использования определенной версии dbt?">

Да, ваша учетная запись должна быть как минимум на версии [dbt v1.6](/docs/dbt-versions/upgrade-dbt-version-in-cloud), чтобы вы могли воспользоваться [межпроектными зависимостями](/docs/mesh/govern/project-dependencies) — одной из самых важных базовых возможностей, необходимых для реализации dbt Mesh.

</DetailsToggle>

<DetailsToggle alt_header="Есть ли способ использовать возможности dbt Mesh в dbt Core?">

Хотя dbt Core определяет ряд базовых элементов для dbt Mesh, <Constant name="cloud" /> предлагает расширенный пользовательский опыт, который использует эти элементы для масштабируемого взаимодействия между несколькими командами. Это достигается за счёт мультипроектного обнаружения в <Constant name="explorer" />, настроенного в соответствии с уровнем доступа каждого пользователя.

Несколько ключевых компонентов, лежащих в основе паттерна dbt Mesh, включая [контракты моделей, версии и модификаторы доступа](/docs/mesh/govern/about-model-governance), определены и реализованы в dbt Core. Мы считаем, что это элементы базового языка dbt, поэтому их реализации являются open source. Наша цель — определить стандартный паттерн, который аналитические инженеры по всему миру смогут использовать, расширять и помогать нам улучшать.

Для обращения к моделям, определённым в другом проекте, пользователи также могут использовать [packages](/docs/build/packages) — давнюю функциональность dbt Core. При импорте апстрим‑проекта как пакета dbt загрузит все модели, определённые в этом проекте, что позволяет разрешать кросс‑проектные ссылки на эти модели. При необходимости доступ можно [ограничить](/docs/mesh/govern/model-access#how-do-i-restrict-access-to-models-defined-in-a-package) только моделями с уровнем доступа `public`.

Ключевое отличие связано с сервисом метаданных <Constant name="cloud" />, который является уникальной возможностью платформы <Constant name="cloud" /> и позволяет разрешать ссылки только на публичные модели проекта. Этот сервис даёт пользователям возможность зависеть от апстрим‑проектов и ссылаться исключительно на их `public`‑модели, *без* необходимости загружать всю сложность этих апстрим‑проектов в локальную среду разработки.

</DetailsToggle>

<DetailsToggle alt_header="Требуется ли для dbt Mesh определённый тариф dbt?">

Да, для настройки нескольких проектов и ссылки на модели между ними требуется тариф [<Constant name="cloud" /> уровня Enterprise](https://www.getdbt.com/pricing). Подробнее о возможностях, доступных в разных тарифах <Constant name="cloud" />, см. в разделе [model governance](/docs/mesh/govern/about-model-governance).

</DetailsToggle>

</DetailsToggle>

## Советы по внедрению dbt Mesh

<DetailsToggle alt_header="Есть ли рекомендованный процесс миграции или внедрения?">

Обратитесь к нашему руководству для разработчиков [How we structure our dbt Mesh projects](/best-practices/how-we-mesh/mesh-1-intro). Также вам может быть интересно посмотреть запись этого доклада с Coalesce 2023: [Unlocking model governance and multi-project deployments with dbt-meshify](https://www.youtube.com/watch?v=FAsY0Qx8EyU).

Вы также можете узнать, как внедрить dbt Mesh, следуя нашему [Руководству по быстрому старту dbt Mesh](/guides/mesh-qs).

</DetailsToggle>

<DetailsToggle alt_header="Есть ли инструменты, которые помогут мне мигрировать на dbt Mesh?">

`dbt-meshify` — это [CLI-инструмент](https://github.com/dbt-labs/dbt-meshify), который автоматизирует создание функций управления моделями и межпроектной родословной, введенных в dbt-core v1.5 и v1.6. Этот пакет будет использовать метаданные вашего проекта dbt для создания и/или редактирования файлов в вашем проекте, чтобы правильно настроить модели в вашем проекте с этими функциями.
</DetailsToggle>

<DetailsToggle alt_header="Моя команда не структурирована для необходимости нескольких проектов сегодня. Какие аспекты dbt Mesh актуальны для меня?">

Предположим, в вашей организации менее 500 моделей и менее дюжины регулярных участников dbt. Вы работаете на масштабе, который хорошо обслуживается монолитом (один проект), и более крупный шаблон dbt Mesh, вероятно, не принесет никаких немедленных преимуществ.

Никогда не рано думать о том, как вы организуете модели _внутри_ этого проекта. Используйте `группы` моделей, чтобы определить четкие границы владения и `частный` доступ, чтобы ограничить использование моделей, созданных для определенной цели, от становления несущими блоками в несвязанной части DAG. Ваши будущие "я" будут благодарны вам за определение этих интерфейсов, особенно если вы достигнете масштаба, при котором имеет смысл "выпускать" интерфейсы между `группами` в границы между проектами.

</DetailsToggle>
