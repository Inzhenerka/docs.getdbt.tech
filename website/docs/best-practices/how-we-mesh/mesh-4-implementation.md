---
title: "Реализация вашего плана Mesh"
description: Начало работы с паттернами dbt Mesh
hoverSnippet: Узнайте, как начать работу с dbt Mesh
---

### С чего начать ваше путешествие в Mesh?

Переход на dbt Mesh представляет собой значительное изменение в архитектуре разработки и развертывания. Прежде чем проводить достаточно сложную рефакторизацию программного обеспечения или миграцию, важно задать вопрос: «Почему это может не сработать?» Две самые распространенные причины, с которыми мы сталкивались, заключаются в следующем:

1. Отсутствие согласия по поводу того, что dbt Mesh является правильной долгосрочной архитектурой.
2. Отсутствие согласованности по поводу хорошо определенной отправной точки.

Создание согласованности в вашей архитектуре и отправной точке — это важные шаги для обеспечения успешной миграции. Определение правильной отправной точки будет выглядеть по-разному для каждой организации, но есть некоторые эвристики, которые могут помочь вам решить, с чего начать. Скорее всего, в вашей организации уже есть логические компоненты, и вы, возможно, уже группируете, строите и развертываете ваш проект в соответствии с этими интерфейсами. Цель состоит в том, чтобы определить и формализовать эти организационные интерфейсы и использовать эти границы для разделения вашего проекта по доменам.

Как найти эти организационные интерфейсы? Вот несколько шагов, чтобы начать:

- **Поговорите с командами** о том, какое разделение существует в настоящее время.
  - Есть ли различные домены, на которых сосредоточены люди?
  - Есть ли различные размеры, формы и источники данных, которые обрабатываются отдельно (например, данные о кликах)?
  - Есть ли люди, сосредоточенные на различных уровнях трансформации, таких как загрузка и подготовка данных или создание marts?
  - Есть ли одна команда, которая находится *вниз по потоку* от вашего текущего проекта dbt, которая могла бы легче перейти на dbt Mesh в качестве потребителя?

При попытке определить интерфейсы вашего проекта вам следует рассмотреть возможность исследования:

- **Ваших задач:** Какие наборы моделей чаще всего создаются вместе?
- **Вашей графа наследования:** Как связаны модели?
- **Ваших селекторов (определенных в `selectors.yml`):** Как люди уже определяют группы ресурсов?

Давайте рассмотрим пример процесса преобразования монолитного проекта, используя группы и доступ для определения интерфейсов, а затем разделим его на несколько проектов.

Чтобы узнать больше, обратитесь к нашему бесплатному [курсу по обучению dbt Mesh](https://learn.getdbt.com/courses/dbt-mesh). 


## Определение интерфейсов проекта с помощью групп и доступа

Как только у вас появится представление о некоторых начальных группах, вы можете сначала реализовать **группы и настройки доступа** в рамках одного проекта.

- Сначала вы можете создать [группу](/docs/build/groups), чтобы определить владельца набора моделей.

```yml
# в models/__groups.yml

groups: 
  - name: marketing
    owner:
        name: Ben Jaffleck 
        email: ben.jaffleck@jaffleshop.com
```

- Затем мы можем добавить модели в эту группу, используя ключ `group:` в YAML-записи модели.

```yml
# в models/marketing/__models.yml

models: 
  - name: fct_marketing_model
    group: marketing
  - name: stg_marketing_model
    group: marketing
```

- После того как вы добавили модели в группу, вы можете **добавить [настройки доступа](/docs/collaborate/govern/model-access) к моделям** на основе их связей между группами, *выбирая наиболее закрытый доступ, который сохранит текущую функциональность*. Это означает, что любая модель, которая имеет *только* связи с другими моделями в той же группе, должна быть `private`, а любая модель, которая имеет межгрупповые связи или является терминальным узлом в DAG группы, должна быть `protected`, чтобы другие части DAG могли продолжать ссылаться на нее.

```yml
# в models/marketing/__models.yml

models: 
  - name: fct_marketing_model
    group: marketing
    access: protected
  - name: stg_marketing_model
    group: marketing
    access: private
```

- **Проверьте эти группы, постепенно мигрируя ваши задачи** для выполнения этих групп конкретно через синтаксис выбора. Мы рекомендуем делать это параллельно с вашими производственными задачами, пока вы не будете уверены в них. Это поможет вам понять, правильно ли вы провели границы.
- Если вы обнаружите, что **постоянно вносите изменения в несколько групп**, когда обновляете логику, это знак того, что **вам, возможно, стоит пересмотреть ваши группы**.

## Разделите ваши проекты

1. **Переместите ваши сгруппированные модели в подпапку**. Это будет включать любую модель из выбранной группы, ее связанную YAML-запись, а также ее родительские или дочерние ресурсы в зависимости от того, где эта группа находится в вашем DAG.
   1. Обратите внимание, что, как и в вашем проекте dbt, циклические ссылки не допускаются! Проект B не может иметь родителей и детей в проекте A, например.
2. **Создайте новый файл `dbt_project.yml`** в подпапке.
3. **Скопируйте любые макросы**, используемые ресурсами, которые вы переместили.
4. **Создайте новый файл `packages.yml`** в вашей подпапке с пакетами, которые используются ресурсами, которые вы переместили.
5. **Обновите функции `{{ ref }}`** &mdash; Для любой модели, которая имеет межпроектную зависимость (это может быть в файлах, которые вы переместили, или в файлах, которые остались в вашем проекте):
   1. Обновите функцию `{{ ref() }}`, чтобы она имела два аргумента, где первый — это имя исходного проекта, а второй — имя модели: например, `{{ ref('jaffle_shop', 'my_upstream_model') }}`
   2. Обновите конфигурации `access` родительских моделей, находящихся выше по потоку, на `public`, чтобы гарантировать, что любой проект может безопасно `{{ ref() }}` эти модели.
   3. Мы *настоятельно* рекомендуем добавить [контракт модели](/docs/collaborate/govern/model-contracts) к моделям выше по потоку, чтобы гарантировать, что форма данных является последовательной и надежной для ваших потребителей ниже по потоку.
6. **Создайте файл `dependencies.yml`** ([docs](/docs/collaborate/govern/project-dependencies)) для проекта ниже по потоку, объявив проект выше по потоку как зависимость.

```yml

# в dependencies.yml
projects:
  - name: jaffle_shop
```

### Лучшие практики

- Когда вы **подтвердите правильные группы**, пришло время разделить ваши проекты.
  - **Делайте *одну* группу за раз**!
  - **Не рефакторите во время миграции**, как бы это ни было заманчиво. Сосредоточьтесь на достижении паритета 1 к 1 и зафиксируйте любые проблемы, которые вы обнаружите в процессе миграции, для дальнейшего рассмотрения. Как только вы полностью мигрируете проект, вы можете начать оптимизировать его для новой жизни в рамках вашего Mesh.
- Начните с разделения вашего проекта в рамках одного репозитория для полного отслеживания git и легкого возврата, если вам нужно начать с нуля.


## Подключение существующих проектов

Некоторые организации могут уже координировать работу через несколько проектов dbt. Чаще всего это происходит через:

1. Установку родительских проектов в качестве пакетов dbt.
2. Использование функций `{{ source() }}` для чтения выходных данных родительского проекта в качестве входных данных для дочернего проекта.

Это имеет несколько недостатков:

1. Если используются пакеты, каждый проект должен включать *все* ресурсы из *всех* проектов в своем манифесте, что замедляет работу dbt и цикл разработки.
2. Если используются источники, возникают разрывы в наследовании, так как нет реальной связи между родительскими и дочерними проектами.

Шаги миграции здесь гораздо проще, чем разделение монолита!

1. Если используется метод `package`:
   1. В родительском проекте:
      1. пометьте все модели, на которые ссылаются ниже по потоку, как `public` и добавьте контракт модели.
   2. В дочернем проекте:
      1. Удалите запись пакета из `packages.yml`
      2. Добавьте проект выше по потоку в ваш `dependencies.yml`
      3. Обновите функции `{{ ref() }}` для моделей из проекта выше по потоку, чтобы включить аргумент с именем проекта.
2. Если используется метод `source`:
   1. В родительском проекте:
      1. пометьте все модели, которые импортируются ниже по потоку, как `public` и добавьте контракт модели.
   2. В дочернем проекте:
      1. Добавьте проект выше по потоку в ваш `dependencies.yml`
      2. Замените функции `{{ source() }}` на межпроектные функции `{{ ref() }}`.
      3. Удалите ненужные определения `source`.

## Дополнительные ресурсы
### Наши примерные проекты

Мы предоставили набор примерных проектов, которые вы можете использовать для изучения тем, рассмотренных здесь. Мы разделили наш проект [Jaffle Shop](https://github.com/dbt-labs/jaffle-shop) на 3 отдельных проекта в многорепозитории dbt Mesh. Обратите внимание, что вам нужно будет использовать dbt Cloud для работы с многопроектной архитектурой, так как межпроектные ссылки поддерживаются через API dbt Cloud.

- **[Платформа](https://github.com/dbt-labs/jaffle-shop-mesh-platform)** - содержащая наши централизованные модели подготовки.
- **[Маркетинг](https://github.com/dbt-labs/jaffle-shop-mesh-marketing)** - содержащая наши маркетинговые marts.
- **[Финансы](https://github.com/dbt-labs/jaffle-shop-mesh-finance)** - содержащая наши финансовые marts.

### dbt-meshify

Мы рекомендуем использовать инструмент командной строки `dbt-meshify` [command line tool](<https://dbt-labs.github.io/dbt-meshify/>), чтобы помочь вам в этом. Он включает в себя операции CLI для автоматизации большинства вышеуказанных шагов.

## Связанные документы
- [Быстрый старт с dbt Mesh](/guides/mesh-qs)