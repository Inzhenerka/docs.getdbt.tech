---
title: "Клонирование инкрементных моделей как первый шаг вашего CI задания"
id: "clone-incremental-models"
description: Узнайте, как определить клонирование инкрементных моделей в качестве первого шага вашего CI задания.
displayText: Клонирование инкрементных моделей как первый шаг вашего CI задания
hoverSnippet: Узнайте, как клонировать инкрементные модели для CI заданий.
---

Перед тем как начать, вам необходимо знать несколько условий:
- `dbt clone` доступен только в версиях dbt 1.6 и новее. Обратитесь к нашему [руководству по обновлению](/docs/dbt-versions/upgrade-dbt-version-in-cloud) для получения помощи в активации новых версий в dbt Cloud.
- Эта стратегия работает только для хранилищ, которые поддерживают клонирование без копирования (в противном случае `dbt clone` просто создаст указатели).
- Некоторые команды могут захотеть протестировать, что их инкрементные модели работают как в инкрементном режиме, так и в режиме полного обновления.

Представьте, что вы создали [Slim CI задание](/docs/deploy/continuous-integration) в dbt Cloud, и оно настроено на:

- Отложение на вашу производственную среду.
- Выполнение команды `dbt build --select state:modified+`, чтобы запустить и протестировать все модели, которые вы изменили, и их зависимые модели.
- Срабатывание каждый раз, когда разработчик вашей команды открывает PR против основной ветки.

<Lightbox src="/img/best-practices/slim-ci-job.png" width="70%" title="Пример slim CI задания с вышеуказанными настройками" />

Теперь представьте, что ваш проект dbt выглядит примерно так в DAG:

<Lightbox src="/img/best-practices/dag-example.png" width="70%" title="Пример DAG проекта" />

Когда вы открываете pull request (PR), который изменяет `dim_wizards`, ваше CI задание начнется и построит _только измененные модели и их зависимые модели_ (в данном случае, `dim_wizards` и `fct_orders`) в временной схеме, уникальной для вашего PR.

Это построение имитирует поведение того, что произойдет, когда PR будет объединен с основной веткой. Это гарантирует, что вы не вводите разрушающие изменения, не нужно строить весь ваш проект dbt.

## Что происходит, когда одна из измененных моделей (или одна из их зависимых моделей) является инкрементной моделью?

Поскольку ваше CI задание строит измененные модели в схему, специфичную для PR, при первом выполнении `dbt build --select state:modified+` измененная инкрементная модель будет построена полностью _потому что она еще не существует в схеме, специфичной для PR_ и [is_incremental будет ложным](/docs/build/incremental-models#understand-the-is_incremental-macro). Вы работаете в режиме `full-refresh`.

Это может быть не оптимально, потому что:
- Обычно инкрементные модели являются вашими крупнейшими наборами данных, поэтому их полное построение занимает много времени, что может замедлить время разработки и привести к высоким затратам на хранилище.
- Бывают ситуации, когда `full-refresh` инкрементной модели проходит успешно в вашем CI задании, но _инкрементное_ построение той же таблицы в продакшене потерпит неудачу, когда PR будет объединен с основной веткой (подумайте о сдвиге схемы, когда [on_schema_change](/docs/build/incremental-models#what-if-the-columns-of-my-incremental-model-change) настроен на `fail`).

Вы можете смягчить эти проблемы, клонируя соответствующие, уже существующие инкрементные модели в вашу схему, специфичную для PR, как первый шаг CI задания, используя команду `dbt clone`. Таким образом, инкрементные модели уже будут существовать в схеме, специфичной для PR, когда вы впервые выполните команду `dbt build --select state:modified+`, поэтому флаг `is_incremental` будет `true`.

У вас будет две команды для выполнения проверки CI в dbt Cloud:
1. Клонировать все существующие инкрементные модели, которые были изменены или являются зависимыми от другой измененной модели:
  ```shell
  dbt clone --select state:modified+,config.materialized:incremental,state:old
  ```
2. Построить все модели, которые были изменены, и их зависимые модели:
  ```shell
  dbt build --select state:modified+
  ```

Благодаря вашему первому шагу клонирования, инкрементные модели, выбранные в вашем `dbt build` на втором шаге, будут работать в инкрементном режиме.

<Lightbox src="/img/best-practices/clone-command.png" width="70%" title="Команда клонирования в конфигурации CI" />

Ваши CI задания будут выполняться быстрее, и вы более точно имитируете поведение того, что произойдет, когда PR будет объединен с основной веткой.

### Расширение на "подумайте о сдвиге схемы", когда конфигурация [on_schema_change](/docs/build/incremental-models#what-if-the-columns-of-my-incremental-model-change) установлена на `fail`

Представьте, что у вас есть инкрементная модель `my_incremental_model` с следующей конфигурацией:

```sql

{{
    config(
        materialized='incremental',
        unique_key='unique_id',
        on_schema_change='fail'
    )
}}

```

Теперь, предположим, вы открываете PR, который добавляет новый столбец в `my_incremental_model`. В этом случае:
- Инкрементное построение потерпит неудачу.
- Полное обновление пройдет успешно.

Если у вас есть ежедневная производственная задача, которая просто выполняет `dbt build` без флага `--full-refresh`, как только PR будет объединен с основной веткой и задача начнется, вы получите ошибку. Так что вопрос в том, что вы хотите, чтобы произошло в CI?
- Хотите ли вы также получить ошибку в CI, чтобы знать, что как только этот PR будет объединен с основной веткой, вам нужно немедленно выполнить `dbt build --full-refresh --select my_incremental_model` в продакшене, чтобы избежать ошибки в продакшене? Это заблокирует вашу проверку CI от успешного завершения.
- Хотите ли вы, чтобы ваша проверка CI прошла успешно, потому что как только вы выполните `full-refresh` для этой модели в продакшене, вы будете в успешном состоянии? Это может привести к неприятным сюрпризам, если ваша производственная задача внезапно потерпит неудачу, когда вы объединяете этот PR с основной веткой, если вы не помните, что вам нужно выполнить `dbt build --full-refresh --select my_incremental_model` в продакшене.

Здесь, вероятно, нет идеального решения; это все компромиссы! Наша предпочтение было бы иметь неудачное CI задание и вручную отменить блокирующее правило защиты ветки, чтобы не было сюрпризов, и мы могли проактивно выполнить соответствующую команду в продакшене, как только PR будет объединен.

### Расширение на "почему `state:old`"

Для совершенно новых инкрементных моделей вы хотите, чтобы они работали в режиме `full-refresh` в CI, потому что они будут работать в режиме `full-refresh` в продакшене, когда PR будет объединен с `main`. Они также еще не существуют в производственной среде... они совершенно новые!
Если вы не укажете это, вы не получите ошибку, а просто "No relation found in state manifest for…". Так что, технически, это работает без указания `state:old`, но добавление `state:old` более явно и означает, что он даже не попытается клонировать совершенно новые инкрементные модели.