---
title: Теперь ваша очередь
id: 6-how-we-style-conclusion
---

## Собственные стили

Теперь, когда вы увидели, как мы оформляем наши проекты dbt, пришло время создать свои собственные. Не стесняйтесь копировать этот гид и использовать его в качестве шаблона для вашего проекта. Если вы это сделаете, нам будет интересно узнать об этом! Свяжитесь с нами на [Форуме сообщества](https://discourse.getdbt.com/c/show-and-tell/22) или [Slack](https://www.getdbt.com/community), чтобы поделиться своим стилевым руководством. Мы рекомендуем размещать ваше стилевое руководство вместе с вашим кодом, чтобы участники могли легко следовать ему. Если вы используете GitHub, вы можете добавить ваше стилевое руководство в вики вашего репозитория или включить его в ваш README.

## Предварительные хуки

Наконец, чтобы убедиться, что автоматические правила вашего стилевого руководства соблюдаются без дополнительной умственной нагрузки для вашей команды, вы можете использовать [предварительные хуки](https://pre-commit.com/) для автоматической проверки вашего кода на наличие нарушений стиля (и часто их автоматического исправления) перед коммитом. Это отличный способ убедиться, что все участники следуют вашему стилевому руководству. Мы рекомендуем реализовать это, как только вы определитесь с вашим стилевым руководством и ваш код соответствует ему. Это обеспечит соблюдение стиля для всех будущих коммитов. Вы можете найти отличный набор открытых предварительных хуков для dbt от сообщества [здесь в проекте dbt-checkpoint](https://github.com/dbt-checkpoint/dbt-checkpoint).

## Шаблон стилевого руководства

```markdown
# Пример стилевого руководства dbt

## Стиль SQL

- Используйте ключевые слова в нижнем регистре.
- Используйте завершающие запятые.

## Организация моделей

Наши модели (обычно) делятся на две основные категории:\

- Staging — Содержит модели, которые очищают и стандартизируют данные.        
- Marts — Содержит модели, которые комбинируют или сильно трансформируют данные. 

Обратите внимание на следующее:

- Существуют разные типы моделей, которые обычно встречаются в каждой из вышеуказанных категорий. См. [Уровни моделей](#model-layers) для получения дополнительной информации.
- Читайте [Как мы структурируем наши проекты dbt](/best-practices/how-we-structure/1-guide-overview) для примера и более подробной информации об организации.

## Уровни моделей

- Только модели в `staging` должны выбирать из [sources](https://docs.getdbt.com/docs/building-a-dbt-project/using-sources).
- Модели, не находящиеся в папке `staging`, должны выбирать из [refs](https://docs.getdbt.com/reference/dbt-jinja-functions/ref).

## Именование файлов моделей и кодирование

- Все объекты должны быть во множественном числе.  
  Пример: `stg_stripe__invoices.sql` против `stg_stripe__invoice.sql`

- Все модели должны использовать соглашение об именовании `<type/dag_stage>_<source/topic>__<additional_context>`. См. [эту статью](https://docs.getdbt.com/blog/stakeholder-friendly-model-names) для получения дополнительной информации.

  - Модели в папке **staging** должны использовать имя источника в качестве `<source/topic>` и имя сущности в качестве `additional_context`.

    Примеры:

    - seed_snowflake_spend.csv
    - base_stripe\_\_invoices.sql
    - stg_stripe\_\_customers.sql
    - stg_salesforce\_\_customers.sql
    - int_customers\_\_unioned.sql
    - fct_orders.sql

- Имена схем, таблиц и столбцов должны быть в `snake_case`.

- Ограничьте использование аббревиатур, связанных с предметной областью. Сотруднику, проходящему обучение, будет легче понять `current_order_status`, чем `current_os`.

- Используйте названия, основанные на _бизнесе_, а не на терминологии источника.

- Каждая модель должна иметь первичный ключ для идентификации уникальной строки и должна называться `<object>_id`. Например, `account_id`. Это упрощает понимание того, какой `id` ссылается на объединенные модели ниже.

- Для моделей `base` или `staging` столбцы должны быть упорядочены по категориям, где идентификаторы идут первыми, а поля даты/времени — в конце.
- Столбцы даты/времени должны именоваться в соответствии с этими соглашениями:

  - Временные метки: `<event>_at`  
    Формат: UTC  
    Пример: `created_at`

  - Даты: `<event>_date`
    Формат: Дата  
    Пример: `created_date`

- Логические значения должны иметь префикс `is_` или `has_`.
  Пример: `is_active_customer` и `has_admin_access`

- Поля цены/дохода должны быть в десятичной валюте (например, `19.99` для $19.99; многие базы данных приложений хранят цены как целые числа в центах). Если используется недесятичная валюта, укажите это с помощью суффиксов. Например, `price_in_cents`.

- Избегайте использования зарезервированных слов (таких как [эти](https://docs.snowflake.com/en/sql-reference/reserved-keywords.html) для Snowflake) в качестве имен столбцов.

- Последовательность — это ключ! Используйте одни и те же имена полей в моделях, где это возможно. Например, ключ к таблице `customers` должен называться `customer_id`, а не `user_id`.

## Конфигурации моделей

- Конфигурации моделей на [уровне папки](https://docs.getdbt.com/reference/model-configs#configuring-directories-of-models-in-dbt_projectyml) должны рассматриваться (и, если применимо, применяться) в первую очередь.
- Более специфические конфигурации должны применяться на уровне модели [с использованием одного из этих методов](https://docs.getdbt.com/reference/model-configs#apply-configurations-to-one-model-only).
- Модели в папке `marts` должны быть материализованы как `table` или `incremental`.
  - По умолчанию `marts` должны быть материализованы как `table` в `dbt_project.yml`.
  - Если вы переходите на `incremental`, это должно быть указано в конфигурации модели.

## Тестирование

- Минимум, тесты `unique` и `not_null` должны применяться к ожидаемому первичному ключу каждой модели.

## CTE

Для получения дополнительной информации о том, почему мы используем так много CTE, читайте [этот глоссарный термин](https://docs.getdbt.com/terms/cte).

- Где это позволяет производительность, CTE должны выполнять единое логическое действие.
- Имена CTE должны быть настолько подробными, насколько это необходимо, чтобы передать, что они делают.
- CTE с запутанной или заметной логикой должны быть прокомментированы с помощью SQL-комментариев, как вы бы сделали с любыми сложными функциями, и должны находиться выше CTE.
- CTE, дублирующиеся в разных моделях, должны быть вынесены и созданы как отдельные модели.
```