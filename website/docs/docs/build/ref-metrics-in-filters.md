---
title: "Метрики как измерения с фильтрами метрик"
id: "ref-metrics-in-filters"
description: "Добавьте метрики в качестве измерений к вашим фильтрам метрик, чтобы создать более сложные метрики и получить больше информации."
sidebar_label: "Метрики как измерения"
---

[Метрики](/docs/build/metrics-overview) предоставляют пользователям ценную информацию о их данных, такую как количество активных пользователей и общие тенденции производительности для принятия бизнес-решений. [Измерения](/docs/build/dimensions), с другой стороны, помогают классифицировать данные через атрибуты, такие как тип пользователя или количество заказов, размещенных клиентом.

Для принятия обоснованных бизнес-решений некоторые метрики требуют значения другой метрики в качестве части определения метрики, что приводит нас к "метрикам как измерениям".

Этот документ объясняет, как вы можете использовать метрики в качестве измерений с фильтрами метрик, что позволяет создавать более сложные метрики и получать больше информации. Доступно в dbt Cloud для версий 1.8 и выше.

## Ссылка на метрику в фильтре

Используйте синтаксис объекта `Metric()` для ссылки на метрику в фильтре `where` для другой метрики. Функция для ссылки на метрику принимает имя метрики и ровно один объект:

```yaml
{{ Metric('metric_name', group_by=['entity_name']) }}
```

### Пример использования

В качестве примера, компания, предоставляющая программное обеспечение как услугу (SaaS), хочет подсчитать активированные аккаунты. В этом случае определение активированного аккаунта — это аккаунт с более чем пятью запусками модели данных.

Чтобы выразить эту метрику на SQL, компания:
- Напишет запрос для расчета количества запусков модели данных на аккаунт.
- Затем подсчитает количество аккаунтов, у которых более пяти запусков модели данных.

<File name="models/model_name.sql">

```sql
with data_models_per_user as (
    select
        account_id as account,
        count(model_runs) as data_model_runs
    from 
        {{ ref('fct_model_runs') }}
    group by 
        account_id
),

activated_accounts as (
    select
        count(distinct account_id) as activated_accounts
    from 
        {{ ref('dim_accounts') }}
    left join 
        data_models_per_user 
    on 
        {{ ref('dim_accounts') }}.account_id = data_models_per_user.account
    where 
        data_models_per_user.data_model_runs > 5
)

select
    *
from 
    activated_accounts
```
</File>

Этот SQL-запрос вычисляет количество `activated_accounts`, используя метрику `data_model_runs` в качестве измерения для сущности пользователя. Он фильтрует на основе значения метрики, ограниченного сущностью аккаунта. Вы можете выразить эту логику на уровне запроса или в YAML-конфигурации метрики.

#### YAML-конфигурация

Используя тот же пример `activated_accounts`, упомянутый в [примере использования](#usage-example), следующий YAML-пример объясняет, как компания может создать [семантические модели](/docs/build/semantic-models) и [метрики](/docs/build/metrics-overview), и использовать объект `Metric()` для ссылки на метрику `data_model_runs` в фильтре метрики `activated_accounts`:

- Создайте две семантические модели: `model_runs` и `accounts`.
- Создайте `measure` и `metric` для подсчета запусков модели данных, и еще одну меру для подсчета пользователей.
- Укажите внешнюю сущность `account` в семантической модели `model_runs`.
- Затем создайте метрику `Activated Accounts`, фильтруя аккаунты, у которых более пяти запусков модели данных.

  <File name="models/metrics/semantic_model.yml">

  ```yaml
  semantic_models:
    - name: model_runs
      ... # Заполнитель для других конфигураций
      entities:
        - name: model_run
          type: primary
        - name: account
          type: foreign
      measures:
        - name: data_model_runs
          agg: sum
          expr: 1
          create_metric: true # Атрибут 'create_metric: true' автоматически создает метрику 'data_model_runs'.

    - name: accounts
      ... # Заполнитель для других конфигураций
      entities:
        - name: account
          type: primary
      measures:
        - name: accounts
          agg: sum
          expr: 1
          create_metric: true
  metrics:
    - name: activated_accounts
      label: Activated Accounts
      type: simple
      type_params:
        measure: accounts
      filter: |
        {{ Metric('data_model_runs', group_by=['account']) }} > 5
  ```
  </File>

Давайте разберем SQL, который система генерирует на основе определения метрики, когда вы запускаете `dbt sl query --metrics activated_accounts` из интерфейса командной строки:

- Фильтр `{{ Metric('data_model_runs', group_by=['account']) }}` генерирует SQL, аналогичный подзапросу `data_models_per_user`, показанному ранее:

	```sql
	select
		sum(1) as data_model_runs,
		account
	from 
		data_model_runs
	group by
		account
	```

- MetricFlow объединяет этот запрос с запросом, сгенерированным мерой `accounts`, по элементам группировки и применяет условия фильтрации:

	```sql
	select
      sum(1) as activated_accounts
	from accounts
  left join (
      select
          sum(1) as data_model_runs, 
		      account
	    from data_model_runs
	    group by 
		      account
  ) as subq on accounts.account = subq.account
  where data_model_runs > 5
	```

Промежуточные таблицы, используемые для создания этой метрики: Аккаунты с измерением `data_model_runs`

  | account | data_model runs |
  | --- | --- |
  | 1 | 4 |
  | 2 | 7 |
  | 3 | 9 |
  | 4 | 1 |

MetricFlow затем фильтрует эту таблицу, чтобы получить аккаунты с более чем 5 запусками модели данных, и подсчитывает количество аккаунтов, которые соответствуют этому критерию:

  | activated_accounts |
  | --- |
  | 2 |

#### Фильтр запроса

Вы также можете использовать метрики в фильтрах на уровне запроса. Запустите эту команду в интерфейсе командной строки (CLI), чтобы сгенерировать тот же SQL-запрос, упомянутый ранее:

```dbt sl query --metrics accounts --where "{{ Metric('data_model_runs', group_by=['account']) }} > 5"```

Результирующий SQL и данные будут теми же, за исключением имени метрики `accounts` вместо `activated_accounts`.

## Учитывайте

- При использовании фильтра метрики убедитесь, что подзапрос может соединяться с внешним запросом без увеличения результата (неожиданного увеличения количества строк).
  - Пример, который фильтрует меру аккаунтов, используя `{{ Metric('data_model_runs', group_by=['account']) }}`, является допустимым, поскольку он агрегирует запуски модели на уровне аккаунта.
  - Однако фильтрация меры 'accounts' по `{{ Metric('data_model_runs', group_by=['model']) }}` недопустима из-за отношения "один-ко-многим" между аккаунтами и запусками модели, что приводит к дублированию данных.
- Вы можете группировать метрику только по одной сущности. Возможность поддержки группировки по нескольким сущностям и измерениям ожидается.
- В будущем вы сможете использовать метрики в качестве измерений для некоторых из следующих примеров использования:
  - Сегменты пользователей: сегментируйте пользователей, используя количество заказов, размещенных пользователем за последние 7 дней, в качестве измерения.
  - Прогнозирование оттока: используйте количество заявок в службу поддержки, которые аккаунт подал в первые 30 дней, чтобы предсказать потенциальный отток.
  - Отслеживание активации: определите активацию аккаунта или пользователя на основе конкретных действий, предпринятых в течение определенного количества дней после регистрации.
  - Поддержка фильтров метрик, требующих многократных соединений, ожидается.