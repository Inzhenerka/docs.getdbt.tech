---
title: "Метрики как измерения с фильтрами метрик"
id: "ref-metrics-in-filters"
description: "Добавьте метрики как измерения к вашим фильтрам метрик, чтобы создавать более сложные метрики и получать больше информации."
sidebar_label: "Метрики как измерения"
---

[Метрики](/docs/build/metrics-overview) предоставляют пользователям ценные сведения о данных, такие как количество активных пользователей и общие тенденции производительности, чтобы информировать бизнес-решения. [Измерения](/docs/build/dimensions), с другой стороны, помогают категоризировать данные через атрибуты, такие как тип пользователя или количество заказов, сделанных клиентом.

Для принятия обоснованных бизнес-решений некоторые метрики нуждаются в значении другой метрики как части определения метрики, что приводит нас к концепции "метрики как измерения".

В этом документе объясняется, как можно использовать метрики в качестве измерений с помощью фильтров метрик, что позволяет создавать более сложные метрики и получать больше аналитических инсайтов. Доступно в <Constant name="cloud" /> для версий 1.8 и выше.

## Ссылка на метрику в фильтре

Используйте синтаксис объекта `Metric()`, чтобы ссылаться на метрику в фильтре `where` для другой метрики. Функция для ссылки на метрику принимает имя метрики и ровно одну сущность:

```yaml
{{ Metric('metric_name', group_by=['entity_name']) }}
```

### Пример использования

Например, компания, предоставляющая программное обеспечение как услугу (SaaS), хочет подсчитать активированные аккаунты. В этом случае определение активированного аккаунта — это аккаунт с более чем пятью запусками модели данных.

Чтобы выразить эту метрику в SQL, компания выполнит следующие шаги:
- Напишет запрос для расчета количества запусков модели данных на аккаунт.
- Затем подсчитает количество аккаунтов, у которых более пяти запусков модели данных.

<File name="models/model_name.sql">

```sql
with data_models_per_user as (
    select
        account_id as account,
        count(model_runs) as data_model_runs
    from 
        {{ ref('fct_model_runs') }}
    group by 
        account_id
),

activated_accounts as (
    select
        count(distinct account_id) as activated_accounts
    from 
        {{ ref('dim_accounts') }}
    left join 
        data_models_per_user 
    on 
        {{ ref('dim_accounts') }}.account_id = data_models_per_user.account
    where 
        data_models_per_user.data_model_runs > 5
)

select
    *
from 
    activated_accounts
```
</File>

Этот SQL-запрос вычисляет количество `activated_accounts`, используя метрику `data_model_runs` как измерение для сущности пользователя. Он фильтрует на основе значения метрики, ограниченного сущностью аккаунта. Вы можете выразить эту логику на уровне запроса или в YAML-конфигурации метрики.

#### YAML-конфигурация

Используя тот же пример `activated_accounts`, упомянутый в [примере использования](#usage-example), следующий YAML-пример объясняет, как компания может создать [семантические модели](/docs/build/semantic-models) и [метрики](/docs/build/metrics-overview), и использовать объект `Metric()`, чтобы ссылаться на метрику `data_model_runs` в фильтре метрики `activated_accounts`:

- Создайте две семантические модели: `model_runs` и `accounts`.
- Создайте `measure` и `metric` для подсчета запусков модели данных и другую меру для подсчета пользователей.
- Укажите внешнюю сущность `account` в семантической модели `model_runs`.
- Затем создайте метрику `Activated Accounts`, фильтруя аккаунты, у которых более пяти запусков модели данных.

  <File name="models/metrics/semantic_model.yml">

  ```yaml
  semantic_models:
    - name: model_runs
      ... # Placeholder for other configurations
      entities:
        - name: model_run
          type: primary
        - name: account
          type: foreign
      measures:
        - name: data_model_runs
          agg: sum
          expr: 1
          create_metric: true # Атрибут 'create_metric: true' автоматически создает метрику 'data_model_runs'.

    - name: accounts
      ... # Placeholder for other configurations
      entities:
        - name: account
          type: primary
      measures:
        - name: accounts
          agg: sum
          expr: 1
          create_metric: true
  metrics:
    - name: activated_accounts
      label: Activated Accounts
      type: simple
      type_params:
        measure: accounts
      filter: |
        {{ Metric('data_model_runs', group_by=['account']) }} > 5
  ```
  </File>

  Давайте разберем SQL, который система генерирует на основе определения метрики, когда вы запускаете `dbt sl query --metrics activated_accounts` из интерфейса командной строки:

- Фильтр `{{ Metric('data_model_runs', group_by=['account']) }}` генерирует SQL, аналогичный подзапросу `data_models_per_user`, показанному ранее:

	```sql
	select
		sum(1) as data_model_runs,
		account
	from 
		data_model_runs
	group by
		account
	```

- MetricFlow соединяет этот запрос с запросом, сгенерированным мерой `accounts`, по элементам группировки и применяет условия фильтра:

	```sql
	select
      sum(1) as activated_accounts
	from accounts
  left join (
      select
          sum(1) as data_model_runs, 
		      account
	    from data_model_runs
	    group by 
		      account
  ) as subq on accounts.account = subq.account
  where data_model_runs > 5
	```

  Промежуточные таблицы, используемые для создания этой метрики: Аккаунты с измерением `data_model_runs`

  | account | data_model runs |
  | --- | --- |
  | 1 | 4 |
  | 2 | 7 |
  | 3 | 9 |
  | 4 | 1 |

  MetricFlow затем фильтрует эту таблицу до аккаунтов с более чем 5 запусками модели данных и подсчитывает количество аккаунтов, соответствующих этому критерию:

  | activated_accounts |
  | --- |
  | 2 |

#### Фильтр запроса

Вы также можете использовать метрики в фильтрах на уровне запроса. Запустите эту команду в интерфейсе командной строки (CLI), чтобы сгенерировать тот же SQL-запрос, на который была ссылка ранее:

```dbt sl query --metrics accounts --where "{{ Metric('data_model_runs', group_by=['account']) }} > 5"```

Полученный SQL и данные будут такими же, за исключением имени метрики `accounts` вместо `activated_accounts`.

## Соображения

- При использовании фильтра метрики убедитесь, что подзапрос может присоединиться к внешнему запросу без увеличения количества строк (неожиданного увеличения количества строк).
  - Пример, который фильтрует меру `accounts` с использованием `{{ Metric('data_model_runs', group_by=['account']) }}`, является допустимым, потому что он агрегирует запуски модели до уровня аккаунта.
  - Однако фильтрация меры 'accounts' с помощью `{{ Metric('data_model_runs', group_by=['model']) }}` недопустима из-за отношения один ко многим между аккаунтами и запусками моделей, что приводит к дублированию данных.
- Вы можете группировать метрику только по одной сущности. Возможность поддержки группировки по нескольким сущностям и измерениям ожидается.
- В будущем вы сможете использовать метрики как измерения для некоторых из следующих примеров использования:
  - Сегменты пользователей: сегментируйте пользователей, используя количество заказов, сделанных пользователем за последние 7 дней, как измерение.
  - Прогнозирование оттока: используйте количество заявок в службу поддержки, отправленных аккаунтом в первые 30 дней, чтобы предсказать потенциальный отток.
  - Отслеживание активации: определите активацию аккаунта или пользователя на основе конкретных действий, выполненных в течение определенного количества дней после регистрации.
  - Поддержка фильтров метрик, требующих многократных соединений, ожидается.