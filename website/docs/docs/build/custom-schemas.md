---
title: "Пользовательские схемы"
id: "custom-schemas"
pagination_next: "docs/build/custom-databases"
---

По умолчанию все модели dbt создаются в схеме, указанной в вашем [окружении](/docs/dbt-cloud-environments) (dbt Cloud) или [целевом профиле](/docs/core/dbt-core-environments) (dbt Core). Эта схема по умолчанию называется _целевой схемой_.

Для проектов dbt с большим количеством моделей часто бывает удобно создавать модели в нескольких схемах и группировать похожие модели вместе. Например, вы можете захотеть:

* Группировать модели по бизнес-единицам, использующим модель, создавая схемы, такие как `core`, `marketing`, `finance` и `support`.
* Скрыть промежуточные модели в схеме `staging` и представлять только модели, которые должны запрашиваться конечным пользователем, в схеме `analytics`.

Для этого укажите пользовательскую схему. dbt генерирует имя схемы для модели, добавляя пользовательскую схему к целевой схеме. Например, `<target_schema>_<custom_schema>`.

| Целевая схема | Пользовательская схема | Результирующая схема |
| ------------- | ---------------------- | --------------------- |
| analytics_prod | None | analytics_prod |
| alice_dev | None | alice_dev |
| dbt_cloud_pr_123_456 | None | dbt_cloud_pr_123_456 |
| analytics_prod | marketing | analytics_prod_marketing |
| alice_dev | marketing | alice_dev_marketing |
| dbt_cloud_pr_123_456 | marketing | dbt_cloud_pr_123_456_marketing |

## Как использовать пользовательские схемы?

Чтобы указать пользовательскую схему для модели, используйте ключ конфигурации `schema`. Как и с любой конфигурацией, вы можете сделать одно из следующего:

* применить эту конфигурацию к конкретной модели, используя блок конфигурации внутри модели
* применить ее к подкаталогу моделей, указав это в вашем файле `dbt_project.yml`

<File name='orders.sql'>

```sql
{{ config(schema='marketing') }}

select ...
```

</File>

<File name='dbt_project.yml'>

```yaml
# модели в `models/marketing/ будут созданы в схеме "*_marketing"
models:
  my_project:
    marketing:
      +schema: marketing
```

</File>

## Понимание пользовательских схем

При первом использовании пользовательских схем часто возникает недопонимание, что модель _только_ использует новую конфигурацию `schema`; например, модель с конфигурацией `schema: marketing` будет создана в схеме `marketing`. Однако dbt помещает ее в схему, такую как `<target_schema>_marketing`.

На это есть веская причина. У каждого пользователя dbt есть своя целевая схема для разработки (см. [Управление окружениями](#managing-environments)). Если dbt игнорировал бы целевую схему и использовал только пользовательскую схему модели, каждый пользователь dbt создавал бы модели в одной и той же схеме и перезаписывал бы работу друг друга.

Комбинируя целевую схему и пользовательскую схему, dbt гарантирует, что объекты, которые он создает в вашем хранилище данных, не будут конфликтовать друг с другом.

Если вы предпочитаете использовать другую логику для генерации имени схемы, вы можете изменить способ, которым dbt генерирует имя схемы (см. ниже).

### Как dbt генерирует имя схемы модели?

dbt использует макрос по умолчанию под названием `generate_schema_name`, чтобы определить имя схемы, в которой должна быть создана модель.

Следующий код представляет логику макроса по умолчанию:

```sql
{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}

        {{ default_schema }}

    {%- else -%}

        {{ default_schema }}_{{ custom_schema_name | trim }}

    {%- endif -%}

{%- endmacro %}
```
<br />

import WhitespaceControl from '/snippets/_whitespace-control.md';

<WhitespaceControl/>

## Изменение способа генерации имени схемы dbt

Если в вашем проекте dbt есть пользовательский макрос под названием `generate_schema_name`, dbt будет использовать его вместо макроса по умолчанию. Это позволяет вам настраивать генерацию имен в соответствии с вашими потребностями.

Чтобы настроить этот макрос, скопируйте пример кода из раздела [Как dbt генерирует имя схемы модели](#how-does-dbt-generate-a-models-schema-name) в файл с именем `macros/generate_schema_name.sql` и внесите необходимые изменения.

Будьте осторожны. dbt проигнорирует любые пользовательские макросы `generate_schema_name`, включенные в установленные пакеты.

<Expandable alt_header="Предупреждение: Не заменяйте `default_schema` в макросе">

Если вы изменяете способ генерации имен схем, не просто заменяйте ```{{ default_schema }}_{{ custom_schema_name | trim }}``` на ```{{ custom_schema_name | trim }}``` в макросе ```generate_schema_name```.

Если вы удалите ```{{ default_schema }}```, это приведет к тому, что разработчики будут перезаписывать модели друг друга, если они создадут свои собственные пользовательские схемы. Это также может вызвать проблемы во время разработки и непрерывной интеграции (CI).

❌ Следующий блок кода является примером того, как ваш код _не должен_ выглядеть:

```sql
{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}

        {{ default_schema }}

    {%- else -%}
    # Следующее неверно, так как опускает {{ default_schema }} перед {{ custom_schema_name | trim }}. 
        {{ custom_schema_name | trim }} 

    {%- endif -%}

{%- endmacro %}

```

</Expandable>

### Аргументы generate_schema_name

| Аргумент | Описание | Пример |
| -------- | ----------- | ------- |
| custom_schema_name | Настроенное значение `schema` в указанном узле или `none`, если значение не указано | `marketing` |
| node | `node`, который в данный момент обрабатывается dbt | `{"name": "my_model", "resource_type": "model",...}` |

### Контекст Jinja, доступный в generate_schema_name

Если вы решите написать пользовательскую логику для генерации имени схемы, стоит отметить, что не все переменные и методы доступны вам при определении этой логики. Другими словами: макрос `generate_schema_name` компилируется с ограниченным контекстом Jinja.

Следующие методы контекста _доступны_ в макросе `generate_schema_name`:

| Контекст Jinja | Тип | Доступно |
| ------------- | ---- | --------- |
| [target](/reference/dbt-jinja-functions/target) | Переменная | ✅ |
| [env_var](/reference/dbt-jinja-functions/env_var) | Переменная | ✅ |
| [var](/reference/dbt-jinja-functions/var) | Переменная | Ограничено, см. ниже |
| [exceptions](/reference/dbt-jinja-functions/exceptions) | Макрос | ✅ |
| [log](/reference/dbt-jinja-functions/log) | Макрос | ✅ |
| Другие макросы в вашем проекте | Макрос | ✅ |
| Другие макросы в ваших пакетах | Макрос | ✅ |

### Какие переменные доступны в generate_schema_name?

Глобально-области переменные и переменные, определенные в командной строке с помощью
[--vars](/docs/build/project-variables), доступны в контексте `generate_schema_name`.

### Управление различными поведениями между пакетами

Смотрите документацию по макросу `dispatch`: ["Управление различными глобальными переопределениями между пакетами"](/reference/dbt-jinja-functions/dispatch)

## Встроенный альтернативный шаблон для генерации имен схем

Распространенной настройкой является игнорирование целевой схемы в производственных окружениях и игнорирование пользовательских конфигураций схем в других окружениях (таких как разработка и CI).

Производственная среда (`target.name == 'prod'`)

| Целевая схема | Пользовательская схема | Результирующая схема |
| ------------- | ---------------------- | --------------------- |
| analytics_prod | None | analytics_prod |
| analytics_prod | marketing | marketing |

Среда разработки/CI (`target.name != 'prod'`)

| Целевая схема | Пользовательская схема | Результирующая схема |
| ------------- | ---------------------- | --------------------- |
| alice_dev | None | alice_dev |
| alice_dev | marketing | alice_dev |
| dbt_cloud_pr_123_456 | None | dbt_cloud_pr_123_456 |
| dbt_cloud_pr_123_456 | marketing | dbt_cloud_pr_123_456 |

Аналогично обычному макросу, этот подход гарантирует, что схемы из разных окружений не будут конфликтовать.

dbt поставляется с макросом для этого случая использования — под названием `generate_schema_name_for_env` — который по умолчанию отключен. Чтобы включить его, добавьте пользовательский макрос `generate_schema_name` в ваш проект, который содержит следующий код:

<File name='macros/get_custom_schema.sql'>

```sql
-- поместите это в macros/get_custom_schema.sql

{% macro generate_schema_name(custom_schema_name, node) -%}
    {{ generate_schema_name_for_env(custom_schema_name, node) }}
{%- endmacro %}
```

</File>

При использовании этого макроса вам нужно будет установить целевое имя в вашей производственной задаче на `prod`.

## Управление окружениями

В примерах макроса `generate_schema_name`, показанных в разделе [встроенный альтернативный шаблон](#a-built-in-alternative-pattern-for-generating-schema-names), используется переменная контекста `target.name`, чтобы изменить имя схемы, которое dbt генерирует для моделей. Если макрос `generate_schema_name` в вашем проекте использует переменную контекста `target.name`, вы должны убедиться, что ваши различные окружения dbt настроены соответствующим образом. Хотя вы можете использовать любую схему именования, которую хотите, мы обычно рекомендуем:

* **dev** — ваша локальная среда разработки; настроенная в файле `profiles.yml` на вашем компьютере.
* **ci** — среда [непрерывной интеграции](/docs/cloud/git/connect-github), работающая на запросах на вытягивание в GitHub, GitLab и т. д.
* **prod** — производственное развертывание вашего проекта dbt, например, в dbt Cloud, Airflow или [аналогичных](/docs/deploy/deployments).

Если ваши имена схем генерируются неправильно, дважды проверьте ваше целевое имя в соответствующем окружении.

Для получения дополнительной информации обратитесь к руководству [управления окружениями в dbt Core](/docs/core/dbt-core-environments).