---
title: "Материализации"
description: "Настройка материализаций в dbt для управления тем, как выполняется SQL и как сохраняются результирующие данные."
id: "materializations"
pagination_next: "docs/build/incremental-models"
---

## Обзор
<Term id="materialization">Материализации</Term> — это стратегии сохранения моделей dbt в хранилище данных. В dbt встроено пять типов материализаций:

- <Term id="table" />
- <Term id="view" />
- incremental
- ephemeral
- materialized view

Вы также можете настраивать [кастомные материализации](/guides/create-new-materializations?step=1) в dbt. Пользовательские материализации — это мощный способ расширить функциональность dbt под ваши конкретные задачи.

import CourseCallout from '/snippets/_materialization-video-callout.md';

<CourseCallout resource="Materializations" 
url="https://learn.getdbt.com/courses/materializations-fundamentals" 
course="Materializations fundamentals" 
/>

## Настройка материализаций
По умолчанию модели dbt материализуются как `view`. Модели можно настроить на использование другой материализации, указав параметр конфигурации [`materialized`](/reference/resource-configs/materialized), как показано на вкладках ниже.

<Tabs>

<TabItem value="Project file">

<File name='dbt_project.yml'>

```yaml
# Следующий dbt_project.yml настраивает проект со следующей структурой:
# .
# └── models
#     ├── csvs
#     │   ├── employees.sql
#     │   └── goals.sql
#     └── events
#         ├── stg_event_log.sql
#         └── stg_event_sessions.sql

name: my_project
version: 1.0.0
config-version: 2

models:
  my_project:
    events:
      # материализовать все модели в models/events как таблицы
      +materialized: table
    csvs:
      # это избыточно и не требует явной настройки
      +materialized: view
```

</File>

</TabItem>

<TabItem value="Model file">

В качестве альтернативы материализации можно настраивать непосредственно внутри SQL-файлов моделей. Это может быть полезно, если вы также задаёте конфигурации для [оптимизации производительности] — например, [специфичные для Redshift настройки](/reference/resource-configs/redshift-configs) или [специфичные для BigQuery настройки](/reference/resource-configs/bigquery-configs).

<File name='models/events/stg_event_log.sql'>

```sql

{{ config(materialized='table', sort='timestamp', dist='user_id') }}

select *
from ...
```

</File>

</TabItem>

<TabItem value="Property file">

Материализации также можно настраивать в файле `properties.yml` модели. В примере ниже показан тип материализации `table`. Полный список типов материализаций см. в разделе [materializations](/docs/build/materializations#materializations).

<File name='models/properties.yml'>

```yaml

models:
  - name: events
    config:
      materialized: table
```

</File>

</TabItem>

</Tabs>

## Материализации

### View
При использовании материализации `view` модель пересобирается как представление при каждом запуске с помощью инструкции `create view as`.
- **Плюсы:** Дополнительные данные не хранятся, представления поверх исходных данных всегда содержат самые актуальные записи.
- **Минусы:** Представления, выполняющие значительные преобразования или построенные поверх других представлений, могут медленно выполняться при запросах.
- **Рекомендации:**
    - Как правило, начинайте с представлений и переходите на другие материализации только при появлении проблем с производительностью.
    - Представления лучше всего подходят для моделей без сложных преобразований, например, переименования или приведения типов колонок.

### Table
При использовании материализации `table` модель пересобирается как <Term id="table" /> при каждом запуске с помощью инструкции `create table as`.
- **Плюсы:** Таблицы быстро обрабатываются при выполнении запросов.
- **Минусы:**
    - Пересборка таблиц может занимать много времени, особенно при сложных преобразованиях.
    - Новые записи в исходных данных не добавляются в таблицу автоматически.
- **Рекомендации:**
  - Используйте материализацию `table` для моделей, которые запрашиваются BI-инструментами, чтобы обеспечить более быстрый отклик для конечных пользователей.
  - Также используйте `table` для медленных преобразований, которые используются большим количеством downstream-моделей.

### Incremental
Модели с материализацией `incremental` позволяют dbt вставлять или обновлять записи в таблице с момента последнего запуска модели.
- **Плюсы:** Можно существенно сократить время сборки, обрабатывая только новые записи.
- **Минусы:** Инкрементальные модели требуют дополнительной настройки и относятся к продвинутому использованию dbt. Подробнее об использовании инкрементальных моделей читайте [здесь](/docs/build/incremental-models).
- **Рекомендации:**
    - Инкрементальные модели лучше всего подходят для событийных данных.
    - Используйте инкрементальные модели, когда `dbt run` начинает выполняться слишком медленно (то есть не стоит начинать с них).

### Ephemeral
Модели с материализацией `ephemeral` не создаются напрямую в базе данных. Вместо этого dbt подставляет код такой модели в зависимые от неё модели с использованием common table expression (<Term id="cte" />). Вы можете управлять идентификатором CTE с помощью [алиаса модели](/docs/build/custom-aliases), но dbt всегда добавляет к идентификатору модели префикс `__dbt__cte__`.

- **Плюсы:**
  - Можно по-прежнему писать переиспользуемую логику.
  - Ephemeral-модели помогают поддерживать <Term id="data-warehouse" /> в чистоте, уменьшая количество объектов (также рассмотрите разделение моделей по нескольким схемам с помощью [кастомных схем](/docs/build/custom-schemas)).
- **Минусы:**
    - Нельзя выполнять `select` напрямую из этой модели.
    - [Operations](/docs/build/hooks-operations#about-operations) (например, макросы, вызываемые через [`dbt run-operation`](/reference/commands/run-operation)) не могут делать `ref()` на ephemeral-узлы.
    - Чрезмерное использование ephemeral-материализации может усложнить отладку запросов.
    - Ephemeral-материализация не поддерживает [контракты моделей](/docs/mesh/govern/model-contracts#where-are-contracts-supported).
- **Рекомендации:** Используйте материализацию `ephemeral` для:
    - очень лёгких преобразований на ранних этапах вашего DAG;
    - моделей, которые используются только в одной или двух downstream-моделях;
    - случаев, когда модель не требуется запрашивать напрямую.

### Materialized View

Материализация `materialized_view` позволяет создавать и поддерживать материализованные представления в целевой базе данных.  
Материализованные представления являются комбинацией представления и таблицы и подходят для сценариев, схожих с инкрементальными моделями.

- **Плюсы:**
  - Материализованные представления сочетают производительность запросов, как у таблиц, с актуальностью данных, как у представлений.
  - Материализованные представления работают похоже на инкрементальные материализации, однако обычно могут обновляться автоматически по расписанию (в зависимости от базы данных), без регулярного пакетного обновления через dbt, которое требуется для инкрементальных материализаций.
  - `dbt run` для материализованных представлений соответствует деплою кода, как и для обычных представлений.
* **Минусы:**
  - Поскольку материализованные представления являются более сложными объектами базы данных, платформы обычно предоставляют меньше вариантов конфигурации; подробности см. в документации вашей СУБД.
  - Материализованные представления поддерживаются не всеми платформами баз данных.
- **Рекомендации:**
  - Рассмотрите использование материализованных представлений в случаях, когда инкрементальные модели подходят, но вы хотите, чтобы платформа данных сама управляла инкрементальной логикой и обновлением.

#### Отслеживание изменений конфигурации

Эта материализация использует конфигурацию [`on_configuration_change`](/reference/resource-configs/on_configuration_change), которая соответствует инкрементальной природе одноимённого объекта базы данных. Этот параметр указывает dbt пытаться применять изменения конфигурации непосредственно к объекту, когда это возможно, вместо полного пересоздания объекта для применения обновлённой конфигурации. Например, при использовании `dbt-postgres` индексы могут быть удалены и созданы заново на материализованном представлении без необходимости пересоздавать само представление.

#### Плановые обновления

В контексте команды `dbt run` материализованные представления следует рассматривать аналогично представлениям. Например, команда `dbt run` требуется только в случае возможных изменений конфигурации или SQL; по сути, это действие деплоя.  
В отличие от этого, для таблиц команда `dbt run` требуется в тех же сценариях *и тогда, когда необходимо обновить данные в таблице*.  
То же самое справедливо для инкрементальных моделей и snapshot-моделей, поскольку их базовые отношения являются таблицами.  
В случае таблиц механизмом планирования выступает либо <Constant name="cloud" />, либо ваш локальный планировщик; встроенной функциональности для автоматического обновления данных таблиц не существует.  
Однако большинство платформ (за исключением Postgres) предоставляют возможность настраивать автоматическое обновление материализованных представлений.  
Таким образом, материализованные представления работают схожим образом с инкрементальными моделями, но с преимуществом отсутствия необходимости запускать dbt для обновления данных. Разумеется, при условии, что автообновление включено и настроено в модели.

:::info
`dbt-snowflake` _не_ поддерживает материализованные представления — вместо этого используются Dynamic Tables. Подробнее см. в разделе [Snowflake specific configurations](/reference/resource-configs/snowflake-configs#dynamic-tables).
:::

## Python-материализации

Python-модели поддерживают две материализации:
- `table`
- `incremental`

Инкрементальные Python-модели поддерживают те же [инкрементальные стратегии](/docs/build/incremental-strategy), что и SQL-модели. Конкретные поддерживаемые стратегии зависят от адаптера.

Python-модели нельзя материализовать как `view` или `ephemeral`. Python также не поддерживается для ресурсов, отличных от моделей (например, тестов и snapshot-ов).

Для инкрементальных моделей, как и в случае SQL-моделей, необходимо фильтровать входные таблицы так, чтобы обрабатывались только новые строки данных:

<WHCode>

<div warehouse="Snowpark">

<File name='models/my_python_model.py'>

```python
import snowflake.snowpark.functions as F

def model(dbt, session):
    dbt.config(materialized = "incremental")
    df = dbt.ref("upstream_table")

    if dbt.is_incremental:

        # только новые строки по сравнению с максимумом в текущей таблице
        max_from_this = f"select max(updated_at) from {dbt.this}"
        df = df.filter(df.updated_at >= session.sql(max_from_this).collect()[0][0])

        # или только строки за последние 3 дня
        df = df.filter(df.updated_at >= F.dateadd("day", F.lit(-3), F.current_timestamp()))

    ...

    return df
```

</File>

</div>

<div warehouse="PySpark">

<File name='models/my_python_model.py'>

```python
import pyspark.sql.functions as F

def model(dbt, session):
    dbt.config(materialized = "incremental")
    df = dbt.ref("upstream_table")

    if dbt.is_incremental:

        # только новые строки по сравнению с максимумом в текущей таблице
        max_from_this = f"select max(updated_at) from {dbt.this}"
        df = df.filter(df.updated_at >= session.sql(max_from_this).collect()[0][0])

        # или только строки за последние 3 дня
        df = df.filter(df.updated_at >= F.date_add(F.current_timestamp(), F.lit(-3)))

    ...

    return df
```

</File>

</div>

</WHCode>

**Примечание:** Инкрементальные модели поддерживаются в BigQuery/Dataproc для стратегии `merge`. Стратегия `insert_overwrite` пока не поддерживается.

<Snippet path="discourse-help-feed-header" />
<DiscourseHelpFeed tags="materialization"/>
