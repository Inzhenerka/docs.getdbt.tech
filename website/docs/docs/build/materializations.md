---
title: "Материализации"
description: "Прочитайте этот учебник, чтобы узнать, как использовать материализации при работе с dbt."
id: "materializations"
pagination_next: "docs/build/incremental-models"
---

## Обзор
<Term id="materialization">Материализации</Term> — это стратегии для сохранения моделей dbt в хранилище данных. В dbt встроено пять типов материализаций. Это:

- <Term id="table" />
- <Term id="view" />
- инкрементальная
- эфемерная
- материализованное представление

Вы также можете настроить [пользовательские материализации](/guides/create-new-materializations?step=1) в dbt. Пользовательские материализации — это мощный способ расширить функциональность dbt в соответствии с вашими конкретными потребностями. 

## Настройка материализаций
По умолчанию модели dbt материализуются как "представления". Модели можно настроить с другой материализацией, указав параметр [`materialized` configuration](/reference/resource-configs/materialized), как показано в следующих вкладках.

<Tabs>

<TabItem value="Project file">

<File name='dbt_project.yml'>

```yaml
# Следующий dbt_project.yml настраивает проект, который выглядит так:
# .
# └── models
#     ├── csvs
#     │   ├── employees.sql
#     │   └── goals.sql
#     └── events
#         ├── stg_event_log.sql
#         └── stg_event_sessions.sql

name: my_project
version: 1.0.0
config-version: 2

models:
  my_project:
    events:
      # материализовать все модели в models/events как таблицы
      +materialized: table
    csvs:
      # это избыточно и не нужно настраивать
      +materialized: view
```

</File>

</TabItem>

<TabItem value="Model file">

Кроме того, материализации можно настраивать непосредственно внутри файлов sql модели. Это может быть полезно, если вы также настраиваете [оптимизацию производительности] для конкретных моделей (например, [конфигурации для Redshift](/reference/resource-configs/redshift-configs) или [конфигурации для BigQuery](/reference/resource-configs/bigquery-configs)).

<File name='models/events/stg_event_log.sql'>

```sql

{{ config(materialized='table', sort='timestamp', dist='user_id') }}

select *
from ...
```

</File>

</TabItem>

<TabItem value="Property file">

Материализации также можно настраивать в файле `properties.yml` модели. Следующий пример показывает тип материализации `table`. Для полного списка типов материализаций обратитесь к [материализациям](/docs/build/materializations#materializations).

<File name='models/properties.yml'>

```yaml
version: 2

models:
  - name: events
    config:
      materialized: table
```

</File>

</TabItem>

</Tabs>

## Материализации

### Представление
При использовании материализации `view` ваша модель пересоздается как представление при каждом запуске с помощью оператора `create view as`.
* **Плюсы:** Не хранится дополнительная информация, представления на основе исходных данных всегда будут содержать последние записи.
* **Минусы:** Представления, которые выполняют значительные преобразования или основаны на других представлениях, медленно запрашиваются.
* **Советы:**
    * Обычно начинайте с представлений для ваших моделей и меняйте на другую материализацию только тогда, когда заметите проблемы с производительностью.
    * Представления лучше всего подходят для моделей, которые не выполняют значительных преобразований, например, переименования или изменения типов столбцов.

### Таблица
При использовании материализации `table` ваша модель пересоздается как <Term id="table" /> при каждом запуске с помощью оператора `create table as`.
* **Плюсы:** Таблицы быстро запрашиваются.
* **Минусы:**
    * Таблицы могут занять много времени для пересоздания, особенно при сложных преобразованиях.
    * Новые записи в исходных данных не добавляются автоматически в таблицу.
* **Советы:**
  * Используйте материализацию таблицы для любых моделей, которые запрашиваются BI-инструментами, чтобы обеспечить более быстрый опыт для конечного пользователя.
  * Также используйте материализацию таблицы для любых медленных преобразований, которые используются многими последующими моделями.

### Инкрементальная
Инкрементальные модели позволяют dbt вставлять или обновлять записи в таблице с момента последнего запуска этой модели.
* **Плюсы:** Вы можете значительно сократить время сборки, преобразовывая только новые записи.
* **Минусы:** Инкрементальные модели требуют дополнительной настройки и являются продвинутым использованием dbt. Узнайте больше о использовании инкрементальных моделей [здесь](/docs/build/incremental-models).
* **Советы:**
    * Инкрементальные модели лучше всего подходят для данных в стиле событий.
    * Используйте инкрементальные модели, когда ваши `dbt run` становятся слишком медленными (т.е. не начинайте с инкрементальных моделей).

### Эфемерная
Эфемерные модели не создаются непосредственно в базе данных. Вместо этого dbt интерполирует код из эфемерной модели в зависимые модели, используя общее выражение таблицы (<Term id="cte" />). Вы можете контролировать идентификатор для этого CTE, используя [псевдоним модели](/docs/build/custom-aliases), но dbt всегда будет добавлять префикс `__dbt__cte__` к идентификатору модели.

* **Плюсы:**
    * Вы все равно можете писать повторно используемую логику.
    * Эфемерные модели могут помочь поддерживать ваш <Term id="data-warehouse" /> в чистоте, уменьшая беспорядок (также рассмотрите возможность разделения ваших моделей по нескольким схемам, используя [пользовательские схемы](/docs/build/custom-schemas)).
* **Минусы:**
    * Вы не можете напрямую выбирать из этой модели.
    * [Операции](/docs/build/hooks-operations#about-operations) (например, макросы, вызываемые с помощью [`dbt run-operation`](/reference/commands/run-operation), не могут `ref()` эфемерные узлы).
    * Чрезмерное использование эфемерной материализации также может усложнить отладку запросов.
    * Эфемерная материализация не поддерживает [контракты моделей](/docs/collaborate/govern/model-contracts#where-are-contracts-supported).
* **Советы:** Используйте эфемерную материализацию для:
    * очень легких преобразований, которые находятся на ранних этапах вашего DAG,
    * которые используются только в одной или двух последующих моделях, и
    * которые не нужно запрашивать напрямую.

### Материализованное представление

Материализация `materialized_view` позволяет создавать и поддерживать материализованные представления в целевой базе данных.
Материализованные представления представляют собой комбинацию представления и таблицы и служат для случаев использования, аналогичных инкрементальным моделям.

* **Плюсы:**
  * Материализованные представления объединяют производительность запросов таблицы с актуальностью данных представления.
  * Материализованные представления работают аналогично инкрементальным материализациям, однако их обычно можно обновлять без ручного вмешательства с регулярной периодичностью (в зависимости от базы данных), избегая регулярного пакетного обновления dbt, необходимого для инкрементальных материализаций.
  * `dbt run` для материализованных представлений соответствует развертыванию кода, как и для представлений.
* **Минусы:**
  * Из-за того, что материализованные представления являются более сложными объектами базы данных, платформы баз данных, как правило, имеют меньше доступных параметров конфигурации; смотрите документацию вашей платформы базы данных для получения дополнительных сведений.
  * Материализованные представления могут не поддерживаться каждой платформой базы данных.
* **Советы:**
  * Рассмотрите возможность использования материализованных представлений для случаев, когда инкрементальные модели достаточны, но вы хотите, чтобы платформа данных управляла инкрементальной логикой и обновлением.

#### Мониторинг изменений конфигурации

Эта материализация использует конфигурацию [`on_configuration_change`](/reference/resource-configs/on_configuration_change), которая соответствует инкрементальному характеру одноименного объекта базы данных. Эта настройка сообщает dbt о том, чтобы пытаться вносить изменения конфигурации непосредственно в объект, когда это возможно, а не полностью пересоздавать объект для реализации обновленной конфигурации. Используя `dbt-postgres` в качестве примера, индексы могут быть удалены и созданы на материализованном представлении без необходимости пересоздавать само материализованное представление.

#### Запланированные обновления

В контексте команды `dbt run` материализованные представления следует рассматривать как аналогичные представлениям.
Например, команда `dbt run` требуется только в том случае, если есть вероятность изменения конфигурации или sql; это фактически действие развертывания.
В отличие от этого, команда `dbt run` требуется для таблицы в тех же сценариях *И когда данные в таблице необходимо обновить*.
Это также верно для инкрементальных и снимковых моделей, у которых подлежащие отношения — это таблицы.
В случае таблиц механизм планирования — это либо dbt Cloud, либо ваш локальный планировщик; нет встроенной функциональности для автоматического обновления данных в таблице.
Тем не менее, большинство платформ (за исключением Postgres) предоставляют функциональность для настройки автоматического обновления материализованного представления.
Таким образом, материализованные представления работают аналогично инкрементальным моделям с преимуществом, что не нужно запускать dbt для обновления данных.
Это предполагает, конечно, что автоматическое обновление включено и настроено в модели.

:::info
`dbt-snowflake` _не поддерживает_ материализованные представления, вместо этого он использует динамические таблицы. Для получения подробной информации смотрите [конфигурации для Snowflake](/reference/resource-configs/snowflake-configs#dynamic-tables).
:::

## Материализации на Python

Модели на Python поддерживают две материализации:
- `table`
- `incremental`

Инкрементальные модели на Python поддерживают все те же [инкрементальные стратегии](/docs/build/incremental-strategy), что и их SQL-аналоги. Конкретные поддерживаемые стратегии зависят от вашего адаптера.

Модели на Python не могут быть материализированы как `view` или `ephemeral`. Python не поддерживается для ресурсов, не относящихся к моделям (таких как тесты и снимки).

Для инкрементальных моделей, как и для SQL-моделей, вам нужно будет фильтровать входные таблицы, чтобы оставить только новые строки данных:

<WHCode>

<div warehouse="Snowpark">

<File name='models/my_python_model.py'>

```python
import snowflake.snowpark.functions as F

def model(dbt, session):
    dbt.config(materialized = "incremental")
    df = dbt.ref("upstream_table")

    if dbt.is_incremental:

        # только новые строки по сравнению с максимальным значением в текущей таблице
        max_from_this = f"select max(updated_at) from {dbt.this}"
        df = df.filter(df.updated_at >= session.sql(max_from_this).collect()[0][0])

        # или только строки за последние 3 дня
        df = df.filter(df.updated_at >= F.dateadd("day", F.lit(-3), F.current_timestamp()))

    ...

    return df
```

</File>

</div>

<div warehouse="PySpark">

<File name='models/my_python_model.py'>

```python
import pyspark.sql.functions as F

def model(dbt, session):
    dbt.config(materialized = "incremental")
    df = dbt.ref("upstream_table")

    if dbt.is_incremental:

        # только новые строки по сравнению с максимальным значением в текущей таблице
        max_from_this = f"select max(updated_at) from {dbt.this}"
        df = df.filter(df.updated_at >= session.sql(max_from_this).collect()[0][0])

        # или только строки за последние 3 дня
        df = df.filter(df.updated_at >= F.date_add(F.current_timestamp(), F.lit(-3)))

    ...

    return df
```

</File>

</div>

</WHCode>

**Примечание:** Инкрементальные модели поддерживаются на BigQuery/Dataproc для стратегии инкремента `merge`. Стратегия `insert_overwrite` пока не поддерживается.

<Snippet path="discourse-help-feed-header" />
<DiscourseHelpFeed tags="materialization"/>