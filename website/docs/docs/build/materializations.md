---
title: "Материализации"
description: "Настройка материализаций в dbt для управления тем, как выполняется SQL и как сохраняются результирующие данные."
id: "materializations"
pagination_next: "docs/build/incremental-models"
---

## Обзор
<Term id="materialization">Материализации</Term> — это стратегии для сохранения моделей dbt в хранилище данных. В dbt встроено пять типов материализаций. Это:

- <Term id="table" />
- <Term id="view" />
- incremental
- ephemeral
- materialized view

Вы также можете настраивать [пользовательские материализации](/guides/create-new-materializations?step=1) в dbt. Пользовательские материализации — это мощный способ расширить функциональность dbt и адаптировать его под ваши конкретные задачи.

import CourseCallout from '/snippets/_materialization-video-callout.md';

<CourseCallout resource="Materializations" 
url="https://learn.getdbt.com/courses/materializations-fundamentals" 
course="Materializations fundamentals" 
/>

## Настройка материализаций
По умолчанию модели dbt материализуются как `"views"`. Для модели можно указать другую материализацию, задав параметр конфигурации [`materialized`](/reference/resource-configs/materialized), как показано на следующих вкладках.

<Tabs>

<TabItem value="Файл проекта">

<File name='dbt_project.yml'>

```yaml
# Следующий dbt_project.yml настраивает проект, который выглядит так:
# .
# └── models
#     ├── csvs
#     │   ├── employees.sql
#     │   └── goals.sql
#     └── events
#         ├── stg_event_log.sql
#         └── stg_event_sessions.sql

name: my_project
version: 1.0.0
config-version: 2

models:
  my_project:
    events:
      # материализовать все модели в models/events как таблицы
      +materialized: table
    csvs:
      # это избыточно и не требует настройки
      +materialized: view
```

</File>

</TabItem>

<TabItem value="Файл модели">

В качестве альтернативы materializations можно настраивать непосредственно внутри SQL‑файлов моделей. Это может быть полезно, если вы также задаёте конфигурации для [Performance Optimization] для отдельных моделей (например, [Redshift specific configurations](/reference/resource-configs/redshift-configs) или [BigQuery specific configurations](/reference/resource-configs/bigquery-configs)).

<File name='models/events/stg_event_log.sql'>

```sql

{{ config(materialized='table', sort='timestamp', dist='user_id') }}

select *
from ...
```

</File>

</TabItem>

<TabItem value="Файл свойств">

Материализации также могут быть настроены в файле `properties.yml` модели. Следующий пример показывает тип материализации `table`. Для полного списка типов материализаций обратитесь к [материализациям](/docs/build/materializations#materializations).

<File name='models/properties.yml'>

```yaml

models:
  - name: events
    config:
      materialized: table
```

</File>

</TabItem>

</Tabs>

## Материализации

### View
При использовании материализации `view` ваша модель пересобирается как представление (view) при каждом запуске с помощью оператора `create view as`.
- **Плюсы:** Дополнительные данные не хранятся, представления поверх исходных данных всегда содержат самые актуальные записи.
- **Минусы:** Представления, которые выполняют значительные преобразования или построены поверх других представлений, медленно выполняются при запросах.
- **Рекомендации:**
    - Обычно стоит начинать с представлений для ваших моделей и переходить на другую материализацию только тогда, когда вы замечаете проблемы с производительностью.
    - Представления лучше всего подходят для моделей, которые не выполняют значительных преобразований, например, только переименование или приведение типов колонок.

### Table
При использовании материализации `table` ваша модель пересобирается как <Term id="table" /> при каждом запуске с помощью оператора `create table as`.
- **Плюсы:** Таблицы быстро выполняются при запросах.
- **Минусы:**
    - Таблицы могут долго пересобираться, особенно при сложных преобразованиях.
    - Новые записи в исходных данных не добавляются в таблицу автоматически.
- **Рекомендации:**
  - Используйте материализацию `table` для моделей, к которым обращаются BI‑инструменты, чтобы обеспечить более быстрый отклик для конечных пользователей.
  - Также используйте материализацию `table` для медленных преобразований, которые используются многими downstream‑моделями.

### Incremental
Модели с материализацией `incremental` позволяют dbt вставлять или обновлять записи в таблице с момента последнего запуска этой модели.
- **Плюсы:** Можно существенно сократить время сборки, преобразуя только новые записи.
- **Минусы:** Инкрементальные модели требуют дополнительной конфигурации и являются более продвинутым вариантом использования dbt. Подробнее об использовании инкрементальных моделей читайте [здесь](/docs/build/incremental-models).
- **Рекомендации:**
    - Инкрементальные модели лучше всего подходят для данных событийного типа.
    - Используйте инкрементальные модели, когда ваши `dbt run` начинают выполняться слишком медленно (то есть не начинайте сразу с инкрементальных моделей).

### Ephemeral
`ephemeral` модели не строятся напрямую в базе данных. Вместо этого dbt будет интерполировать код из эфемерной модели в ее зависимые модели, используя общее табличное выражение (<Term id="cte" />). Вы можете управлять идентификатором для этого CTE, используя [псевдоним модели](/docs/build/custom-aliases), но dbt всегда будет добавлять префикс к идентификатору модели `__dbt__cte__`.

- **Плюсы:**
  - Вы по‑прежнему можете писать переиспользуемую логику.
  - Эфемерные модели помогают поддерживать ваш <Term id="data-warehouse" /> в чистоте, уменьшая «захламление» (также рассмотрите вариант разделения моделей по нескольким схемам с помощью [пользовательских схем](/docs/build/custom-schemas)).

- **Минусы:**
  - Вы не можете выполнять `select` напрямую из этой модели.
  - [Operations](/docs/build/hooks-operations#about-operations) (например, макросы, вызываемые через [`dbt run-operation`](/reference/commands/run-operation)) не могут делать `ref()` на эфемерные узлы.
  - Чрезмерное использование эфемерной материализации может усложнить отладку запросов.
  - Эфемерная материализация не поддерживает [контракты моделей](/docs/mesh/govern/model-contracts#where-are-contracts-supported).

- **Рекомендации:** используйте эфемерную материализацию для:
  - Очень лёгких преобразований, находящихся на ранних этапах вашего DAG,
  - Которые используются только в одной или двух downstream‑моделях,
  - И не требуют прямого выполнения запросов.

### Materialized View

Материализация `materialized_view` позволяет создавать и поддерживать материализованные представления в целевой базе данных.
Материализованные представления представляют собой комбинацию представления и таблицы и служат для случаев использования, аналогичных инкрементальным моделям.

- **Плюсы:**
  - Материализованные представления сочетают производительность запросов, характерную для таблиц, с актуальностью данных, как у представлений
  - Материализованные представления работают во многом похоже на инкрементальные материализации, однако обычно могут обновляться автоматически по регулярному расписанию (в зависимости от базы данных), без ручного вмешательства, что избавляет от необходимости выполнять регулярный batch-обновления через dbt, как это требуется для инкрементальных материализаций
  - `dbt run` для материализованных представлений соответствует деплою кода, так же как и для обычных представлений
- **Минусы:**
  - Поскольку материализованные представления являются более сложными объектами базы данных, платформы БД, как правило, предоставляют для них меньше доступных опций конфигурации; подробнее см. документацию вашей платформы базы данных
  - Материализованные представления поддерживаются не всеми платформами баз данных
- **Рекомендации:**
  - Рассмотрите использование материализованных представлений в тех случаях, когда инкрементальные модели подходят по функциональности, но вы хотите, чтобы платформа данных сама управляла инкрементальной логикой и обновлением данных.

#### Мониторинг изменения конфигурации

Эта материализация использует конфигурацию [`on_configuration_change`](/reference/resource-configs/on_configuration_change), которая соответствует инкрементальной природе одноименного объекта базы данных. Эта настройка указывает dbt попытаться внести изменения конфигурации непосредственно в объект, когда это возможно, вместо полного пересоздания объекта для реализации обновленной конфигурации. Используя `dbt-postgres` в качестве примера, индексы могут быть удалены и созданы на материализованном представлении без необходимости пересоздания самого материализованного представления.

#### Запланированные обновления

В контексте команды `dbt run` материализованные представления следует рассматривать как аналог обычных представлений.

Например, команда `dbt run` требуется только в том случае, если есть потенциальные изменения в конфигурации или SQL;
по сути, это операция деплоя.
В отличие от этого, для таблицы команда `dbt run` необходима в тех же сценариях *и дополнительно тогда, когда требуется обновить данные в таблице*.
Это также справедливо для incremental- и snapshot-моделей, поскольку их базовые отношения являются таблицами.

В случае таблиц механизм планирования — это либо <Constant name="cloud" />, либо ваш локальный планировщик;
в dbt нет встроенной функциональности для автоматического обновления данных, лежащих в основе таблицы.
Однако большинство платформ (за исключением Postgres) предоставляют возможность настраивать автоматическое обновление материализованных представлений.
Следовательно, материализованные представления работают аналогично incremental-моделям, но с тем преимуществом, что для обновления данных не требуется запускать dbt.
Разумеется, при условии, что автоматическое обновление включено и настроено в модели.

:::info
`dbt-snowflake` _не поддерживает_ материализованные представления, вместо этого он использует динамические таблицы. Для получения подробной информации обратитесь к [конфигурациям для Snowflake](/reference/resource-configs/snowflake-configs#dynamic-tables).
:::

## Материализации Python

Модели Python поддерживают две материализации:
- `table`
- `incremental`

Инкрементальные модели Python поддерживают все те же [инкрементальные стратегии](/docs/build/incremental-strategy), что и их SQL-аналоги. Конкретные поддерживаемые стратегии зависят от вашего адаптера.

Модели Python не могут быть материализованы как `view` или `ephemeral`. Python не поддерживается для типов ресурсов, отличных от моделей (например, тестов и снимков).

Для инкрементальных моделей, как и для SQL-моделей, вам нужно будет фильтровать входящие таблицы только на новые строки данных:

<WHCode>

<div warehouse="Snowpark">

<File name='models/my_python_model.py'>

```python
import snowflake.snowpark.functions as F

def model(dbt, session):
    dbt.config(materialized = "incremental")
    df = dbt.ref("upstream_table")

    if dbt.is_incremental:

        # только новые строки по сравнению с максимумом в текущей таблице
        max_from_this = f"select max(updated_at) from {dbt.this}"
        df = df.filter(df.updated_at >= session.sql(max_from_this).collect()[0][0])

        # или только строки за последние 3 дня
        df = df.filter(df.updated_at >= F.dateadd("day", F.lit(-3), F.current_timestamp()))

    ...

    return df
```

</File>

</div>

<div warehouse="PySpark">

<File name='models/my_python_model.py'>

```python
import pyspark.sql.functions as F

def model(dbt, session):
    dbt.config(materialized = "incremental")
    df = dbt.ref("upstream_table")

    if dbt.is_incremental:

        # только новые строки по сравнению с максимумом в текущей таблице
        max_from_this = f"select max(updated_at) from {dbt.this}"
        df = df.filter(df.updated_at >= session.sql(max_from_this).collect()[0][0])

        # или только строки за последние 3 дня
        df = df.filter(df.updated_at >= F.date_add(F.current_timestamp(), F.lit(-3)))

    ...

    return df
```

</File>

</div>

</WHCode>

**Примечание:** Инкрементальные модели поддерживаются на BigQuery/Dataproc для инкрементальной стратегии `merge`. Стратегия `insert_overwrite` пока не поддерживается.

<Snippet path="discourse-help-feed-header" />
<DiscourseHelpFeed tags="materialization"/>