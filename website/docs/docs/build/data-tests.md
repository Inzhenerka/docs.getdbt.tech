---
title: "Добавление тестов данных в ваш DAG"
sidebar_label: "Тесты данных"
description: "Прочитайте этот учебник, чтобы узнать, как использовать тесты данных при разработке в dbt."
pagination_next: "docs/build/unit-tests"
pagination_prev: null
search_weight: "heavy"
id: "data-tests"
keywords:
  - тест, тесты, тестирование, dag
---

import CopilotBeta from '/snippets/_dbt-copilot-avail.md';

<CopilotBeta resource='data tests' />

## Связанные справочные документы
* [Команда тестирования](/reference/commands/test)
* [Свойства тестов данных](/reference/resource-properties/data-tests)
* [Конфигурации тестов данных](/reference/data-test-configs)
* [Примеры выбора тестов](/reference/node-selection/test-selection-examples)

<VersionBlock firstVersion="1.8">

:::important

Начиная с версии dbt v1.8, "тесты" теперь называются "тестами данных", чтобы избежать путаницы с [модульными тестами](/docs/build/unit-tests). Ключ YAML `tests:` по-прежнему поддерживается как псевдоним для `data_tests:`. Обратитесь к [Новой синтаксису `data_tests:`](#new-data_tests-syntax) для получения дополнительной информации.

:::

</VersionBlock>

## Обзор

Тесты данных — это утверждения, которые вы делаете о своих моделях и других ресурсах в вашем проекте dbt (например, источниках, семенах и снимках). Когда вы запускаете `dbt test`, dbt сообщит вам, проходит ли каждый тест в вашем проекте или нет.

Вы можете использовать тесты данных для повышения целостности SQL в каждой модели, делая утверждения о сгенерированных результатах. По умолчанию вы можете проверить, содержит ли указанная колонка в модели только ненулевые значения, уникальные значения или значения, которые имеют соответствующее значение в другой модели (например, `customer_id` для `order` соответствует `id` в модели `customers`), а также значения из указанного списка. Вы можете расширить тесты данных, чтобы они соответствовали бизнес-логике, специфичной для вашей организации — любое утверждение, которое вы можете сделать о своей модели в виде запроса select, может быть преобразовано в тест данных.

Тесты данных возвращают набор неудачных записей. Общие тесты данных (ранее известные как схемные тесты) определяются с помощью блоков `test`.

Как и почти все в dbt, тесты данных — это SQL-запросы. В частности, это операторы `select`, которые пытаются получить "неудачные" записи, те, которые опровергают ваше утверждение. Если вы утверждаете, что колонка уникальна в модели, тестовый запрос выбирает дубликаты; если вы утверждаете, что колонка никогда не должна быть нулевой, тест ищет нулевые значения. Если тест данных возвращает ноль неудачных строк, он проходит, и ваше утверждение было подтверждено.

Существует два способа определения тестов данных в dbt:
* **Единственный** тест данных — это тест в его самой простой форме: если вы можете написать SQL-запрос, который возвращает неудачные строки, вы можете сохранить этот запрос в файле `.sql` в вашем [каталоге тестов](/reference/project-configs/test-paths). Теперь это тест данных, и он будет выполнен командой `dbt test`.
* **Общий** тест данных — это параметризованный запрос, который принимает аргументы. Тестовый запрос определяется в специальном блоке `test` (как [макрос](jinja-macros)). После определения вы можете ссылаться на общий тест по имени в ваших `.yml` файлах — определять его для моделей, колонок, источников, снимков и семян. dbt поставляется с четырьмя встроенными общими тестами данных, и мы считаем, что вы должны их использовать!

Определение тестов данных — отличный способ подтвердить, что ваши выходные и входные данные соответствуют ожиданиям, и помогает предотвратить регрессии, когда ваш код изменяется. Поскольку вы можете использовать их снова и снова, делая аналогичные утверждения с незначительными изменениями, общие тесты данных, как правило, гораздо более распространены — они должны составлять основную часть вашего набора тестов данных dbt. Тем не менее, оба способа определения тестов данных имеют свое время и место.

:::tip Создание ваших первых тестов данных
Если вы новичок в dbt, мы рекомендуем вам ознакомиться с нашим [руководством по быстрому старту](/guides), чтобы создать свой первый проект dbt с моделями и тестами.
:::

## Единственные тесты данных

Самый простой способ определить тест данных — это написать точный SQL, который вернет неудачные записи. Мы называем эти тесты "единственными", потому что это разовые утверждения, используемые для одной цели.

Эти тесты определяются в файлах `.sql`, обычно в вашем каталоге `tests` (как определено в вашей конфигурации [`test-paths`](/reference/project-configs/test-paths)). Вы можете использовать Jinja (включая `ref` и `source`) в определении теста, так же как и при создании моделей. Каждый файл `.sql` содержит одно выражение `select` и определяет один тест данных:

<File name='tests/assert_total_payment_amount_is_positive.sql'>

```sql
-- Возвраты имеют отрицательную сумму, поэтому общая сумма всегда должна быть >= 0.
-- Поэтому верните записи, где total_amount < 0, чтобы тест не прошел.
select
    order_id,
    sum(amount) as total_amount
from {{ ref('fct_payments') }}
group by 1
having total_amount < 0
```

</File>

Имя этого теста — это имя файла: `assert_total_payment_amount_is_positive`. 

Обратите внимание, что вам не нужно включать точки с запятой (;) в конце SQL-запроса в ваших файлах единственных тестов, так как это может привести к сбою теста.

Чтобы добавить описание к единственному тесту в вашем проекте, добавьте файл `.yml` в ваш каталог `tests`, например, `tests/schema.yml` с следующим содержимым:

<File name='tests/schema.yml'>

```yaml
version: 2
data_tests:
  - name: assert_total_payment_amount_is_positive
    description: >
      Возвраты имеют отрицательную сумму, поэтому общая сумма всегда должна быть >= 0.
      Поэтому верните записи, где общая сумма < 0, чтобы тест не прошел.

```

</File>

Единственные тесты данных так просты, что вы можете обнаружить, что пишете одну и ту же базовую структуру многократно, меняя только имя колонки или модели. В этом случае тест уже не так единственен! В таком случае мы рекомендуем использовать общие тесты данных.

## Общие тесты данных
Некоторые тесты данных являются общими: их можно использовать снова и снова. Общий тест данных определяется в блоке `test`, который содержит параметризованный запрос и принимает аргументы. Он может выглядеть так:

```sql
{% test not_null(model, column_name) %}

    select *
    from {{ model }}
    where {{ column_name }} is null

{% endtest %}
```

Вы заметите, что есть два аргумента, `model` и `column_name`, которые затем подставляются в запрос. Это и делает тест "общим": его можно определить для любого количества колонок, в любом количестве моделей, и dbt передаст значения `model` и `column_name` соответственно. После того как этот общий тест был определен, его можно добавить как _свойство_ к любой существующей модели (или источнику, семени или снимку). Эти свойства добавляются в `.yml` файлы в том же каталоге, что и ваш ресурс.

:::info
Если вы впервые работаете с добавлением свойств к ресурсу, ознакомьтесь с документацией о [объявлении свойств](/reference/configs-and-properties).
:::

По умолчанию dbt поставляется с четырьмя уже определенными общими тестами данных: `unique`, `not_null`, `accepted_values` и `relationships`. Вот полный пример использования этих тестов на модели `orders`:

```yml
version: 2

models:
  - name: orders
    columns:
      - name: order_id
        tests:
          - unique
          - not_null
      - name: status
        tests:
          - accepted_values:
              values: ['placed', 'shipped', 'completed', 'returned']
      - name: customer_id
        tests:
          - relationships:
              to: ref('customers')
              field: id
```

На простом языке эти тесты данных переводятся как:
* `unique`: колонка `order_id` в модели `orders` должна быть уникальной
* `not_null`: колонка `order_id` в модели `orders` не должна содержать нулевых значений
* `accepted_values`: колонка `status` в модели `orders` должна быть одной из `'placed'`, `'shipped'`, `'completed'` или `'returned'`
* `relationships`: каждый `customer_id` в модели `orders` существует как `id` в таблице `customers` (также известной как ссылочная целостность)

За кулисами dbt строит запрос `select` для каждого теста данных, используя параметризованный запрос из блока общего теста. Эти запросы возвращают строки, где ваше утверждение _не_ верно; если тест возвращает ноль строк, ваше утверждение проходит.

Вы можете найти больше информации о этих тестах данных и дополнительных конфигурациях (включая [`severity`](/reference/resource-configs/severity) и [`tags`](/reference/resource-configs/tags)) в [разделе справки](/reference/resource-properties/data-tests).

### Больше общих тестов данных

Эти четыре теста достаточно, чтобы начать. Вы быстро обнаружите, что хотите использовать более широкий спектр тестов — это хорошо! Вы также можете установить общие тесты данных из пакета или написать свои собственные, чтобы использовать (и повторно использовать) в вашем проекте dbt. Ознакомьтесь с [руководством по созданию пользовательских общих тестов](/best-practices/writing-custom-generic-tests) для получения дополнительной информации.

:::info
Существуют общие тесты, определенные в некоторых открытых пакетах, таких как [dbt-utils](https://hub.getdbt.com/dbt-labs/dbt_utils/latest/) и [dbt-expectations](https://hub.getdbt.com/calogica/dbt_expectations/latest/) — переходите к документации о [пакетах](/docs/build/packages), чтобы узнать больше!
:::

### Пример
Чтобы добавить общий (или "схемный") тест в ваш проект:

1. Добавьте файл `.yml` в ваш каталог `models`, например, `models/schema.yml`, с следующим содержимым (возможно, вам нужно будет скорректировать значения `name:` для существующей модели)

<File name='models/schema.yml'>

```yaml
version: 2

models:
  - name: orders
    columns:
      - name: order_id
        tests:
          - unique
          - not_null

```

</File>

2. Запустите команду [`dbt test`](/reference/commands/test):

```
$ dbt test

Found 3 models, 2 tests, 0 snapshots, 0 analyses, 130 macros, 0 operations, 0 seed files, 0 sources

17:31:05 | Concurrency: 1 threads (target='learn')
17:31:05 |
17:31:05 | 1 of 2 START test not_null_order_order_id..................... [RUN]
17:31:06 | 1 of 2 PASS not_null_order_order_id........................... [PASS in 0.99s]
17:31:06 | 2 of 2 START test unique_order_order_id....................... [RUN]
17:31:07 | 2 of 2 PASS unique_order_order_id............................. [PASS in 0.79s]
17:31:07 |
17:31:07 | Finished running 2 tests in 7.17s.

Completed successfully

Done. PASS=2 WARN=0 ERROR=0 SKIP=0 TOTAL=2

```
3. Проверьте SQL, который выполняет dbt, либо:
   * **dbt Cloud:** проверяя вкладку Details.
   * **dbt Core:** проверяя каталог `target/compiled`


**Тест уникальности**
<Tabs
  defaultValue="compiled"
  values={[
    {label: 'Скомпилированный SQL', value: 'compiled'},
    {label: 'Шаблонный SQL', value: 'templated'},
  ]}>
  <TabItem value="compiled">

```sql
select *
from (

    select
        order_id

    from analytics.orders
    where order_id is not null
    group by order_id
    having count(*) > 1

) validation_errors
```

  </TabItem>
  <TabItem value="templated">

```sql
select *
from (

    select
        {{ column_name }}

    from {{ model }}
    where {{ column_name }} is not null
    group by {{ column_name }}
    having count(*) > 1

) validation_errors
```

  </TabItem>
</Tabs>

**Тест на ненулевое значение**

<Tabs
  defaultValue="compiled"
  values={[
    {label: 'Скомпилированный SQL', value: 'compiled'},
    {label: 'Шаблонный SQL', value: 'templated'},
  ]}>
  <TabItem value="compiled">

```sql
select *
from analytics.orders
where order_id is null
```

  </TabItem>
  <TabItem value="templated">

```sql
select *
from {{ model }}
where {{ column_name }} is null
```

  </TabItem>
</Tabs>

## Хранение неудач тестов

Обычно запрос теста данных будет вычислять неудачи в процессе его выполнения. Если вы установите необязательный флаг `--store-failures`, [`store_failures`](/reference/resource-configs/store_failures) или конфигурации [`store_failures_as`](/reference/resource-configs/store_failures_as), dbt сначала сохранит результаты запроса теста в таблице в базе данных, а затем выполнит запрос к этой таблице, чтобы вычислить количество неудач.

Этот рабочий процесс позволяет вам быстрее запрашивать и проверять неудачные записи в процессе разработки:

<Lightbox src="/img/docs/building-a-dbt-project/test-store-failures.gif" title="Сохраните неудачи тестов в базе данных для более быстрого отладки во время разработки."/>

Обратите внимание, что если вы выберете хранение неудач тестов:
* Таблицы результатов тестов создаются в схеме с суффиксом или названием `dbt_test__audit` по умолчанию. Это значение можно изменить, установив конфигурацию `schema`. (Для получения дополнительной информации о наименовании схемы см. [использование пользовательских схем](/docs/build/custom-schemas).)
- Результаты теста всегда **заменяют** предыдущие неудачи для того же теста.



## Новый синтаксис `data_tests:`

<VersionBlock lastVersion="1.7">

В версии dbt 1.8 мы обновили конфигурацию `tests` на `data_tests`. Для получения подробной информации выберите версию v1.8 в меню навигации документации.

</VersionBlock>

<VersionBlock firstVersion="1.8">
  
Тесты данных исторически назывались "тестами" в dbt как единственная форма тестирования, доступная. С введением модульных тестов в v1.8 ключ был переименован с `tests:` на `data_tests:`. 

dbt по-прежнему поддерживает `tests:` в ваших YML конфигурационных файлах для целей обратной совместимости, и вы можете увидеть его использование в нашей документации. Однако вы не можете иметь ключ `tests` и ключ `data_tests`, связанные с одним и тем же ресурсом (например, одной моделью) одновременно.

<File name='models/schema.yml'>

```yml
models:
  - name: orders
    columns:
      - name: order_id
        data_tests:
          - unique
          - not_null
```

</File>

<File name='dbt_project.yml'>

```yml
data_tests:
  +store_failures: true
```

</File>


</VersionBlock>

## Часто задаваемые вопросы

<FAQ path="Tests/available-tests" />
<FAQ path="Tests/test-one-model" />
<FAQ path="Runs/failed-tests" />
<FAQ path="Tests/recommended-tests" />
<FAQ path="Tests/when-to-test" />
<FAQ path="Tests/configurable-data-test-path" />
<FAQ path="Tests/testing-sources" />
<FAQ path="Tests/custom-test-thresholds" />
<FAQ path="Tests/uniqueness-two-columns" />
