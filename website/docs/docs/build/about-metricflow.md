---
title: "О MetricFlow"
id: about-metricflow
description: "Узнайте больше о MetricFlow и его ключевых концепциях"
sidebar_label: О MetricFlow
tags: [Метрики, Семантический уровень]
pagination_next: "docs/build/join-logic"
pagination_prev: null
---

Этот гид вводит в основные идеи MetricFlow для людей, которые впервые знакомятся с этой функцией. MetricFlow, который поддерживает семантический уровень dbt, помогает вам определять и управлять логикой метрик вашей компании. Это набор абстракций с определенной точкой зрения, который помогает потребителям данных быстро и эффективно извлекать наборы данных метрик из платформы данных.

MetricFlow обрабатывает построение SQL-запросов и определяет спецификацию для семантических моделей и метрик dbt. Он позволяет вам определять метрики в вашем проекте dbt и запрашивать их с помощью [команд MetricFlow](/docs/build/metricflow-commands) как в dbt Cloud, так и в dbt Core.

Перед тем как начать, рассмотрите следующие рекомендации:

- Определяйте метрики в YAML и запрашивайте их, используя эти [новые спецификации метрик](https://github.com/dbt-labs/dbt-core/discussions/7456).
- Вы должны использовать [версию dbt](/docs/dbt-versions/upgrade-dbt-version-in-cloud) 1.6 или выше, чтобы использовать MetricFlow.
- Используйте MetricFlow с Snowflake, BigQuery, Databricks, Postgres (только dbt Core) или Redshift.
- Открывайте новые инсайты и запрашивайте ваши метрики, используя [семантический уровень dbt](/docs/use-dbt-semantic-layer/dbt-sl) и его разнообразные [доступные интеграции](/docs/cloud-integrations/avail-sl-integrations).

## MetricFlow

MetricFlow — это инструмент генерации SQL-запросов, предназначенный для упрощения создания метрик по различным измерениям данных для различных бизнес-потребностей.
- Он работает через YAML-файлы, где семантический граф связывает язык с данными. Этот граф состоит из [семантических моделей](/docs/build/semantic-models) (точки входа в данные) и [метрик](/docs/build/metrics-overview) (функции для создания количественных показателей).
- MetricFlow является [пакетом BSL](https://github.com/dbt-labs/metricflow) с доступным исходным кодом и совместим с версиями dbt 1.6 и выше. Практики и энтузиасты данных настоятельно призываются к сотрудничеству.
- В рамках семантического уровня dbt MetricFlow позволяет организациям определять метрики, используя абстракции YAML.
- Для запроса измерений метрик, значений измерений и проверки конфигураций используйте [команды MetricFlow](/docs/build/metricflow-commands).

**Примечание** &mdash; На данный момент MetricFlow не поддерживает [встроенные функции или пакеты dbt](/reference/dbt-jinja-functions/builtins), однако поддержка планируется в будущем.

MetricFlow руководствуется следующими принципами:

- **Гибкость с полнотой**: Определяйте логику метрик, используя гибкие абстракции на любой модели данных.
- **DRY (Не повторяйте себя)**: Минимизируйте избыточность, позволяя определять метрики, когда это возможно.
- **Простота с постепенной сложностью:** Подходите к MetricFlow, используя знакомые концепции моделирования данных.
- **Производительность и эффективность**: Оптимизируйте производительность, поддерживая централизованную инженерии данных и распределенную ответственность за логику.

### Семантический граф

Мы вводим новую концепцию: "семантический граф". Это взаимосвязь между семантическими моделями и конфигурациями YAML, которая создает ландшафт данных для построения метрик. Вы можете представить его как карту, где таблицы — это места, а связи между ними (ребра) — это дороги. Хотя это происходит за кулисами, семантический граф является подмножеством <Term id="dag" />, и вы можете рассматривать семантические модели как узлы на DAG.

Семантический граф помогает нам определить, какая информация доступна для использования, а какая — нет. Связи между таблицами в семантическом графе больше касаются отношений между информацией. Это отличается от DAG, где связи показывают зависимости между задачами.

Когда MetricFlow генерирует метрику, он использует свой SQL-движок, чтобы определить лучший путь между таблицами, используя структуру, определенную в YAML-файлах для семантических моделей и метрик. Когда эти модели и метрики правильно определены, их можно использовать в дальнейшем с интеграциями семантического уровня dbt.

### Семантические модели

Семантические модели являются отправными точками данных и соответствуют моделям в вашем проекте dbt. Вы можете создать несколько семантических моделей из каждой модели. Семантические модели имеют метаданные, такие как таблица данных, которые определяют важную информацию, такую как имя таблицы и первичные ключи, чтобы граф мог быть правильно навигирован.

Для семантической модели есть три основных элемента метаданных:

* [Сущности](/docs/build/entities) &mdash; Ключи соединения вашей семантической модели (подумайте об этих как о путях перемещения или ребрах между семантическими моделями).
* [Измерения](/docs/build/dimensions) &mdash; Это способы, которыми вы хотите группировать или разбивать ваши метрики.
* [Меры](/docs/build/measures) &mdash; Функции агрегации, которые дают вам числовой результат и могут быть использованы для создания ваших метрик.

<Lightbox src="/img/docs/dbt-cloud/semantic-layer/semantic_foundation.jpg" width="70%" title="Семантическая модель состоит из различных компонентов: Сущности, Меры и Измерения."/>

### Метрики

Метрики, которые являются ключевой концепцией, представляют собой функции, которые комбинируют меры, ограничения или другие математические функции для определения новых количественных показателей. MetricFlow использует меры и различные типы агрегации, такие как среднее, сумма и количество уникальных значений, для создания метрик. Измерения добавляют контекст к метрикам, и без них метрика просто является числом на все времена. Вы можете определять метрики в тех же YAML-файлах, что и ваши семантические модели, или создать новый файл.

MetricFlow поддерживает различные типы метрик:

- [Конверсия](/docs/build/conversion) &mdash; Помогает отслеживать, когда базовое событие и последующее событие конверсии происходят для сущности в заданный период времени.
- [Кумулятивная](/docs/build/cumulative) &mdash; Агрегирует меру за заданный период.
- [Производная](/docs/build/derived) &mdash; Выражение других метрик, которое позволяет вам выполнять вычисления на основе метрик.
- [Соотношение](/docs/build/ratio) &mdash; Создает соотношение из двух мер, например, доход на клиента.
- [Простая](/docs/build/simple) &mdash; Метрики, которые напрямую ссылаются на одну меру.

## Случай использования

В следующих разделах мы покажем, как практики данных в настоящее время рассчитывают метрики и сравним это с тем, как MetricFlow упрощает и делает более гибким процесс определения метрик.

Следующие примеры данных основаны на репозитории Jaffle Shop. Вы можете просмотреть полный [проект dbt](https://github.com/dbt-labs/jaffle-sl-template). Таблицы, которые мы используем в нашем примере модели:

- `orders` — это экспорт данных производственной платформы, который был очищен и организован для аналитического использования.
- `customers` — это частично денормализованная таблица, в данном случае с колонкой, полученной из таблицы заказов через некоторый процесс на предыдущем этапе.

<!-- ![MetricFlow-SchemaExample](/img/docs/building-a-dbt-project/MetricFlow-SchemaExample.jpeg) -->

Чтобы сделать это более конкретным, рассмотрим метрику `order_total`, которая определяется с помощью SQL-выражения:

`select sum(order_total) as order_total from orders` 
Это выражение вычисляет общий доход от всех заказов, суммируя колонку order_total в таблице заказов. В бизнесе метрика order_total часто рассчитывается в соответствии с различными категориями, такими как:
- Время, например `date_trunc(ordered_at, 'day')`
- Тип заказа, используя измерение `is_food_order` из таблицы `orders`.

### Расчет метрик

Далее мы сравним, как практики данных в настоящее время рассчитывают метрики с помощью нескольких запросов, и как MetricFlow упрощает и оптимизирует этот процесс.

<Tabs>
<TabItem value="mulqueries" label="Расчет с помощью нескольких запросов">

Следующий пример показывает, как практики данных обычно рассчитывают агрегированную метрику `order_total`. Также вероятно, что аналитики запрашивают больше деталей по метрике, например, сколько дохода поступило от новых клиентов.

Использование следующего запроса создает ситуацию, когда несколько аналитиков работают с одними и теми же данными, каждый используя свой собственный метод запроса &mdash; это может привести к путанице, несоответствиям и головной боли для управления данными.

```sql
select
    date_trunc('day',orders.ordered_at) as day, 
    case when customers.first_ordered_at is not null then true else false end as is_new_customer,
    sum(orders.order_total) as order_total
from
  orders
left join
  customers
on
  orders.customer_id = customers.customer_id
group by 1, 2
```

</TabItem>
<TabItem value="metricflow" label="Расчет с помощью MetricFlow">

В следующих трех примерах мы используем MetricFlow для определения семантической модели, которая использует order_total в качестве метрики и образец схемы для создания последовательных и точных результатов &mdash; устраняя путаницу, дублирование кода и оптимизируя ваш рабочий процесс.

<Tabs>
<TabItem value="example1" label="Пример дохода">

В этом примере мера с именем `order_total` определяется на основе колонки order_total в таблице `orders`. 

Измерение времени `metric_time` предоставляет ежедневную детализацию и может быть агрегировано в недельные или месячные периоды. Кроме того, в семантической модели `customers` указано категориальное измерение с именем `is_new_customer`.


```yaml
semantic_models:
  - name: orders    # Имя семантической модели
    description: |
      Модель, содержащая данные о заказах. Гранулярность таблицы — идентификатор заказа.
    model: ref('orders') #Имя модели dbt и схемы
    defaults:
      agg_time_dimension: metric_time
    entities: # Сущности, которые обычно соответствуют ключам в таблице. 
      - name: order_id
        type: primary
      - name: customer
        type: foreign
        expr: customer_id
    measures:   # Меры, которые являются агрегациями по колонкам в таблице.
      - name: order_total
        agg: sum
    dimensions: # Измерения могут быть категориальными или временными. Они добавляют дополнительный контекст к метрикам, и типичный шаблон запроса — Метрика по Измерению.
      - name: metric_time
        expr: cast(ordered_at as date)
        type: time
        type_params:
          time_granularity: day
  - name: customers    # Имя второй семантической модели
    description: >
      Таблица измерений клиентов. Гранулярность таблицы — одна строка на
        клиента.
    model: ref('customers') #Имя модели dbt и схемы
    defaults:
      agg_time_dimension: first_ordered_at
    entities: # Сущности, которые обычно соответствуют ключам в таблице.
      - name: customer 
        type: primary
        expr: customer_id
    dimensions: # Измерения могут быть категориальными или временными. Они добавляют дополнительный контекст к метрикам, и типичный шаблон запроса — Метрика по Измерению.
      - name: is_new_customer
        type: categorical
        expr: case when first_ordered_at is not null then true else false end
      - name: first_ordered_at
        type: time
        type_params:
          time_granularity: day

  ```

</TabItem>
<TabItem value="example2" label="Пример с дополнительными измерениями">

Аналогично, вы можете добавить дополнительные измерения, такие как `is_food_order`, в ваши семантические модели, чтобы включить еще больше измерений для разбивки и анализа вашего дохода от order_total. 

```yaml
semantic_models:
  - name: orders
    description: |
      Модель, содержащая данные о заказах. Гранулярность таблицы — идентификатор заказа.
    model: ref('orders')  #Имя модели dbt и схемы
    defaults:
      agg_time_dimension: metric_time
    entities: # Сущности, которые обычно соответствуют ключам в таблице
      - name: order_id
        type: primary
      - name: customer
        type: foreign
        expr: customer_id
    measures: # Меры, которые являются агрегациями по колонкам в таблице.
      - name: order_total
        agg: sum
    dimensions: # Измерения могут быть категориальными или временными. Они добавляют дополнительный контекст к метрикам, и типичный шаблон запроса — Метрика по Измерению.
      - name: metric_time
        expr: cast(ordered_at as date)
        type: time
        type_params:
          time_granularity: day
      - name: is_food_order
        type: categorical
```
</TabItem>
<TabItem value="example3" label="Расширенный пример">

Представьте, что требуется еще более сложная метрика, например, сумма денег, заработанная каждый день от заказов еды от постоянных клиентов. Без MetricFlow оригинальный SQL практикующего данных может выглядеть так:

```sql
select
    date_trunc('day',orders.ordered_at) as day, 
    sum(case when is_food_order = true then order_total else null end) as food_order,
    sum(orders.order_total) as sum_order_total,
    food_order/sum_order_total
from
  orders
left join
  customers
on
  orders.customer_id = customers.customer_id
where
  case when customers.first_ordered_at is not null then true else false end = true
group by 1
```

MetricFlow упрощает процесс SQL через конфигурации метрик YAML, как показано ниже. Вы также можете зафиксировать их в вашем репозитории git, чтобы гарантировать, что все члены команд данных и бизнеса могут видеть и утверждать их как единственный и истинный источник информации.

```yaml
metrics:
  - name: food_order_pct_of_order_total_returning
    description: Доход от заказов еды от постоянных клиентов
    label: "Процент еды от общего дохода"
    type: ratio
    type_params:
      numerator: food_order
      denominator: order_total
    filter: |
      {{ Dimension('customer__is_new_customer') }} = false
```
</TabItem>
</Tabs>

</TabItem>
</Tabs>

## Часто задаваемые вопросы

<DetailsToggle alt_header="Нужно ли нормализовать мои наборы данных?">

Совсем нет! Хотя очищенный и хорошо смоделированный набор данных может быть чрезвычайно мощным и является идеальным входом, вы можете использовать любой набор данных, от сырого до полностью денормализованного.

Рекомендуется применять качество согласованности данных, например, фильтрацию плохих данных, нормализацию общих объектов и моделирование данных ключей и таблиц, в приложениях на предыдущем этапе. Семантический уровень более эффективен в выполнении денормализации данных, чем нормализации.

Если вы не инвестировали в согласованность данных, это нормально. Семантический уровень может принимать SQL-запросы или выражения для определения согласованных наборов данных.

</DetailsToggle>

<DetailsToggle alt_header="Почему нормализованные данные являются идеальным входом?">

MetricFlow создан для эффективной денормализации. Существуют лучшие инструменты для обработки сырых наборов данных и выполнения различных задач, необходимых для создания согласованности данных и организованных моделей данных. С другой стороны, вводя денормализованные данные, вы потенциально создаете избыточность, что технически сложно управлять, и снижаете потенциальную гранулярность, которую MetricFlow может использовать для агрегации метрик.
</DetailsToggle>

<DetailsToggle alt_header="Почему бы не сделать метрики такими же, как меры?">
Одним из принципов MetricFlow является сокращение дублирования логики, иногда называемого Не повторяйте себя (DRY).

Многие метрики строятся на основе повторно используемых мер, а в некоторых случаях — на основе мер из разных семантических моделей. Это позволяет строить метрики в ширину (метрики, которые могут существовать самостоятельно), а не в глубину (где у вас есть несколько метрик, действующих как функции друг друга).

Кроме того, не все метрики строятся на основе мер. Например, метрика конверсии, вероятно, определяется как наличие или отсутствие записи события после некоторой другой записи события.

</DetailsToggle>
<DetailsToggle alt_header="Как семантический уровень dbt обрабатывает соединения?">
Семантический уровень dbt, поддерживаемый MetricFlow, строит соединения на основе типов ключей и параметров, которые передаются сущностям. Чтобы лучше понять, как строятся соединения, смотрите нашу документацию по типам соединений.

Вместо того чтобы захватывать произвольную логику соединения, MetricFlow захватывает типы каждого идентификатора и затем помогает пользователю ориентироваться в соответствующих соединениях. Это позволяет избежать построения соединений с разветвлениями и пропусками, а также генерировать читаемый SQL.
</DetailsToggle>

<DetailsToggle alt_header="Являются ли сущности и ключи соединения одним и тем же?">
Если вам удобно думать о сущностях как о ключах соединения, это вполне разумно. Сущности в MetricFlow имеют применения, выходящие за рамки соединения двух таблиц, такие как выступление в качестве измерения.
</DetailsToggle>

<DetailsToggle alt_header="Может ли таблица без первичных или уникальных сущностей иметь измерения?">
Да, но поскольку измерение считается атрибутом первичной или уникальной сущности таблицы, они могут использоваться только метриками, которые определены в этой таблице. Они не могут быть соединены с метриками из других таблиц. Это распространено в журналах событий.
</DetailsToggle>

## Связанные документы
- [Соединения](/docs/build/join-logic)
- [Валидации](/docs/build/validation)