---
title: Временная шкала MetricFlow
id: metricflow-time-spine
description: "MetricFlow ожидает таблицу временной шкалы по умолчанию, называемую metricflow_time_spine"
sidebar_label: "Временная шкала MetricFlow"
tags: [Метрики, Семантический слой]
---
<VersionBlock firstVersion="1.9">

<!-- этот раздел для версии 1.9 и выше + Release Tracks -->

В аналитической инженерии часто используется таблица измерения дат или "временная шкала" в качестве базовой таблицы для различных типов соединений и агрегаций на основе времени. Структура этой таблицы обычно включает базовую колонку с ежедневными или почасовыми датами, с дополнительными колонками для других временных гранулярностей, таких как фискальные кварталы, определяемые на основе базовой колонки. Вы можете присоединять другие таблицы к временной шкале по базовой колонке, чтобы вычислять метрики, такие как доход в определенный момент времени, или агрегировать данные до определенной временной гранулярности.

MetricFlow требует, чтобы вы определили как минимум одну модель dbt, которая предоставляет временную шкалу, а затем указали (в YAML) колонки, которые будут использоваться для соединений на основе времени. MetricFlow будет соединяться с моделью временной шкалы для следующих типов метрик и измерений:

- [Кумулятивные метрики](/docs/build/cumulative)
- [Смещения метрик](/docs/build/derived#derived-metric-offset)
- [Метрики конверсии](/docs/build/conversion)
- [Медленно изменяющиеся измерения](/docs/build/dimensions#scd-type-ii)
- [Метрики](/docs/build/metrics-overview) с конфигурацией `join_to_timespine`, установленной в true

Чтобы увидеть сгенерированный SQL для типов метрик и измерений, использующих соединения с временной шкалой, обратитесь к соответствующей документации или добавьте флаг `compile=True` при запросе Семантического слоя, чтобы вернуть скомпилированный SQL.

## Настройка временной шкалы в YAML

Модели временной шкалы — это обычные модели dbt с дополнительными конфигурациями, которые указывают dbt и MetricFlow, как использовать конкретные колонки, определяя их свойства. Добавьте [ключ `models`](/reference/model-properties) для временной шкалы в ваш каталог `models/`. Если ваш проект уже включает таблицу календаря или измерение дат, вы можете настроить эту таблицу как временную шкалу. В противном случае, ознакомьтесь с [примером таблиц временной шкалы](#example-time-spine-tables), чтобы создать одну из них.

Некоторые моменты, которые следует учитывать при настройке моделей временной шкалы:

- Добавьте конфигурации под ключом `time_spine` для [свойств модели](/reference/model-properties), так же как вы добавляете описание или тесты.
- Вам нужно настроить только те модели временной шкалы, которые Семантический слой должен распознавать.
- Минимально определите таблицу временной шкалы для ежедневной гранулярности.
- Вы можете дополнительно определить дополнительные таблицы временной шкалы для различных гранулярностей, таких как почасовая. Ознакомьтесь с [соображениями по гранулярности](#granularity-considerations) при принятии решения о том, какие таблицы создавать.
- Если вы хотите указать гранулярность временного измерения, чтобы MetricFlow мог преобразовать базовую колонку в требуемую гранулярность, обратитесь к [документации по временной гранулярности](/docs/build/dimensions?dimension=time_gran).

:::tip
Если вы ранее использовали модель, называемую `metricflow_time_spine`, вам больше не нужно создавать эту конкретную модель. Теперь вы можете настроить MetricFlow для использования любой таблицы измерения дат или временной шкалы, уже существующей в вашем проекте, обновив настройку `model` в Семантическом слое.

Если у вас нет таблицы измерения дат, вы все равно можете создать ее, используя фрагмент кода в [следующем разделе](#creating-a-time-spine-table), чтобы построить вашу модель временной шкалы.
:::

### Создание таблицы временной шкалы

MetricFlow поддерживает гранулярности от миллисекунд до лет. Обратитесь к [странице измерений](/docs/build/dimensions?dimension=time_gran#time) (вкладка time_granularity), чтобы найти полный список поддерживаемых гранулярностей.

Чтобы создать таблицу временной шкалы с нуля, вы можете добавить следующий код в ваш проект dbt. Этот пример создает временную шкалу с почасовой и ежедневной гранулярностью: `time_spine_hourly` и `time_spine_daily`.

<VersionBlock firstVersion="1.9">
<File name="models/_models.yml">
  
```yaml
[models:](/reference/model-properties) 
# Почасовая временная шкала
  - name: time_spine_hourly 
    description: моя любимая временная шкала
    time_spine:
      standard_granularity_column: date_hour # колонка для стандартной гранулярности вашей таблицы, должна быть типа date time.
      custom_granularities:
        - name: fiscal_year
          column_name: fiscal_year_column
    columns:
      - name: date_hour
        granularity: hour # установите гранулярность на уровне колонки для standard_granularity_column

# Ежедневная временная шкала
  - name: time_spine_daily
    time_spine:
      standard_granularity_column: date_day # колонка для стандартной гранулярности вашей таблицы
    columns:
      - name: date_day
        granularity: day # установите гранулярность на уровне колонки для standard_granularity_column
```
</File>
</VersionBlock>

<Lightbox src="/img/time_spines.png" width="50%" title="Структура каталога временной шкалы" />

<!--
<VersionBlock lastVersion="1.8">
<File name="models/_models.yml">
  
```yaml
models:
  - name: time_spine_hourly
    description: Временная шкала с одной строкой на час, охватывающая период с 2020-01-01 по 2039-12-31.
    time_spine:
      standard_granularity_column: date_hour # колонка для стандартной гранулярности вашей таблицы
    columns:
      - name: date_hour
        granularity: hour # установите гранулярность на уровне колонки для standard_granularity_column
  
  - name: time_spine_daily
    description: Временная шкала с одной строкой на день, охватывающая период с 2020-01-01 по 2039-12-31.
    time_spine:
      standard_granularity_column: date_day # колонка для стандартной гранулярности вашей таблицы
    columns:
      - name: date_day
        granularity: day # установите гранулярность на уровне колонки для standard_granularity_column
```

</File>
</VersionBlock>
-->

- Этот пример конфигурации показывает модель временной шкалы, называемую `time_spine_hourly` и `time_spine_daily`. Она устанавливает конфигурации временной шкалы под ключом `time_spine`.
- `standard_granularity_column` — это колонка, которая соответствует одной из наших [стандартных гранулярностей](/docs/build/dimensions?dimension=time_gran). Эта колонка должна быть установлена под ключом `columns` и должна иметь гранулярность, которая более тонкая или равна любой пользовательской колонке гранулярности, определенной в той же модели.
  - Она должна ссылаться на колонку, определенную под ключом `columns`, в данном случае `date_hour` и `date_day` соответственно.
  - Она устанавливает гранулярность на уровне колонки, используя ключ `granularity`, в данном случае `hour` и `day` соответственно.
- MetricFlow будет использовать `standard_granularity_column` в качестве ключа соединения при соединении таблицы временной шкалы с другой исходной таблицей.
- [Поле `custom_granularities`](#custom-calendar), (доступно в dbt Cloud Latest и dbt Core v1.9 и выше) позволяет вам указывать нестандартные временные периоды, такие как `fiscal_year` или `retail_month`, которые может использовать ваша организация.

Для примера проекта обратитесь к нашему [примеру Jaffle shop](https://github.com/dbt-labs/jaffle-sl-template/blob/main/models/marts/_models.yml).

### Соображения при выборе, какие гранулярности создавать{#granularity-considerations}

- MetricFlow будет использовать временную шкалу с наибольшей совместимой гранулярностью для данного запроса, чтобы обеспечить максимально эффективный запрос. Например, если у вас есть временная шкала с месячной гранулярностью и вы запрашиваете измерение с месячной гранулярностью, MetricFlow будет использовать месячную временную шкалу. Если у вас есть только ежедневная временная шкала, MetricFlow будет использовать ежедневную временную шкалу и date_trunc до месяца.
- Вы можете добавить временную шкалу для каждой гранулярности, которую вы планируете использовать, если эффективность запроса для вас важнее, чем время настройки или ограничения по хранению. Для большинства движков разница в производительности запроса должна быть минимальной, и преобразование вашей временной шкалы в более грубую гранулярность во время запроса не должно добавлять значительной нагрузки на ваши запросы.
- Мы рекомендуем иметь временную шкалу с самой тонкой гранулярностью, используемой в любом из ваших измерений, чтобы избежать неожиданных ошибок. Например, если у вас есть измерения с почасовой гранулярностью, у вас должна быть временная шкала с почасовой гранулярностью.

## Примеры таблиц временной шкалы

### Ежедневная

<File name="metricflow_time_spine.sql">

```sql
{{
    config(
        materialized = 'table',
    )
}}

with days as (

    {{
        dbt.date_spine(
            'day',
            "to_date('01/01/2000','mm/dd/yyyy')",
            "to_date('01/01/2025','mm/dd/yyyy')"
        )
    }}

),

final as (
    select cast(date_day as date) as date_day
    from days
)

select * from final
where date_day > dateadd(year, -4, current_timestamp()) 
and date_day < dateadd(day, 30, current_timestamp())
```

### Ежедневная (BigQuery)

Используйте эту модель, если вы используете BigQuery. BigQuery поддерживает `DATE()` вместо `TO_DATE()`:

<File name="metricflow_time_spine.sql">

```sql

{{config(materialized='table')}}
with days as (
    {{dbt.date_spine(
        'day',
        "DATE(2000,01,01)",
        "DATE(2025,01,01)"
    )
    }}
),

final as (
    select cast(date_day as date) as date_day
    from days
)

select *
from final
-- фильтруйте временную шкалу до определенного диапазона
where date_day > date_add(DATE(current_timestamp()), INTERVAL -4 YEAR)
and date_day < date_add(DATE(current_timestamp()), INTERVAL 30 DAY)
```

</File>

</File>

### Почасовая

<File name='time_spine_hourly.sql'>

```sql
{{
    config(
        materialized = 'table',
    )
}}

with hours as (

    {{
        dbt.date_spine(
            'hour',
            "to_date('01/01/2000','mm/dd/yyyy')",
            "to_date('01/01/2025','mm/dd/yyyy')"
        )
    }}

),

final as (
    select cast(date_hour as timestamp) as date_hour
    from hours
)

select * from final
-- фильтруйте временную шкалу до определенного диапазона
where date_day > dateadd(year, -4, current_timestamp()) 
and date_hour < dateadd(day, 30, current_timestamp())
```

</File>


</VersionBlock>

<VersionBlock lastVersion="1.8">

<!-- этот раздел для версии 1.8 и ниже -->

MetricFlow использует таблицу временной шкалы для построения кумулятивных метрик. По умолчанию MetricFlow ожидает, что таблица временной шкалы будет называться `metricflow_time_spine` и не поддерживает использование другого имени. Для поддерживаемых гранулярностей обратитесь к [странице измерений](/docs/build/dimensions?dimension=time_gran#time).

Чтобы создать эту таблицу, вам нужно создать модель в вашем проекте dbt, называемую `metricflow_time_spine`, и добавить следующий код:

### Ежедневная

<File name='metricflow_time_spine.sql'>


```sql
{{
    config(
        materialized = 'table',
    )
}}

with days as (

    {{
        dbt.date_spine(
            'day',
            "to_date('01/01/2000','mm/dd/yyyy')",
            "to_date('01/01/2025','mm/dd/yyyy')"
        )
    }}

),

final as (
    select cast(date_day as date) as date_day
    from days
)

select * from final
where date_day > dateadd(year, -4, current_timestamp()) 
and date_day  < dateadd(day, 30, current_timestamp())
```

</File>

### Ежедневная (BigQuery)

Используйте эту модель, если вы используете BigQuery. BigQuery поддерживает `DATE()` вместо `TO_DATE()`:

<File name="metricflow_time_spine.sql">

```sql
{{config(materialized='table')}}
with days as (
    {{dbt.date_spine(
        'day',
        "DATE(2000,01,01)",
        "DATE(2025,01,01)"
    )
    }}
),

final as (
    select cast(date_day as date) as date_day
    from days
)

select *
from final
-- фильтруйте временную шкалу до определенного диапазона
where date_day > dateadd(year, -4, current_timestamp()) 
and date_day < dateadd(day, 30, current_timestamp())
```

</File>

Вам нужно включить только колонку `date_day` в таблицу. MetricFlow может обрабатывать более широкие уровни детализации, но более тонкие гранулярности поддерживаются только в версиях 1.9 и выше.

</VersionBlock>


## Пользовательский календарь <Lifecycle status="Preview"/>

<VersionBlock lastVersion="1.8">

Возможность настройки пользовательских календарей, таких как фискальный календарь, доступна сейчас в [последней версии в dbt Cloud](/docs/dbt-versions/cloud-release-tracks), и будет доступна в [dbt Core v1.9+](/docs/dbt-versions/core-upgrade/upgrading-to-v1.9).

</VersionBlock>

<VersionBlock firstVersion="1.9">

Пользовательские преобразования дат могут быть сложными, и у организаций часто есть уникальные потребности, которые трудно обобщить. Создание модели пользовательского календаря позволяет вам определять эти преобразования в SQL, предлагая больше гибкости, чем встроенные преобразования в MetricFlow. Этот подход позволяет вам сопоставлять пользовательские колонки с гранулярностями MetricFlow, обеспечивая согласованность, при этом давая вам контроль над преобразованиями.

Например, если вы используете пользовательский календарь в вашей организации, такой как фискальный календарь, вы можете настроить его в MetricFlow, используя его операции с датами и временем.

- Это полезно для расчета метрик на основе пользовательского календаря, таких как фискальные кварталы или недели.
- Используйте ключ `custom_granularities`, чтобы определить нестандартный временной период для запроса данных, такой как `retail_month` или `fiscal_week`, вместо стандартных опций, таких как `day`, `month` или `year`.
- Эта функция предоставляет больше контроля над тем, как рассчитываются метрики на основе времени.

<Expandable alt_header="Соображения по типам данных и часовым поясам">
 
При работе с пользовательскими календарями в MetricFlow важно обеспечить:

- Согласованные типы данных &mdash; как ваша колонка измерения, так и колонка временной шкалы должны использовать один и тот же тип данных для точных сравнений. Функции, такие как `DATE_TRUNC`, не изменяют тип данных входных данных в некоторых базах данных (например, Snowflake). Использование разных типов данных может привести к несоответствиям и неточным результатам.

  Мы рекомендуем использовать типы данных `DATETIME` или `TIMESTAMP` для ваших временных измерений и временной шкалы, так как они поддерживают все гранулярности. Тип данных `DATE` может не поддерживать более мелкие гранулярности, такие как часы или минуты.

- Часовые пояса &mdash; MetricFlow в настоящее время не выполняет никаких манипуляций с часовыми поясами. При работе с данными, учитывающими часовой пояс, несоответствия в часовых поясах могут привести к неожиданным результатам при агрегациях и сравнениях.

Например, если ваша колонка временной шкалы имеет тип `TIMESTAMP`, а ваша колонка измерения имеет тип `DATE`, сравнения между этими колонками могут не работать, как предполагалось. Чтобы исправить это, преобразуйте вашу колонку `DATE` в `TIMESTAMP` или убедитесь, что обе колонки имеют один и тот же тип данных.

</Expandable>

### Добавление пользовательских гранулярностей

Чтобы добавить пользовательские гранулярности, Семантический слой поддерживает конфигурации пользовательского календаря, которые позволяют пользователям запрашивать данные, используя нестандартные временные периоды, такие как `fiscal_year` или `retail_month`. Вы можете определить эти пользовательские гранулярности (все в нижнем регистре), изменив конфигурацию YAML вашей модели следующим образом:

<File name="models/_models.yml">

```yaml
models:
 - name: my_time_spine
   description: моя любимая временная шкала
   time_spine:
      standard_granularity_column: date_day
      custom_granularities:
        - name: fiscal_year
          column_name: fiscal_year_column
```
</File>

#### Скоро
Обратите внимание, что такие функции, как расчет смещений и периодов по периодам, будут поддерживаться в ближайшее время!

</VersionBlock>