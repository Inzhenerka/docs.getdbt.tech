---
title: Размерности
id: dimensions
description: "Размерности определяют уровень агрегации для метрики и являются неагрегируемыми выражениями."
sidebar_label: "Размерности"
tags: [Метрики, Семантический уровень]
---

Размерности представляют собой неагрегируемые столбцы в вашем наборе данных, которые являются атрибутами, характеристиками или признаками, описывающими или классифицирующими данные. В контексте семантического уровня dbt размерности являются частью более крупной структуры, называемой семантической моделью. Они создаются вместе с другими элементами, такими как [сущности](/docs/build/entities) и [меры](/docs/build/measures), и используются для добавления дополнительных деталей к вашим данным. В SQL размерности обычно включаются в оператор `group by` вашего SQL-запроса.

Все размерности требуют указания `name`, `type`, и могут дополнительно включать параметр `expr`. `name` для вашей размерности должен быть уникальным в пределах одной семантической модели.

| Параметр | Описание | Обязательный | Тип |
| --------- | ----------- | ---- | ---- |
| `name` |  Относится к имени группы, которое будет видно пользователю в инструментах на выходе. Оно также может служить псевдонимом, если имя столбца или ссылка на SQL-запрос отличается и указана в параметре `expr`. <br /><br /> Имена размерностей должны быть уникальными в семантической модели, но они могут быть не уникальными в разных моделях, так как MetricFlow использует [соединения](/docs/build/join-logic) для идентификации правильной размерности. | Обязательный | Строка |
| `type` | Указывает тип группы, создаваемой в семантической модели. Существует два типа:<br /><br />- **Категориальный**: Описывает атрибуты или характеристики, такие как география или регион продаж. <br />- **Время**: Размерности, основанные на времени, такие как временные метки или даты. | Обязательный | Строка |  
| `type_params` | Специфические параметры типа, такие как то, является ли время основным или используется как раздел. | Обязательный | Словарь |
| `description` | Четкое описание размерности. | Необязательный | Строка |  
| `expr` | Определяет основной столбец или SQL-запрос для размерности. Если `expr` не указан, MetricFlow будет использовать столбец с тем же именем, что и группа. Вы можете использовать само имя столбца для ввода SQL-выражения. | Необязательный | Строка |
| `label` | Определяет отображаемое значение в инструментах на выходе. Принимает обычный текст, пробелы и кавычки (например, `orders_total` или `"orders_total"`).  | Необязательный | Строка |

Смотрите полную спецификацию для размерностей:

```yaml
dimensions:
  - name: Имя группы, которое будет видно пользователю в инструментах на выходе # Обязательный
    type: Категориальный или Время # Обязательный
    label: Рекомендуется добавить строку, которая определяет отображаемое значение в инструментах на выходе. # Необязательный
    type_params: Специфические параметры типа, такие как то, является ли время основным или используется как раздел # Обязательный
    description: То же, что и всегда # Необязательный
    expr: Имя столбца или выражение. Если не указано, по умолчанию используется имя размерности # Необязательный
```

Смотрите следующий пример, чтобы увидеть, как размерности используются в семантической модели:

```yaml
semantic_models:
  - name: transactions
    description: Запись каждой транзакции, которая происходит. Корзины считаются несколькими транзакциями для каждого SKU. 
    model: {{ ref('fact_transactions') }}
    defaults:
      agg_time_dimension: order_date
# --- сущности --- 
  entities: 
    - name: transaction
      type: primary
      ...
# --- меры --- 
  measures: 
      ... 
# --- размерности ---
  dimensions:
    - name: order_date
      type: time
      type_params:
        time_granularity: day
      label: "Дата транзакции" # Рекомендуется добавить метку для предоставления большего контекста пользователям, использующим данные
      expr: ts
    - name: is_bulk
      type: categorical
      expr: case when quantity > 10 then true else false end
    - name: type
      type: categorical
```

Размерности связаны с основной сущностью семантической модели, в которой они определены. Например, размерность `type` определена в модели, где `transaction` является основной сущностью. `type` ограничена сущностью `transaction`, и для ссылки на эту размерность вы должны использовать полное имя размерности, т.е. `transaction__type`. 

MetricFlow требует, чтобы все семантические модели имели основную сущность. Это необходимо для гарантии уникальности имен размерностей. Если ваш источник данных не имеет основной сущности, вам нужно назначить сущности имя, используя ключ `primary_entity`. Это не обязательно должно соответствовать столбцу в этой таблице, и назначение имени не влияет на генерацию запросов. Мы рекомендуем делать эти "виртуальные основные сущности" уникальными в вашей семантической модели. Пример определения основной сущности для источника данных, который не имеет столбца основной сущности, приведен ниже:

```yaml
semantic_model:
  name: bookings_monthly_source
  description: bookings_monthly_source
  defaults:
    agg_time_dimension: ds
  model: ref('bookings_monthly_source')
  measures:
    - name: bookings_monthly
      agg: sum
      create_metric: true
  primary_entity: booking_id
```

## Типы размерностей
Этот раздел дополнительно объясняет определения размерностей, а также примеры. Размерности имеют следующие типы:

- [Типы размерностей](#dimensions-types)
- [Категориальные](#categorical)
- [Время](#time)
  - [SCD Тип II](#scd-type-ii)
    - [Основная структура](#basic-structure)
    - [Параметры и ключи семантической модели](#semantic-model-parameters-and-keys)
    - [Реализация](#implementation)
    - [Примеры SCD](#scd-examples)

## Категориальные

Категориальные размерности используются для группировки метрик по различным атрибутам, характеристикам или признакам, таким как тип продукта. Они могут ссылаться на существующие столбцы в вашей модели dbt или вычисляться с использованием SQL-выражения с параметром `expr`. Пример категориальной размерности — `is_bulk_transaction`, которая является группой, созданной путем применения оператора case к основному столбцу `quantity`. Это позволяет пользователям группировать или фильтровать данные на основе оптовых транзакций.

```yaml
dimensions: 
  - name: is_bulk_transaction
    type: categorical
    expr: case when quantity > 10 then true else false end
```

## Время

Время имеет дополнительные параметры, указанные в разделе `type_params`. Когда вы запрашиваете одну или несколько метрик, размерность времени по умолчанию для каждой метрики — это размерность агрегации времени, которую вы можете обозначить как `metric_time` или использовать имя размерности. 

Вы можете использовать несколько временных групп в отдельных метриках. Например, метрика `users_created` использует `created_at`, а метрика `users_deleted` использует `deleted_at`:

```bash
# пользователи dbt Cloud
dbt sl query --metrics users_created,users_deleted --group-by metric_time__year --order-by metric_time__year

# пользователи dbt Core
mf query --metrics users_created,users_deleted --group-by metric_time__year --order-by metric_time__year
```

Вы можете установить `is_partition` для времени, чтобы определить конкретные временные интервалы. Кроме того, используйте раздел `type_params`, чтобы установить `time_granularity`, чтобы настроить детали агрегации (ежедневно, еженедельно и т.д.).

<Tabs queryString="dimension">

<TabItem value="is_partition" label="is_partition">

Используйте `is_partition: True`, чтобы показать, что размерность существует в течение определенного временного окна. Например, таблица размерностей, разделенная по датам. Когда вы запрашиваете метрики из разных таблиц, семантический уровень dbt использует этот параметр, чтобы гарантировать, что правильные размерные значения соединяются с мерами. 

```yaml
dimensions: 
  - name: created_at
    type: time
    label: "Дата создания"
    expr: ts_created # ts_created — это имя основного столбца из таблицы 
    is_partition: True
    type_params:
      time_granularity: day
  - name: deleted_at
    type: time
    label: "Дата удаления"
    expr: ts_deleted # ts_deleted — это имя основного столбца из таблицы
    is_partition: True 
    type_params:
      time_granularity: day

measures:
  - name: users_deleted
    expr: 1
    agg: sum
    agg_time_dimension: deleted_at
  - name: users_created
    expr: 1
    agg: sum
```

</TabItem>

<TabItem value="time_gran" label="time_granularity">

<VersionBlock firstVersion="1.9">

`time_granularity` указывает на зерно временной размерности. MetricFlow преобразует основной столбец в указанную гранулярность. Например, если вы добавите почасовую гранулярность к столбцу временной размерности, MetricFlow выполнит функцию `date_trunc`, чтобы преобразовать временную метку в почасовую. Вы можете легко изменить временное зерно во время запроса и агрегировать его до более грубой гранулярности, например, с почасовой до месячной. Однако вы не можете перейти от более грубой гранулярности к более тонкой (с месячной на почасовую).

Наши поддерживаемые гранулярности:
* наносекунда (только Snowflake)
* микросекунда 
* миллисекунда
* секунда
* минута
* час
* день
* неделя
* месяц
* квартал
* год

Агрегация между метриками с различными гранулярностями возможна, при этом семантический уровень по умолчанию возвращает результаты на самой грубой гранулярности. Например, при запросе двух метрик с ежедневной и месячной гранулярностью результирующая агрегация будет на уровне месяца.

```yaml
dimensions: 
  - name: created_at
    type: time
    label: "Дата создания"
    expr: ts_created # ts_created — это имя основного столбца из таблицы 
    is_partition: True 
    type_params:
      time_granularity: hour 
  - name: deleted_at
    type: time
    label: "Дата удаления"
    expr: ts_deleted # ts_deleted — это имя основного столбца из таблицы 
    is_partition: True 
    type_params:
      time_granularity: day 

measures:
  - name: users_deleted
    expr: 1
    agg: sum 
    agg_time_dimension: deleted_at
  - name: users_created
    expr: 1
    agg: sum
```

</VersionBlock>

<VersionBlock lastVersion="1.8">

`time_granularity` указывает на зерно временной размерности. MetricFlow преобразует основной столбец в указанную гранулярность. Например, если вы добавите ежедневную гранулярность к столбцу временной размерности, MetricFlow выполнит функцию `date_trunc`, чтобы преобразовать временную метку в ежедневную. Вы можете легко изменить временное зерно во время запроса и агрегировать его до более грубой гранулярности, например, с ежедневной до месячной. Однако вы не можете перейти от более грубой гранулярности к более тонкой (с месячной на ежедневную).

Наши поддерживаемые гранулярности:
* день
* неделя
* месяц
* квартал
* год

Агрегация между метриками с различными гранулярностями возможна, при этом семантический уровень по умолчанию возвращает результаты на самой грубой гранулярности. Например, при запросе двух метрик с ежедневной и месячной гранулярностью результирующая агрегация будет на уровне месяца.

```yaml
dimensions: 
  - name: created_at
    type: time
    label: "Дата создания"
    expr: ts_created # ts_created — это имя основного столбца из таблицы 
    is_partition: True 
    type_params:
      time_granularity: day 
  - name: deleted_at
    type: time
    label: "Дата удаления"
    expr: ts_deleted # ts_deleted — это имя основного столбца из таблицы 
    is_partition: True 
    type_params:
      time_granularity: day 

measures:
  - name: users_deleted
    expr: 1
    agg: sum 
    agg_time_dimension: deleted_at
  - name: users_created
    expr: 1
    agg: sum
```

</VersionBlock>

</TabItem>

</Tabs>

### SCD Тип II

:::caution
В настоящее время семантические модели с размерностями SCD Тип II не могут содержать меры.
:::

MetricFlow поддерживает соединения с значениями размерностей в семантической модели, построенной на основе таблицы медленно изменяющейся размерности (SCD) Тип II. Это полезно, когда вам нужно получить определенную метрику, разбитую по группе, которая изменяется со временем, например, исторические тенденции продаж по стране клиента.

#### Основная структура

SCD Тип II — это группы, которые изменяют значения на более грубой временной гранулярности. Таблицы SCD Тип II обычно имеют два временных столбца, которые указывают на период действия размерности: `valid_from` (или `tier_start`) и `valid_to` (или `tier_end`). Это создает диапазон действительных строк с различными значениями размерности для метрики или меры.

MetricFlow связывает метрику с самой ранней доступной размерностью в пределах более грубого временного окна, например, месяца. По умолчанию используется группа, действительная в начале этой временной гранулярности.

MetricFlow поддерживает следующую основную структуру таблицы платформы данных SCD Тип II:

| entity_key | dimensions_1 | dimensions_2 | ... | dimensions_x | valid_from | valid_to |
|------------|-------------|-------------|-----|-------------|------------|----------|  

* `entity_key` (обязательный): Уникальный идентификатор для каждой строки в таблице, такой как первичный ключ или другой уникальный идентификатор, специфичный для сущности.
* `valid_from`  (обязательный): Дата начала, когда размерность действительна. Используйте `validity_params: is_start: True` в семантической модели, чтобы указать это.
* `valid_to`  (обязательный): Дата окончания, когда размерность действительна. Используйте `validity_params: is_end: True` в семантической модели, чтобы указать это.

#### Параметры и ключи семантической модели
При настройке таблицы SCD Тип II в семантической модели используйте `validity_params`, чтобы указать начало (`valid_from`) и конец (`valid_to`) периода действия для каждой размерности. 

- `validity_params`: Параметры, которые определяют период действия.
  - `is_start: True`: Указывает на начало периода действия. Отображается как `valid_from` в таблице SCD.
  - `is_end: True`: Указывает на конец периода действия. Отображается как `valid_to` в таблице SCD.

Вот пример конфигурации:

```yaml
- name: tier_start #  Имя размерности.
  type: time # Тип размерности (например, время)
  label: "Дата начала уровня" # Читаемая метка для размерности
  expr: start_date # Выражение или имя столбца, которое представляет размерность
  type_params: # Дополнительные параметры для типа размерности
    time_granularity: day # Указывает гранулярность временной размерности (например, день)
    validity_params: # Определяет период действия
      is_start: True # Указывает на начало периода действия. 
- name: tier_end 
  type: time
  label: "Дата окончания уровня"
  expr: end_date
  type_params:
    time_granularity: day
    validity_params:
      is_end: True # Указывает на конец периода действия.
```

Таблицы SCD Тип II имеют конкретную размерность с датой начала и окончания. Для соединения таблиц:
- Установите дополнительный [параметр `type` сущности](/docs/build/entities#entity-types) в ключ `natural`. 
- Используйте ключ `natural` в качестве [параметра `type` сущности](/docs/build/entities#entity-types), что означает, что вам не нужен `primary` ключ.
- В большинстве случаев таблицы SCD не имеют логически используемого `primary` ключа, так как `natural` ключи сопоставляются с несколькими строками.

#### Реализация

Вот некоторые рекомендации, которые следует учитывать при реализации таблиц SCD Тип II:

- Таблица SCD должна иметь временные размерности `valid_to` и `valid_from`, которые являются логическими конструкциями.
- Свойства `valid_from` и `valid_to` должны быть указаны ровно один раз для каждой конфигурации таблицы SCD.
- Свойства `valid_from` и `valid_to` не должны использоваться или указываться в одной и той же временной размерности.
- Временные размерности `valid_from` и `valid_to` должны охватывать неперекрывающийся период, в котором одна строка соответствует каждому значению естественного ключа (то есть они не должны перекрываться и должны быть различными).
- Мы рекомендуем определять основную модель dbt с помощью [снимков dbt](/docs/build/snapshots). Это поддерживает макет таблицы SCD Тип II и гарантирует, что таблица обновляется с последними данными.

Вот пример SQL-кода, который показывает, как метрика под названием `num_events` соединяется с данными размерностей с версиями (хранящимися в таблице `scd_dimensions`) с использованием первичного ключа, состоящего из столбцов `entity_key` и `timestamp`. 

```sql
select metric_time, dimensions_1, sum(1) as num_events
from events a
left outer join scd_dimensions b
on 
  a.entity_key = b.entity_key 
  and a.metric_time >= b.valid_from 
  and (a.metric_time < b.valid_to or b.valid_to is null)
group by 1, 2
```

#### Примеры SCD

Следующие примеры показывают, как использовать таблицы SCD Тип II в семантической модели:

<Expandable alt_header="Размерности SCD для уровней продаж и временной длины этого уровня.">

Этот пример показывает, как создать медленно изменяющиеся размерности (SCD) с использованием семантической модели. Таблица SCD содержит информацию о уровнях продажников и временной длине этого уровня. Предположим, у вас есть основная таблица SCD:

| sales_person_id | tier | start_date | end_date | 
|-----------------|------|------------|----------|
| 111             | 1    | 2019-02-03 | 2020-01-05| 
| 111             | 2    | 2020-01-05 | 2048-01-01| 
| 222             | 2    | 2020-03-05 | 2048-01-01| 
| 333             | 2    | 2020-08-19 | 2021-10-22| 
| 333             | 3    | 2021-10-22 | 2048-01-01|  

Как уже упоминалось, `validity_params` включает два важных аргумента, которые указывают на столбцы в таблице SCD, которые отмечают даты начала и окончания (или временные метки) для каждого уровня или размерности:
- `is_start`
- `is_end`

Кроме того, сущность помечена как `natural`, чтобы отличать ее от `primary` сущности. В `primary` сущности каждое значение сущности имеет одну строку. В отличие от этого, `natural` сущность имеет одну строку для каждой комбинации значения сущности и его периода действия.

```yaml 
semantic_models:
  - name: sales_person_tiers
    description: Таблица SCD Тип II уровней для продавцов 
    model: {{ ref('sales_person_tiers') }}
    defaults:
      agg_time_dimension: tier_start

    dimensions:
      - name: tier_start
        type: time
        label: "Дата начала уровня"
        expr: start_date
        type_params:
          time_granularity: day
          validity_params:
            is_start: True
      - name: tier_end 
        type: time
        label: "Дата окончания уровня"
        expr: end_date
        type_params:
          time_granularity: day
          validity_params:
            is_end: True
      - name: tier
        type: categorical

    primary_entity: sales_person

    entities:
      - name: sales_person
        type: natural 
        expr: sales_person_id
```

Следующий код представляет собой отдельную семантическую модель, которая содержит фактическую таблицу для `transactions`:  

```yaml
semantic_models: 
  - name: transactions 
    description: |
      Каждая строка представляет одну транзакцию.
      Для каждой транзакции есть идентификатор транзакции, продукта, продавца и клиента. 
      Для каждой транзакции существует только один идентификатор транзакции. Дата `metric_time` 
      отражается в UTC.
    model: {{ ref('fact_transactions') }}
    defaults:
      agg_time_dimension: metric_time

    entities:
      - name: transaction_id
        type: primary
      - name: customer
        type: foreign
        expr: customer_id
      - name: product
        type: foreign
        expr: product_id
      - name: sales_person
        type: foreign
        expr: sales_person_id

    measures:
      - name: transactions
        expr: 1
        agg: sum
      - name: gross_sales
        expr: sales_price
        agg: sum
      - name: sales_persons_with_a_sale
        expr: sales_person_id
        agg: count_distinct

    dimensions:
      - name: metric_time
        type: time
        label: "Дата транзакции"
        is_partition: true
        type_params:
          time_granularity: day
      - name: sales_geo
        type: categorical
```

Теперь вы можете получить доступ к метрикам в семантической модели `transactions`, организованным по медленно изменяющейся размерности `tier`. 

В примере уровня продаж, например, если продавец находился на уровне 1 с 2022-03-01 по 2022-03-12 и был повышен до уровня 2 с 2022-03-12, все транзакции за март будут классифицированы под уровнем 1, так как значение размерности уровня 1 приходит раньше (и является начальной точкой по умолчанию), даже если продавец был повышен до уровня 2 12 марта 2022 года.

</Expandable>

<Expandable alt_header="Размерности SCD с уровнями продаж и группировка транзакций по месяцам, когда уровни отсутствуют">

Этот пример показывает, как создать медленно изменяющиеся размерности (SCD) с использованием семантической модели. Таблица SCD содержит информацию о уровнях продажников и временной длине этого уровня. Предположим, у вас есть основная таблица SCD:

| sales_person_id | tier | start_date | end_date | 
|-----------------|------|------------|----------|
| 111             | 1    | 2019-02-03 | 2020-01-05| 
| 111             | 2    | 2020-01-05 | 2048-01-01| 
| 222             | 2    | 2020-03-05 | 2048-01-01| 
| 333             | 2    | 2020-08-19 | 2021-10-22| 
| 333             | 3    | 2021-10-22 | 2048-01-01|  

В примере уровня продаж, если sales_person_id 456 находится на уровне 2 с 2022-03-08, но для этого человека нет связанного уровня размерности с 2022-03-01 по 2022-03-08, тогда все транзакции, связанные с sales_person_id 456 за март, будут сгруппированы под 'NA', так как до уровня 2 не было представлено ни одного уровня.

Следующая команда или код представляют, как вернуть количество транзакций, сгенерированных каждым уровнем продаж в месяц:

```bash
# пользователи dbt Cloud
dbt sl query --metrics transactions --group-by metric_time__month,sales_person__tier --order-by metric_time__month,sales_person__tier

# пользователи dbt Core
mf query --metrics transactions --group-by metric_time__month,sales_person__tier --order-by metric_time__month,sales_person__tier

```

</Expandable>