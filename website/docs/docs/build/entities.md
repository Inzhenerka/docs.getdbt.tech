---
title: Сущности
id: entities
description: "Сущности — это концепции реального мира, которые соответствуют ключевым частям вашего бизнеса, таким как клиенты, транзакции и рекламные кампании."
sidebar_label: "Сущности"
tags: [Metrics, Semantic Layer]
---

Сущности — это концепции реального мира в бизнесе, такие как клиенты, транзакции и рекламные кампании. Мы часто фокусируем наши анализы вокруг конкретных сущностей, таких как отток клиентов или моделирование ежегодного повторяющегося дохода. Мы представляем сущности в наших семантических моделях, используя столбцы id, которые служат ключами для соединения с другими семантическими моделями в вашем семантическом графе.

В семантическом графе обязательными параметрами для сущности являются `name` и `type`. `name` относится либо к названию ключевого столбца из исходной таблицы данных, либо может служить псевдонимом с именем столбца, указанным в параметре `expr`. `name` вашей сущности должно быть уникальным для семантической модели и не может совпадать с существующими `measure` или `dimension` в этой же модели.

Сущности могут быть заданы с одним столбцом или несколькими столбцами. Сущности (ключи соединения) в семантической модели идентифицируются по их имени. Каждое имя сущности должно быть уникальным в пределах семантической модели, но не обязательно уникальным в разных семантических моделях.

Существует четыре типа сущностей:
- [Первичный](#primary) &mdash; Имеет только одну запись для каждой строки в таблице и включает каждую запись на платформе данных. Этот ключ уникально идентифицирует каждую запись в таблице.
- [Уникальный](#unique) &mdash; Содержит только одну запись на строку в таблице и допускает нулевые значения. Может иметь подмножество записей в хранилище данных.
- [Внешний](#foreign) &mdash; Поле (или набор полей) в одной таблице, которое уникально идентифицирует строку в другой таблице. Этот ключ устанавливает связь между таблицами.
- [Естественный](#natural) &mdash; Столбцы или комбинации столбцов в таблице, которые уникально идентифицируют запись на основе данных реального мира. Этот ключ выводится из фактических атрибутов данных.

:::tip Используйте сущности как измерения
Вы также можете использовать сущности как измерения, что позволяет агрегировать метрику до уровня детализации этой сущности.
:::

## Типы сущностей

Логика соединения MetricFlow зависит от типа сущности, который вы используете, и определяет, как соединять семантические модели. Обратитесь к [Соединениям](/docs/build/join-logic) для получения дополнительной информации о том, как строить соединения.

### Первичный
Первичный ключ имеет _только одну_ запись для каждой строки в таблице и включает каждую запись на платформе данных. Он должен содержать уникальные значения и не может содержать нулевые значения. Используйте первичный ключ, чтобы гарантировать, что каждая запись в таблице является уникальной и идентифицируемой.

<Expandable alt_header="Пример первичного ключа">

Например, рассмотрим таблицу сотрудников со следующими столбцами:

```sql
employee_id (primary key)
first_name
last_name
```
В этом случае `employee_id` является первичным ключом. Каждый `employee_id` уникален и представляет одного конкретного сотрудника. Не может быть дублирующих `employee_id` и не может быть нулевым.

</Expandable>

### Уникальный
Уникальный ключ содержит _только одну_ запись на строку в таблице, но может иметь подмножество записей в хранилище данных. Однако, в отличие от первичного ключа, уникальный ключ допускает нулевые значения. Уникальный ключ гарантирует, что значения столбца являются уникальными, за исключением нулевых значений.

<Expandable alt_header="Пример уникального ключа">

Например, рассмотрим таблицу студентов со следующими столбцами:

```sql
student_id (primary key)
email (unique key)
first_name
last_name
```

В этом примере `email` определен как уникальный ключ. Каждый адрес электронной почты должен быть уникальным; однако, у нескольких студентов могут быть нулевые адреса электронной почты. Это связано с тем, что ограничение уникального ключа допускает одно или несколько нулевых значений, но ненулевые значения должны быть уникальными. Это создает набор записей с уникальными (ненулевыми) адресами электронной почты, которые могут быть подмножеством всей таблицы, включающей всех студентов.

</Expandable>

### Внешний
Внешний ключ — это поле (или набор полей) в одной таблице, которое уникально идентифицирует строку в другой таблице. Внешний ключ устанавливает связь между данными в двух таблицах.
Он может включать ноль, одну или несколько экземпляров одной и той же записи. Он также может содержать нулевые значения.

<Expandable alt_header="Пример внешнего ключа">

Например, предположим, у вас есть две таблицы, `customers` и `orders`:

таблица customers:

```sql
customer_id (primary key)
customer_name
```

таблица orders:

```sql
order_id (primary key)
order_date
customer_id (foreign key)
```

В этом примере `customer_id` в таблице `orders` является внешним ключом, который ссылается на `customer_id` в таблице `customers`. Эта связь означает, что каждый заказ связан с конкретным клиентом. Однако не каждый заказ должен иметь клиента; `customer_id` в таблице заказов может быть нулевым или иметь тот же `customer_id` для нескольких заказов.

</Expandable>

### Естественный

Естественные ключи — это столбцы или комбинации столбцов в таблице, которые уникально идентифицируют запись на основе данных реального мира. Например, если у вас есть таблица измерений `sales_person_department`, `sales_person_id` может служить естественным ключом. Вы можете использовать естественные ключи только для [измерений типа SCD II](/docs/build/dimensions#scd-type-ii).

## Конфигурация сущностей

Ниже приведена полная спецификация для сущностей:

```yaml
entities:
  - name: transaction     ## Обязательно
    type: Primary or natural or foreign or unique ## Обязательно
    description: Описание поля или роли, которую сущность выполняет в этой таблице ## Необязательно
    expr: Поле, обозначающее эту сущность (transaction_id).  ## Необязательно
          По умолчанию совпадает с name, если не указано.
```

Вот пример того, как определить сущности в семантической модели:
  
```yaml
entities:
  - name: transaction
    type: primary
    expr: id_transaction
  - name: order
    type: foreign
    expr: id_order
  - name: user
    type: foreign
    expr: substring(id_order from 2)
```

## Комбинирование столбцов с ключом

Если в таблице нет ключа (например, первичного ключа), используйте _суррогатное сочетание_, чтобы сформировать ключ, который поможет вам идентифицировать запись, комбинируя два столбца. Это применимо к любому [типу сущности](/docs/build/entities#entity-types). Например, вы можете объединить `date_key` и `brand_code` из таблицы `raw_brand_target_weekly`, чтобы сформировать _суррогатный ключ_. В следующем примере создается суррогатный ключ путем объединения `date_key` и `brand_code` с использованием вертикальной черты (`|`) в качестве разделителя.

```yaml

entities:
  - name: brand_target_key # Имя или идентификатор сущности.
    type: foreign # Это может быть любой тип ключа сущности. 
    expr: date_key || '|' || brand_code # Определяет выражение для связывания полей для формирования суррогатного ключа.
```