---
title: Сущности
id: entities
description: "Сущности — это реальные концепции, которые соответствуют ключевым частям вашего бизнеса, таким как клиенты, транзакции и рекламные кампании."
sidebar_label: "Сущности"
tags: [Метрики, Семантический уровень]
---

Сущности — это реальные концепции в бизнесе, такие как клиенты, транзакции и рекламные кампании. Мы часто сосредотачиваем наши анализы вокруг конкретных сущностей, таких как отток клиентов или моделирование ежегодного повторяющегося дохода. Мы представляем сущности в наших семантических моделях, используя столбцы id, которые служат ключами для соединения с другими семантическими моделями в вашей семантической графе.

В семантической графе обязательными параметрами для сущности являются `name` и `type`. `name` относится либо к имени ключевого столбца из базовой таблицы данных, либо может служить псевдонимом с именем столбца, указанным в параметре `expr`. `name` вашей сущности должно быть уникальным для семантической модели и не может совпадать с существующими `measure` или `dimension` в той же модели.

Сущности могут быть указаны с одним или несколькими столбцами. Сущности (ключи соединения) в семантической модели идентифицируются по их имени. Каждое имя сущности должно быть уникальным в пределах семантической модели, но не обязательно уникальным между различными семантическими моделями.

Существует четыре типа сущностей:
- [Первичный](#primary) &mdash; Имеет только одну запись для каждой строки в таблице и включает каждую запись в платформе данных. Этот ключ уникально идентифицирует каждую запись в таблице.
- [Уникальный](#unique) &mdash; Содержит только одну запись на строку в таблице и допускает нулевые значения. Может содержать подмножество записей в хранилище данных.
- [Внешний](#foreign) &mdash; Поле (или набор полей) в одной таблице, которое уникально идентифицирует строку в другой таблице. Этот ключ устанавливает связь между таблицами.
- [Естественный](#natural) &mdash; Столбцы или комбинации столбцов в таблице, которые уникально идентифицируют запись на основе реальных данных. Этот ключ выводится из фактических атрибутов данных.

:::tip Используйте сущности как измерения
Вы также можете использовать сущности в качестве измерений, что позволяет агрегировать метрику до уровня детализации этой сущности.
:::

## Типы сущностей

Логика соединения MetricFlow зависит от типа сущности `type`, который вы используете, и определяет, как соединять семантические модели. Обратитесь к [Соединениям](/docs/build/join-logic) для получения дополнительной информации о том, как строить соединения.

### Первичный
Первичный ключ имеет _только одну_ запись для каждой строки в таблице и включает каждую запись в платформе данных. Он должен содержать уникальные значения и не может содержать нулевые значения. Используйте первичный ключ, чтобы гарантировать, что каждая запись в таблице является уникальной и идентифицируемой.

<Expandable alt_header="Пример первичного ключа">

Например, рассмотрим таблицу сотрудников со следующими столбцами:

```sql
employee_id (первичный ключ)
first_name
last_name
```
В этом случае `employee_id` является первичным ключом. Каждый `employee_id` уникален и представляет собой одного конкретного сотрудника. Дубликатов `employee_id` быть не должно, и он не может быть нулевым.

</Expandable>

### Уникальный
Уникальный ключ содержит _только одну_ запись на строку в таблице, но может иметь подмножество записей в хранилище данных. Однако, в отличие от первичного ключа, уникальный ключ допускает нулевые значения. Уникальный ключ гарантирует, что значения в столбце различны, за исключением нулевых значений.

<Expandable alt_header="Пример уникального ключа">

Например, рассмотрим таблицу студентов со следующими столбцами:

```sql
student_id (первичный ключ)
email (уникальный ключ)
first_name
last_name
```

В этом примере `email` определен как уникальный ключ. Каждый адрес электронной почты должен быть уникальным; однако несколько студентов могут иметь нулевые адреса электронной почты. Это связано с тем, что ограничение уникального ключа допускает одно или несколько нулевых значений, но ненулевые значения должны быть уникальными. Это создает набор записей с уникальными адресами электронной почты (ненулевыми), которые могут быть подмножеством всей таблицы, включающей всех студентов.

</Expandable>

### Внешний
Внешний ключ — это поле (или набор полей) в одной таблице, которое уникально идентифицирует строку в другой таблице. Внешний ключ устанавливает связь между данными в двух таблицах. Он может включать ноль, одну или несколько экземпляров одной и той же записи. Он также может содержать нулевые значения.

<Expandable alt_header="Пример внешнего ключа">

Например, предположим, что у вас есть две таблицы: `customers` и `orders`:

таблица customers:

```sql
customer_id (первичный ключ)
customer_name
```

таблица orders:

```sql
order_id (первичный ключ)
order_date
customer_id (внешний ключ)
```

В этом примере `customer_id` в таблице `orders` является внешним ключом, который ссылается на `customer_id` в таблице `customers`. Эта связь означает, что каждый заказ связан с конкретным клиентом. Однако не каждый заказ должен иметь клиента; `customer_id` в таблице заказов может быть нулевым или иметь одно и то же `customer_id` для нескольких заказов.

</Expandable>

### Естественный

Естественные ключи — это столбцы или комбинации столбцов в таблице, которые уникально идентифицируют запись на основе реальных данных. Например, если у вас есть таблица измерений `sales_person_department`, `sales_person_id` может служить естественным ключом. Вы можете использовать естественные ключи только для [измерений типа SCD II](/docs/build/dimensions#scd-type-ii).

## Конфигурация сущностей

Следующее — это полная спецификация для сущностей:

```yaml
entities:
  - name: transaction     ## Обязательно
    type: Primary or natural or foreign or unique ## Обязательно
    description: Описание поля или роли, которую сущность занимает в этой таблице ## Необязательно
    expr: Поле, которое обозначает эту сущность (transaction_id).  ## Необязательно
          По умолчанию используется name, если не указано.
```

Вот пример того, как определить сущности в семантической модели:
  
```yaml
entities:
  - name: transaction
    type: primary
    expr: id_transaction
  - name: order
    type: foreign
    expr: id_order
  - name: user
    type: foreign
    expr: substring(id_order from 2)
```

## Объединение столбцов с ключом

Если таблица не имеет никакого ключа (например, первичного ключа), используйте _суррогатное объединение_, чтобы сформировать ключ, который поможет вам идентифицировать запись, комбинируя два столбца. Это применимо к любому [типу сущности](/docs/build/entities#entity-types). Например, вы можете объединить `date_key` и `brand_code` из таблицы `raw_brand_target_weekly`, чтобы сформировать _суррогатный ключ_. Следующий пример создает суррогатный ключ, объединяя `date_key` и `brand_code`, используя символ вертикальной черты (`|`) в качестве разделителя. 

```yaml

entities:
  - name: brand_target_key # Имя сущности или идентификатор.
    type: foreign # Это может быть любой тип сущности. 
    expr: date_key || '|' || brand_code # Определяет выражение для связывания полей для формирования суррогатного ключа.
```