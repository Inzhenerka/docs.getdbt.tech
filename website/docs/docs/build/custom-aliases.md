---
title: "Пользовательские псевдонимы"
description: "Прочитайте этот учебник, чтобы узнать, как использовать пользовательские псевдонимы при работе с dbt."
id: "custom-aliases"
---

## Обзор

Когда dbt выполняет модель, он обычно создает отношение (либо <Term id="table" />, либо <Term id="view" />) в базе данных, за исключением случая [эпhemeral model](/docs/build/materializations), когда он создает <Term id="cte" /> для использования в другой модели. По умолчанию dbt использует имя файла модели в качестве идентификатора для создаваемого отношения или CTE. Этот идентификатор можно переопределить с помощью конфигурации модели [`alias`](/reference/resource-configs/alias).

### Зачем использовать псевдонимы для имен моделей?
Имена схем и таблиц фактически являются "пользовательским интерфейсом" вашего <Term id="data-warehouse" />. Хорошо названные схемы и таблицы могут помочь обеспечить ясность и направление для потребителей этих данных. В сочетании с [пользовательскими схемами](/docs/build/custom-schemas) псевдонимизация моделей является мощным механизмом для проектирования вашего хранилища данных.

Схема именования файлов, которую вы используете для организации своих моделей, также может противоречить требованиям вашей платформы данных к идентификаторам. Например, вы можете захотеть использовать точку (`.`) для пространственного именования ваших файлов, но SQL-диалект вашей платформы данных может интерпретировать точки как разделители между именами схем и таблиц в идентификаторах или вообще запрещать использование точек в идентификаторах CTE. В таких случаях псевдонимизация моделей может позволить вам сохранить гибкость в именовании файлов моделей, не нарушая требований вашей платформы данных к идентификаторам.

### Использование
Конфигурация `alias` может быть использована для изменения имени идентификатора модели в базе данных. В следующей таблице показаны примеры идентификаторов базы данных для моделей как с предоставленным `alias`, так и без него, а также с различными материализациями.

| Модель | Конфигурация | Тип отношения | Идентификатор базы данных |
| ----- | ------ | --------------| ------------------- |
| ga_sessions.sql | \{\{ config(materialization='view') \}\} | <Term id="view" /> | "analytics"."ga_sessions" |
| ga_sessions.sql | \{\{ config(materialization='view', alias='sessions') \}\} | <Term id="view" /> | "analytics"."sessions" |
| ga_sessions.sql | \{\{ config(materialization='ephemeral') \}\} | <Term id="cte" /> | "\__dbt\__cte\__ga_sessions" |
| ga_sessions.sql | \{\{ config(materialization='ephemeral', alias='sessions') \}\} | <Term id="cte" /> | "\__dbt\__cte\__sessions" |

Чтобы настроить псевдоним для модели, укажите значение для параметра конфигурации `alias` модели. Например:

<File name='models/google_analytics/ga_sessions.sql'>

```sql

-- Эта модель будет создана в базе данных с идентификатором `sessions`
-- Обратите внимание, что в этом примере `alias` используется вместе с пользовательской схемой
{{ config(alias='sessions', schema='google_analytics') }}

select * from ...
```

</File>

Или в файле `schema.yml`.

<File name='models/google_analytics/schema.yml'>

```yaml
models:
  - name: ga_sessions
    config:
      alias: sessions
```

</File>

При обращении к модели `ga_sessions` выше из другой модели используйте функцию `ref()`, как обычно, с _именем файла_ модели. Например:

<File name='models/combined_sessions.sql'>

```sql

-- Используйте имя файла модели в ref, независимо от любых конфигураций псевдонимов

select * from {{ ref('ga_sessions') }}
union all
select * from {{ ref('snowplow_sessions') }}
```

</File>

### generate_alias_name

Псевдоним, сгенерированный для модели, контролируется макросом под названием `generate_alias_name`. Этот макрос можно переопределить в проекте dbt, чтобы изменить способ, которым dbt создает псевдонимы для моделей. Этот макрос работает аналогично макросу [generate_schema_name](/docs/build/custom-schemas#advanced-custom-schema-configuration).

Чтобы переопределить генерацию имен псевдонимов в dbt, создайте макрос с именем `generate_alias_name` в своем проекте dbt. Макрос `generate_alias_name` принимает два аргумента:

1. Пользовательский псевдоним, указанный в конфигурации модели
2. Узел, для которого генерируется пользовательский псевдоним

Стандартная реализация `generate_alias_name` просто использует указанный конфигурационный параметр `alias` (если он присутствует) в качестве псевдонима модели, в противном случае возвращается имя модели. Эта реализация выглядит следующим образом:

<File name='get_custom_alias.sql'>

```jinja2
{% macro generate_alias_name(custom_alias_name=none, node=none) -%}

    {%- if custom_alias_name -%}

        {{ custom_alias_name | trim }}

    {%- elif node.version -%}

        {{ return(node.name ~ "_v" ~ (node.version | replace(".", "_"))) }}

    {%- else -%}

        {{ node.name }}

    {%- endif -%}

{%- endmacro %}

```

</File>

import WhitespaceControl from '/snippets/_whitespace-control.md';

<WhitespaceControl/>

### Макрос диспетчеризации - управление SQL-псевдонимами для баз данных и пакетов dbt

Смотрите документацию по макросу `dispatch`: ["Управление различными глобальными переопределениями в пакетах"](/reference/dbt-jinja-functions/dispatch#managing-different-global-overrides-across-packages)

### Предостережения

#### Неоднозначные идентификаторы базы данных

Используя псевдонимы, можно случайно создать модели с неоднозначными идентификаторами. Учитывая следующие две модели, dbt попытается создать два <Term id="view">представления</Term> с _точно_ такими же именами в базе данных (т.е. `sessions`):

<File name='models/snowplow_sessions.sql'>

```sql
{{ config(alias='sessions') }}

select * from ...
```
</File>

<File name='models/sessions.sql'>

```sql
select * from ...
```

</File>

Модель, которая выполнится второй, "выиграет", и, как правило, вывод dbt не будет таким, как вы ожидали. Чтобы избежать этого режима сбоя, dbt проверит, являются ли ваши имена моделей и псевдонимы по своей природе неоднозначными. Если это так, вы получите сообщение об ошибке, подобное этому:

```
$ dbt compile
Обнаружена ошибка:
Ошибка компиляции
  dbt нашел два ресурса с представлением базы данных "analytics.sessions".
  dbt не может создать два ресурса с идентичными представлениями базы данных. Чтобы исправить это,
  измените конфигурацию "schema" или "alias" одного из этих ресурсов:
  - model.my_project.snowplow_sessions (models/snowplow_sessions.sql)
  - model.my_project.sessions (models/sessions.sql)
```

Если эти модели действительно должны иметь одинаковый идентификатор базы данных, вы можете обойти эту ошибку, настроив [пользовательскую схему](/docs/build/custom-schemas) для одной из моделей.

#### Версии моделей

**Связанная документация:**
- [Версии моделей](/docs/collaborate/govern/model-versions)
- [`versions`](/reference/resource-properties/versions#alias)

По умолчанию dbt будет создавать версии моделей с псевдонимом `<model_name>_v<v>`, где `<v>` - это уникальный идентификатор этой версии. Вы можете настроить это поведение так же, как и для неверсированных моделей, настроив пользовательский `alias` или переопределив макрос `generate_alias_name`.