---
title: "Модульные тесты"
sidebar_label: "Модульные тесты"
description: "Узнайте, как использовать модульные тесты для ваших SQL моделей."
search_weight: "heavy"
id: "unit-tests"
keywords:
  - модульный тест, модульные тесты, модульное тестирование, dag
---

:::note 

Функциональность модульного тестирования доступна в [dbt Cloud Release Tracks](/docs/dbt-versions/cloud-release-tracks) или dbt Core v1.8+

:::

Исторически, тестирование в dbt ограничивалось [“данными” тестами](/docs/build/data-tests), которые оценивали качество входных данных или структуру результирующих наборов данных. Однако эти тесты могли выполняться _только после_ построения модели.

Начиная с dbt Core v1.8, мы ввели дополнительный тип теста в dbt - модульные тесты. В программировании модульные тесты проверяют небольшие части вашего функционального кода, и они работают аналогичным образом здесь. Модульные тесты позволяют вам проверять логику моделирования SQL на небольшом наборе статических входных данных _до_ того, как вы материализуете вашу полную модель в производственной среде. Модульные тесты способствуют разработке, ориентированной на тестирование, что повышает эффективность разработчиков и надежность кода.

## Перед началом

- В настоящее время мы поддерживаем только модульное тестирование SQL моделей.
- В настоящее время мы поддерживаем добавление модульных тестов только к моделям в вашем _текущем_ проекте.
- В настоящее время мы _не_ поддерживаем модульное тестирование моделей, использующих материализацию [`materialized view`](/docs/build/materializations#materialized-view).
- В настоящее время мы _не_ поддерживаем модульное тестирование моделей, использующих рекурсивный SQL.
- В настоящее время мы _не_ поддерживаем модульное тестирование моделей, использующих интроспективные запросы.
- Если у вашей модели есть несколько версий, по умолчанию модульный тест будет выполняться на *всех* версиях вашей модели. Читайте [модульное тестирование версионированных моделей](/reference/resource-properties/unit-testing-versions) для получения дополнительной информации.
- Модульные тесты должны быть определены в YML файле в вашем [`models/` каталоге](/reference/project-configs/model-paths).
- Имена таблиц должны быть алиасированы для тестирования логики `join`.
- Включите все ссылки на [`ref`](/reference/dbt-jinja-functions/ref) или [`source`](/reference/dbt-jinja-functions/source) модели в конфигурацию модульного теста как `input`, чтобы избежать ошибок "узел не найден" во время компиляции.

#### Специфические ограничения адаптера
- Вы должны указать все поля в `STRUCT` BigQuery в модульном тесте. Нельзя использовать только подмножество полей в `STRUCT`.
- Клиенты Redshift должны быть в курсе [ограничения при создании модульных тестов](/reference/resource-configs/redshift-configs#unit-test-limitations), которое требует обходного пути.

Читать [документацию по ссылкам](/reference/resource-properties/unit-tests) для получения более подробной информации о форматировании ваших модульных тестов.

### Когда добавлять модульный тест к вашей модели

Вы должны проводить модульное тестирование модели:
- Когда ваш SQL содержит сложную логику:
    - Regex
    - Математика дат
    - Оконные функции
    - `case when` выражения, когда много `when`
    - Урезание
- Когда вы пишете пользовательскую логику для обработки входных данных, аналогично созданию функции.
- Мы не рекомендуем проводить модульное тестирование для таких функций, как `min()`, так как эти функции тестируются обширно хранилищем данных. Если возникает неожиданная проблема, скорее всего, это результат проблем в исходных данных, а не самой функции. Поэтому фиктивные данные в модульном тесте не предоставят ценной информации.
- Логика, по которой ранее были сообщены ошибки.
- Краевые случаи, которые еще не встречались в ваших фактических данных и которые вы хотите обработать.
- Перед рефакторингом логики трансформации (особенно если рефакторинг значительный).
- Модели с высокой "критичностью" (публичные, контрактные модели или модели, находящиеся непосредственно выше в цепочке поставок).

### Когда запускать модульные тесты

dbt Labs настоятельно рекомендует запускать модульные тесты только в средах разработки или CI. Поскольку входные данные модульных тестов статичны, нет необходимости использовать дополнительные вычислительные циклы для их выполнения в производственной среде. Используйте их в разработке для подхода, ориентированного на тестирование, и в CI, чтобы убедиться, что изменения не нарушают их.

Используйте флаг [типа ресурса](/reference/global-configs/resource-type) `--exclude-resource-type` или переменную окружения `DBT_EXCLUDE_RESOURCE_TYPES`, чтобы исключить модульные тесты из ваших производственных сборок и сэкономить вычислительные ресурсы.

## Модульное тестирование модели

Этот пример создает новую модель `dim_customers` с полем `is_valid_email_address`, которое вычисляет, является ли электронная почта клиента действительной: 

<file name='dim_customers.sql'>

```sql
with customers as (

    select * from {{ ref('stg_customers') }}

),

accepted_email_domains as (

    select * from {{ ref('top_level_email_domains') }}

),
	
check_valid_emails as (

    select
        customers.customer_id,
        customers.first_name,
        customers.last_name,
        customers.email,
	      coalesce (regexp_like(
            customers.email, '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}$'
        )
        = true
        and accepted_email_domains.tld is not null,
        false) as is_valid_email_address
    from customers
		left join accepted_email_domains
        on customers.email_top_level_domain = lower(accepted_email_domains.tld)

)

select * from check_valid_emails
```
</file>

Логику, представленную в этом примере, может быть сложно проверить. Вы можете добавить модульный тест к этой модели, чтобы убедиться, что логика `is_valid_email_address` охватывает все известные крайние случаи: электронные письма без `.`, электронные письма без `@` и электронные письма из недействительных доменов.

<file name='dbt_project.yml'> 

```yaml
unit_tests:
  - name: test_is_valid_email_address
    description: "Проверка логики is_valid_email_address на наличие всех известных крайних случаев - электронные письма без ., электронные письма без @ и электронные письма из недействительных доменов."
    model: dim_customers
    given:
      - input: ref('stg_customers')
        rows:
          - {email: cool@example.com,    email_top_level_domain: example.com}
          - {email: cool@unknown.com,    email_top_level_domain: unknown.com}
          - {email: badgmail.com,        email_top_level_domain: gmail.com}
          - {email: missingdot@gmailcom, email_top_level_domain: gmail.com}
      - input: ref('top_level_email_domains')
        rows:
          - {tld: example.com}
          - {tld: gmail.com}
    expect:
      rows:
        - {email: cool@example.com,    is_valid_email_address: true}
        - {email: cool@unknown.com,    is_valid_email_address: false}
        - {email: badgmail.com,        is_valid_email_address: false}
        - {email: missingdot@gmailcom, is_valid_email_address: false}

```
</file>

В предыдущем примере фиктивные данные определяются с использованием встроенного формата `dict`, но вы также можете использовать `csv` или `sql`, как встроенные, так и в отдельном файле фикстуры. Храните ваши файлы фикстур в подкаталоге `fixtures` в любом из ваших [путей тестирования](/reference/project-configs/test-paths). Например, `tests/fixtures/my_unit_test_fixture.sql`. 

При использовании формата `dict` или `csv` вам нужно определить фиктивные данные только для столбцов, которые вам важны. Это позволяет вам писать лаконичные и _специфические_ модульные тесты.

:::note

Прямые родительские модели, которые вы тестируете (в этом примере, `stg_customers` и `top_level_email_domains`), должны существовать в хранилище данных, прежде чем вы сможете выполнить модульный тест.

Используйте флаг [`--empty`](/reference/commands/build#the---empty-flag), чтобы построить пустую версию моделей и сэкономить затраты на хранилище данных. 

```bash

dbt run --select "stg_customers top_level_email_domains" --empty

```

Или используйте `dbt build`, чтобы, в порядке наследования:

- Запустить модульные тесты на вашей модели.
- Материализовать вашу модель в хранилище данных.
- Запустить тесты данных на вашей модели.

:::

Теперь вы готовы запустить этот модульный тест. У вас есть несколько вариантов команд в зависимости от того, насколько конкретным вы хотите быть: 

- `dbt test --select dim_customers` запускает _все_ тесты на `dim_customers`.
- `dbt test --select "dim_customers,test_type:unit"` запускает все _модульные_ тесты на `dim_customers`.
- `dbt test --select test_is_valid_email_address` запускает тест с именем `test_is_valid_email_address`.

```shell

dbt test --select test_is_valid_email_address
16:03:49  Запуск с dbt=1.8.0-a1
16:03:49  Зарегистрированный адаптер: postgres=1.8.0-a1
16:03:50  Найдено 6 моделей, 5 семян, 4 теста данных, 0 источников, 0 экспозиций, 0 метрик, 410 макросов, 0 групп, 0 семантических моделей, 1 модульный тест
16:03:50  
16:03:50  Параллелизм: 5 потоков (target='postgres')
16:03:50  
16:03:50  1 из 1 НАЧАЛО модульного теста dim_customers::test_is_valid_email_address ................... [RUN]
16:03:51  1 из 1 НЕУДАЧА 1 dim_customers::test_is_valid_email_address ............................ [FAIL 1 за 0.26s]
16:03:51  
16:03:51  Завершено выполнение 1 модульного теста за 0 часов 0 минут и 0.67 секунд (0.67s).
16:03:51  
16:03:51  Завершено с 1 ошибкой и 0 предупреждениями:
16:03:51  
16:03:51  Ошибка в модульном тесте test_is_valid_email_address (models/marts/unit_tests.yml)
16:03:51    

фактическое значение отличается от ожидаемого:

@@ ,email           ,is_valid_email_address
→  ,cool@example.com,True→False
   ,cool@unknown.com,False
...,...             ,...


16:03:51  
16:03:51    скомпилированный код в models/marts/unit_tests.yml
16:03:51  
16:03:51  Готово. PASS=0 WARN=0 ERROR=1 SKIP=0 TOTAL=1

```

Умное выражение regex оказалось не таким умным, как предполагалось изначально, так как модель неверно отметила `cool@example.com` как недействительный адрес электронной почты.

Обновление логики regex на `'^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'` (эти надоедливые символы экранирования) и повторный запуск модульного теста решает проблему:

```shell

dbt test --select test_is_valid_email_address
16:09:11  Запуск с dbt=1.8.0-a1
16:09:12  Зарегистрированный адаптер: postgres=1.8.0-a1
16:09:12  Найдено 6 моделей, 5 семян, 4 теста данных, 0 источников, 0 экспозиций, 0 метрик, 410 макросов, 0 групп, 0 семантических моделей, 1 модульный тест
16:09:12  
16:09:13  Параллелизм: 5 потоков (target='postgres')
16:09:13  
16:09:13  1 из 1 НАЧАЛО модульного теста dim_customers::test_is_valid_email_address ................... [RUN]
16:09:13  1 из 1 УСПЕХ dim_customers::test_is_valid_email_address .............................. [PASS за 0.26s]
16:09:13  
16:09:13  Завершено выполнение 1 модульного теста за 0 часов 0 минут и 0.75 секунд (0.75s).
16:09:13  
16:09:13  Завершено успешно
16:09:13  
16:09:13  Готово. PASS=1 WARN=0 ERROR=0 SKIP=0 TOTAL=1

```

Ваша модель теперь готова к производству! Добавление этого модульного теста помогло выявить проблему с логикой SQL _до_ того, как вы материализовали `dim_customers` в вашем хранилище данных и лучше обеспечит надежность этой модели в будущем. 

## Модульное тестирование инкрементальных моделей

При настройке вашего модульного теста вы можете переопределить вывод макросов, переменных или переменных окружения. Это позволяет вам модульно тестировать ваши инкрементальные модели в режимах "полного обновления" и "инкрементального".

При тестировании инкрементальной модели ожидаемый вывод - это __результат материализации__ (что будет объединено/вставлено), а не сама результирующая модель (как будет выглядеть финальная таблица после объединения/вставки).

Например, предположим, у вас есть инкрементальная модель в вашем проекте:

<File name='my_incremental_model.sql'>

```sql

{{
    config(
        materialized='incremental'
    )
}}

select * from {{ ref('events') }}
{% if is_incremental() %}
where event_time > (select max(event_time) from {{ this }})
{% endif %}

```

</File>

Вы можете определить модульные тесты для `my_incremental_model`, чтобы убедиться, что ваша инкрементальная логика работает как ожидалось:

```yml

unit_tests:
  - name: my_incremental_model_full_refresh_mode
    model: my_incremental_model
    overrides:
      macros:
        # модульный тест этой модели в режиме "полного обновления"
        is_incremental: false 
    given:
      - input: ref('events')
        rows:
          - {event_id: 1, event_time: 2020-01-01}
    expect:
      rows:
        - {event_id: 1, event_time: 2020-01-01}

  - name: my_incremental_model_incremental_mode
    model: my_incremental_model
    overrides:
      macros:
        # модульный тест этой модели в режиме "инкрементального"
        is_incremental: true 
    given:
      - input: ref('events')
        rows:
          - {event_id: 1, event_time: 2020-01-01}
          - {event_id: 2, event_time: 2020-01-02}
          - {event_id: 3, event_time: 2020-01-03}
      - input: this 
        # содержимое текущей my_incremental_model
        rows:
          - {event_id: 1, event_time: 2020-01-01}
    expect:
      # что будет вставлено/объединено в my_incremental_model
      rows:
        - {event_id: 2, event_time: 2020-01-02}
        - {event_id: 3, event_time: 2020-01-03}

```

В настоящее время нет способа модульно тестировать, правильно ли dbt вставил/объединил записи в вашу существующую модель, но [мы исследуем поддержку этого в будущем](https://github.com/dbt-labs/dbt-core/issues/8664).

## Модульное тестирование модели, зависящей от эфемерных моделей

Если вы хотите модульно протестировать модель, которая зависит от эфемерной модели, вы должны использовать `format: sql` для этого входа.

```yml
unit_tests:
  - name: my_unit_test
    model: dim_customers
    given:
      - input: ref('ephemeral_model')
        format: sql
        rows: |
          select 1 as id, 'emily' as name
    expect:
      rows:
        - {id: 1, first_name: emily}
```

## Код выхода модульного теста

Успехи и неудачи модульных тестов представлены двумя кодами выхода:
- Успех (0)
- Неудача (1)

Коды выхода отличаются от успехов и неудач тестов данных, поскольку они не отражают напрямую неудачные тесты данных. Тесты данных - это запросы, предназначенные для проверки конкретных условий в ваших данных, и они возвращают одну строку на каждый случай неудачи теста (например, количество значений с дубликатами для теста `unique`). dbt сообщает количество неудачных записей как неудачи. В то время как каждый модульный тест представляет собой один 'тестовый случай', поэтому результаты всегда 0 (успех) или 1 (неудача), независимо от того, сколько записей не удалось в этом тестовом случае.

Узнайте о [кодах выхода](/reference/exit-codes) для получения дополнительной информации.

## Дополнительные ресурсы

- [Страница справки по модульному тестированию](/reference/resource-properties/unit-tests)
- [Поддерживаемые форматы данных для фиктивных данных](/reference/resource-properties/data-formats)
- [Модульное тестирование версионированных моделей](/reference/resource-properties/unit-testing-versions)
- [Входные данные модульного теста](/reference/resource-properties/unit-test-input)
- [Переопределения модульного теста](/reference/resource-properties/unit-test-overrides)
- [Специфические типы данных платформы](/reference/resource-properties/data-types)
