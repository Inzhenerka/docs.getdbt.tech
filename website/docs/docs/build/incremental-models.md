---
title: "Настройка инкрементных моделей"
description: "Узнайте, как настраивать инкрементные модели при работе с dbt."
id: "incremental-models"
keywords: ["инкрементные модели", "инкрементная материализация", "инкрементный", "материализация", "инкрементная модель", "инкрементная стратегия", "настройка инкрементной модели"]
---

Инкрементные модели создаются в виде таблиц в вашем <Term id="data-warehouse" />. При первом запуске модели таблица <Term id="table" /> создается путем преобразования _всех_ строк исходных данных. При последующих запусках dbt преобразует _только_ те строки в ваших исходных данных, которые вы укажете для фильтрации, вставляя их в целевую таблицу, которая уже была создана.

Часто строки, которые вы фильтруете при инкрементном запуске, будут строками в ваших исходных данных, которые были созданы или обновлены с момента последнего запуска dbt. Таким образом, при каждом запуске dbt ваша модель строится инкрементально.

Использование инкрементной модели ограничивает объем данных, которые необходимо преобразовать, значительно сокращая время выполнения ваших преобразований. Это улучшает производительность хранилища и снижает затраты на вычисления.

## Настройка инкрементных материализаций

Как и другие <Term id="materialization">материализации</Term>, встроенные в dbt, инкрементные модели определяются с помощью операторов `select`, при этом материализация определяется в блоке конфигурации.
```sql
{{
    config(
        materialized='incremental'
    )
}}

select ...

```

Чтобы использовать инкрементные модели, вам также нужно сообщить dbt:

* Как фильтровать строки при инкрементном запуске
* Уникальный ключ модели (если он есть)

### Понимание макроса is_incremental()

Макрос `is_incremental()` управляет инкрементными материализациями. Он вернет `True`, если выполнены _все_ следующие условия:

- Модель уже должна существовать в базе данных
- Целевая таблица уже существует в базе данных
- Флаг `full-refresh` _не_ передан
- Запускаемая модель настроена с `materialized='incremental'`

Обратите внимание, что SQL в вашей модели должен быть действительным независимо от того, возвращает ли `is_incremental()` значение `True` или `False`.

### Фильтрация строк при инкрементном запуске

Чтобы сообщить dbt, какие строки он должен преобразовать при инкрементном запуске, оберните действительный SQL, который фильтрует эти строки, в макрос `is_incremental()`.

Часто вы захотите фильтровать "новые" строки, то есть строки, которые были созданы с момента последнего запуска dbt этой модели. Лучший способ найти временную метку последнего запуска этой модели — проверить самую последнюю временную метку в вашей целевой таблице. dbt упрощает запрос вашей целевой таблицы, используя переменную "[\{\{ this \}\}](/reference/dbt-jinja-functions/this)".

Также часто возникает необходимость захватить как новые, так и обновленные записи. Для обновленных записей вам нужно [определить уникальный ключ](#defining-a-unique-key-optional), чтобы гарантировать, что вы не добавите измененные записи как дубликаты. Ваш код `is_incremental()` будет проверять строки, созданные *или измененные* с момента последнего запуска dbt этой модели.

Например, модель, которая включает вычислительно медленное преобразование по столбцу, может быть построена инкрементально следующим образом:

<File name='models/stg_events.sql'>

```sql
{{
    config(
        materialized='incremental'
    )
}}

select
    *,
    my_slow_function(my_column)

from {{ ref('app_data_events') }}

{% if is_incremental() %}

  -- этот фильтр будет применен только при инкрементном запуске
  -- (использует >=, чтобы включить записи, временная метка которых произошла с момента последнего запуска этой модели)
  -- (Если event_time равно NULL или таблица обрезана, условие всегда будет истинным и загрузит все записи)
where event_time >= (select coalesce(max(event_time),'1900-01-01') from {{ this }} )

{% endif %}
```

</File>

:::tip Оптимизация вашей инкрементной модели

Для более сложных инкрементных моделей, использующих Общие Табличные Выражения (CTE), вам следует учитывать влияние позиции макроса `is_incremental()` на производительность запроса. В некоторых хранилищах фильтрация ваших записей на раннем этапе может значительно улучшить время выполнения вашего запроса!

:::

### Определение уникального ключа (необязательно)

Параметр `unique_key` позволяет обновлять существующие строки вместо того, чтобы просто добавлять новые строки. Если новая информация поступает для существующего `unique_key`, эта новая информация может заменить текущую информацию, а не добавляться в таблицу. Если поступает дублирующая строка, она может быть проигнорирована. Обратитесь к [конфигурациям, специфичным для стратегии](/docs/build/incremental-strategy#strategy-specific-configs) для получения дополнительных вариантов управления этим поведением обновления, например, выбора только определенных столбцов для обновления.

Не указание `unique_key` приведет к поведению только добавления, что означает, что dbt вставляет все строки, возвращаемые SQL модели, в уже существующую целевую таблицу, не учитывая, представляют ли строки дубликаты.

Необязательный параметр `unique_key` указывает поле (или комбинацию полей), которое определяет зерно вашей модели. То есть, поле(я) идентифицируют одну уникальную строку. Вы можете определить `unique_key` в блоке конфигурации в верхней части вашей модели, и это может быть одно имя столбца или список имен столбцов.

`unique_key` должен быть указан в определении вашей модели как строка, представляющая один столбец или список имен столбцов в одинарных кавычках, которые могут использоваться вместе, например, `['col1', 'col2', …])`. Столбцы, используемые таким образом, не должны содержать никаких значений NULL, иначе инкрементная модель может не сопоставить строки и сгенерировать дублирующие строки. Либо убедитесь, что каждый столбец не содержит NULL (например, с помощью `coalesce(COLUMN_NAME, 'VALUE_IF_NULL')`), либо определите одно-столбцовый [суррогатный ключ](https://www.getdbt.com/blog/guide-to-surrogate-key) (например, с помощью [`dbt_utils.generate_surrogate_key`](https://github.com/dbt-labs/dbt-utils#generate_surrogate_key-source)).

:::tip
В случаях, когда вам нужно несколько столбцов в комбинации для уникальной идентификации каждой строки, мы рекомендуем передавать эти столбцы в виде списка (`unique_key = ['user_id', 'session_number']`), а не в виде строкового выражения (`unique_key = 'concat(user_id, session_number)'`).

Используя первый синтаксис, который более универсален, dbt может гарантировать, что столбцы будут шаблонизированы в вашей инкрементной модели материализации таким образом, который подходит для вашей базы данных.
    
При передаче списка таким образом, пожалуйста, убедитесь, что каждый столбец не содержит никаких значений NULL, иначе выполнение инкрементной модели может завершиться неудачей.
   
В качестве альтернативы вы можете определить одно-столбцовый [суррогатный ключ](https://www.getdbt.com/blog/guide-to-surrogate-key), например, с помощью [`dbt_utils.generate_surrogate_key`](https://github.com/dbt-labs/dbt-utils#generate_surrogate_key-source).
:::

Когда вы определяете `unique_key`, вы увидите следующее поведение для каждой строки "новых" данных, возвращаемых вашей моделью dbt:

* Если тот же `unique_key` присутствует в "новых" и "старых" данных модели, dbt обновит/заменит старую строку новой строкой данных. Точные механизмы того, как происходит это обновление/замена, будут варьироваться в зависимости от вашей базы данных, [инкрементальной стратегии](/docs/build/incremental-strategy) и [конфигураций, специфичных для стратегии](/docs/build/incremental-strategy#strategy-specific-configs).
* Если `unique_key` _не_ присутствует в "старых" данных, dbt вставит всю строку в таблицу.

Обратите внимание, что если существует `unique_key` с более чем одной строкой как в существующей целевой таблице, так и в новых инкрементных строках, инкрементная модель может завершиться неудачей в зависимости от вашей базы данных и [инкрементальной стратегии](/docs/build/incremental-strategy). Если у вас возникают проблемы с запуском инкрементной модели, разумно дважды проверить, что уникальный ключ действительно уникален как в вашей существующей таблице базы данных, так и в ваших новых инкрементных строках. Вы можете [узнать больше о суррогатных ключах здесь](https://www.getdbt.com/blog/guide-to-surrogate-key).

:::info
Хотя общие инкрементные стратегии, такие как `delete+insert` + `merge`, могут использовать `unique_key`, другие этого не делают. Например, стратегия `insert_overwrite` не использует `unique_key`, потому что она работает с разделами данных, а не с отдельными строками. Для получения дополнительной информации см. [О инкрементальной стратегии](/docs/build/incremental-strategy).
:::

#### Пример `unique_key`

Рассмотрим модель, которая вычисляет количество активных пользователей за день (DAU), основываясь на потоке событий. По мере поступления исходных данных вы захотите пересчитать количество DAU как для дня, когда dbt в последний раз запускался, так и для любых дней с тех пор. Модель будет выглядеть следующим образом:

<File name='models/staging/fct_daily_active_users.sql'>

```sql
{{
    config(
        materialized='incremental',
        unique_key='date_day'
    )
}}

select
    date_trunc('day', event_at) as date_day,
    count(distinct user_id) as daily_active_users

from {{ ref('app_data_events') }}


{% if is_incremental() %}

  -- этот фильтр будет применен только при инкрементном запуске
  -- (использует >=, чтобы включить записи, поступающие позже в тот же день, что и последний запуск этой модели)
  where date_day >= (select coalesce(max(date_day), '1900-01-01') from {{ this }})

{% endif %}

group by 1
```

</File>

Построение этой модели инкрементально без параметра `unique_key` приведет к множественным строкам в целевой таблице для одного дня – одна строка для каждого запуска dbt в этот день. Вместо этого включение параметра `unique_key` гарантирует, что существующая строка будет обновлена.

## Как мне восстановить инкрементную модель?
Если логика вашей инкрементной модели изменилась, преобразования ваших новых строк данных могут отличаться от исторических преобразований, которые хранятся в вашей целевой таблице. В этом случае вам следует восстановить вашу инкрементную модель.

Чтобы заставить dbt восстановить всю инкрементную модель с нуля, используйте флаг `--full-refresh` в командной строке. Этот флаг заставит dbt удалить существующую целевую таблицу в базе данных перед ее восстановлением для всех времён. 

```bash
$ dbt run --full-refresh --select my_incremental_model+
```

Также рекомендуется восстановить любые последующие модели, как указано знаком `+`.

Вы также можете использовать [`full_refresh config`](/reference/resource-configs/full_refresh), чтобы установить ресурс для всегда или никогда не выполнять полное обновление на уровне проекта или ресурса. Если указано как true или false, конфигурация `full_refresh` будет иметь приоритет над наличием или отсутствием флага `--full-refresh`.

Для получения подробных инструкций по использованию ознакомьтесь с документацией по [dbt run](/reference/commands/run). 

## Что если столбцы моей инкрементной модели изменятся?

Инкрементные модели могут быть настроены для включения необязательного параметра `on_schema_change`, чтобы обеспечить дополнительный контроль, когда столбцы инкрементной модели изменяются. Эти параметры позволяют dbt продолжать запуск инкрементных моделей в условиях изменений схемы, что приводит к меньшему количеству сценариев `--full-refresh` и экономии затрат на запросы. 

Вы можете настроить параметр `on_schema_change` следующим образом.

<File name='dbt_project.yml'>

```yaml
models:
  +on_schema_change: "sync_all_columns"
```

</File>

<File name='models/staging/fct_daily_active_users.sql'>

```sql
{{
    config(
        materialized='incremental',
        unique_key='date_day',
        on_schema_change='fail'
    )
}}
```

</File>

Возможные значения для `on_schema_change`:

* `ignore`: Поведение по умолчанию (см. ниже).
* `fail`: Вызывает сообщение об ошибке, когда схемы источника и цели расходятся  
* `append_new_columns`: Добавляет новые столбцы в существующую таблицу. Обратите внимание, что эта настройка *не* удаляет столбцы из существующей таблицы, которые отсутствуют в новых данных.
* `sync_all_columns`: Добавляет любые новые столбцы в существующую таблицу и удаляет любые столбцы, которые теперь отсутствуют. Обратите внимание, что это *включает* изменения типов данных. В BigQuery изменение типов столбцов требует полного <Term id="table" /> сканирования; будьте внимательны к компромиссам при реализации.

**Примечание**: Ни одно из поведений `on_schema_change` не заполняет значения в старых записях для вновь добавленных столбцов. Если вам нужно заполнить эти значения, мы рекомендуем выполнять ручные обновления или инициировать `--full-refresh`.

:::caution `on_schema_change` отслеживает изменения верхнего уровня

В настоящее время `on_schema_change` отслеживает только изменения столбцов верхнего уровня. Он не отслеживает изменения вложенных столбцов. Например, в BigQuery добавление, удаление или изменение вложенного столбца не вызовет изменения схемы, даже если `on_schema_change` установлен соответствующим образом.

:::

### Поведение по умолчанию

Это поведение `on_schema_change: ignore`, которое установлено по умолчанию.

Если вы добавите столбец в свою инкрементную модель и выполните `dbt run`, этот столбец _не_ появится в вашей целевой таблице.

Если вы удалите столбец из своей инкрементной модели и выполните `dbt run`, `dbt run` завершится неудачей.

Вместо этого, всякий раз, когда логика вашей инкрементной модели изменяется, выполните полное обновление как для вашей инкрементной модели, так и для любых последующих моделей.

<Snippet path="discourse-help-feed-header" />
<DiscourseHelpFeed tags="incremental"/>