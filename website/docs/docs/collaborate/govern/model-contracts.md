---
title: "Контракты моделей"
id: model-contracts
sidebar_label: "Контракты моделей"
description: "Контракты моделей определяют набор параметров, проверяемых во время трансформации"
---

## Связанная документация
* [`contract`](/reference/resource-configs/contract)
* [`columns`](/reference/resource-properties/columns)
* [`constraints`](/reference/resource-properties/constraints)

## Зачем определять контракт?

Определение модели dbt так же просто, как написание SQL-запроса `select`. Ваш запрос естественным образом создает набор данных с именами и типами столбцов на основе выбранных вами столбцов и применяемых трансформаций.

Хотя это идеально подходит для быстрого и итеративного развития, для некоторых моделей постоянное изменение структуры возвращаемого набора данных представляет риск, когда другие люди и процессы запрашивают эту модель. Лучше определить набор заранее заданных "гарантий", которые определяют структуру вашей модели. Мы называем этот набор гарантий "контрактом". При создании вашей модели dbt будет проверять, что трансформация вашей модели создаст набор данных, соответствующий ее контракту, или она не сможет построить модель.

## Где поддерживаются контракты?

В настоящее время контракты моделей поддерживаются для:
- SQL моделей.
- Моделей, материализованных как одна из следующих:
    - `table`
    - `view` &mdash; Представления предлагают ограниченную поддержку для имен столбцов и типов данных, но не для `constraints`.
    - `incremental` &mdash; с `on_schema_change: append_new_columns` или `on_schema_change: fail`.  
- Определенных платформ данных, но поддерживаемые и применяемые `constraints` различаются в зависимости от платформы.

Контракты моделей _не_ поддерживаются для:
- Python моделей.
- `materialized view` или `ephemeral`-материализованных SQL моделей.
- Пользовательских материализаций (если они не добавлены автором).
- Моделей с рекурсивными <Term id="cte" /> в BigQuery.
- Других типов ресурсов, таких как `sources`, `seeds`, `snapshots` и так далее.

## Как определить контракт

Предположим, у вас есть модель с запросом, подобным следующему:

<File name="models/marts/dim_customers.sql">

```sql
-- много SQL

final as (

    select
        customer_id,
        customer_name,
        -- ... много других ...
    from ...

)

select * from final
```

</File>

Чтобы обеспечить соблюдение контракта модели, установите `enforced: true` в конфигурации `contract`.

При соблюдении контракта ваш контракт _должен_ включать `name` и `data_type` для каждого столбца (где `data_type` соответствует тому, который понимает ваша платформа данных).

Если ваша модель материализована как `table` или `incremental`, в зависимости от вашей платформы данных, вы можете дополнительно указать [constraints](/reference/resource-properties/constraints), такие как `not_null` (содержащий ноль значений null).

<File name="models/marts/customers.yml">

```yaml
models:
  - name: dim_customers
    config:
      contract:
        enforced: true
    columns:
      - name: customer_id
        data_type: int
        constraints:
          - type: not_null
      - name: customer_name
        data_type: string
      ...
```

</File>

При построении модели с определенным контрактом dbt будет делать две вещи иначе:
1. dbt выполнит проверку "предварительного полета", чтобы убедиться, что запрос модели вернет набор столбцов с именами и типами данных, соответствующими тем, которые вы определили. Эта проверка не зависит от порядка столбцов, указанных в вашей модели (SQL) или спецификации YAML.
2. dbt включит имена столбцов, типы данных и ограничения в DDL-операторы, которые он отправляет на платформу данных, которые будут применяться при создании или обновлении таблицы модели, и упорядочит столбцы в соответствии с контрактом, а не с вашей моделью dbt.

## Поддержка ограничений платформы

Выберите вкладку, специфичную для адаптера, для получения дополнительной информации о поддержке [constraints](/reference/resource-properties/constraints) на различных платформах. Ограничения делятся на три категории в зависимости от возможности определения и применения на платформе:

- **Определяемые и применяемые** &mdash; Модель не будет построена, если она нарушает ограничение.
- **Определяемые и не применяемые** &mdash; Платформа поддерживает указание типа ограничения, но модель все равно может быть построена, даже если при построении модели нарушается ограничение. Это ограничение существует только для целей метаданных. Этот подход более типичен для облачных хранилищ данных, чем для транзакционных баз данных, где строгая реализация правил более распространена.
- **Неопределяемые и не применяемые** &mdash; Вы не можете указать тип ограничения для платформы.

<Tabs>

<TabItem value="Redshift" label="Redshift">

| Тип ограничения | Определяемое       | Применяемое         |
|:----------------|:-------------:|:------------------:|
| not_null        | ✅ | ✅ |
| primary_key     | ✅ | ❌ |
| foreign_key     | ✅ | ❌ |
| unique          | ✅ | ❌ |
| check           | ❌ | ❌ |

</TabItem>
<TabItem value="Snowflake" label="Snowflake">

| Тип ограничения | Определяемое     | Применяемое |
|:----------------|:-------------:|:---------------------:|
| not_null        | ✅  | ✅ |
| primary_key     | ✅  | ❌ |
| foreign_key     | ✅  | ❌ |
| unique          | ✅  | ❌ |
| check           | ❌  | ❌ |

</TabItem>
<TabItem value="BigQuery" label="BigQuery">

| Тип ограничения | Определяемое     | Применяемое |
|:-----------------|:-------------:|:---------------------:|
| not_null        | ✅ | ✅  |
| primary_key     | ✅ | ❌  |
| foreign_key     | ✅ | ❌  |
| unique          | ❌ | ❌  |
| check           | ❌ | ❌  |

</TabItem>
<TabItem value="Postgres" label="Postgres">

| Тип ограничения | Определяемое     | Применяемое |
|:----------------|:-------------:|:--------------------:|
| not_null        | ✅  |	✅  |
| primary_key     | ✅  |	✅  |
| foreign_key     | ✅  |	✅  |
| unique          | ✅  |	✅  |
| check           | ✅  |	✅  |

</TabItem>
<TabItem value="Spark" label="Spark">

В настоящее время ограничения `not_null` и `check` применяются только после построения модели. Из-за этого ограничения платформы dbt считает эти ограничения определяемыми, но не применяемыми, что означает, что они не являются частью _контракта модели_, поскольку их нельзя применить во время построения. Эта таблица изменится по мере развития функций.

| Тип ограничения | Определяемое    | Применяемое |
|:----------------|:------------:|:---------------------:|
| not_null        |	✅  | ❌ |
| primary_key     |	✅  | ❌ |
| foreign_key     |	✅  | ❌ |
| unique          |	✅  | ❌ |
| check           |	✅  | ❌ |

</TabItem>
<TabItem value="Databricks" label="Databricks">

В настоящее время ограничения `not_null` и `check` применяются только после построения модели. Из-за этого ограничения платформы dbt считает эти ограничения определяемыми, но не применяемыми, что означает, что они не являются частью _контракта модели_, поскольку их нельзя применить во время построения. Эта таблица изменится по мере развития функций.

| Тип ограничения | Определяемое     | Применяемое |
|:----------------|:-------------:|:---------------------:|
| not_null        |	✅  | ❌ |
| primary_key     | ✅  | ❌ |
| foreign_key     |	✅  | ❌ |
| unique          |	✅  | ❌ |
| check           |	✅  | ❌ |

</TabItem>
</Tabs>

## Часто задаваемые вопросы

### Какие модели должны иметь контракты?

Любая модель, соответствующая описанным выше критериям, _может_ определить контракт. Мы рекомендуем определять контракты для ["публичных" моделей](model-access), на которые полагаются downstream.
- Внутри dbt: Делится с другими группами, другими командами и [другими проектами dbt](/best-practices/how-we-mesh/mesh-1-intro).
- Вне dbt: Отчеты, панели мониторинга или другие системы и процессы, которые ожидают, что эта модель будет иметь предсказуемую структуру. Вы можете отразить эти downstream использования с помощью [exposures](/docs/build/exposures).

### Чем контракты отличаются от тестов?

Контракт модели определяет **структуру** возвращаемого набора данных. Если логика модели или входные данные не соответствуют этой структуре, модель не строится.

[Тесты данных](/docs/build/data-tests) являются более гибким механизмом для проверки содержимого вашей модели _после_ ее построения. Пока вы можете написать запрос, вы можете запустить тест данных. Тесты данных более настраиваемы, например, с помощью [пользовательских порогов серьезности](/reference/resource-configs/severity). Их легче отлаживать после обнаружения сбоев, потому что вы можете запрашивать уже построенную модель или [сохранять неудачные записи в хранилище данных](/reference/resource-configs/store_failures).

В некоторых случаях вы можете заменить тест данных его эквивалентным ограничением. Это имеет преимущество в гарантии проверки во время построения и, вероятно, требует меньше вычислений (стоимости) на вашей платформе данных. Предпосылки для замены теста данных ограничением:
- Убедитесь, что ваша платформа данных может поддерживать и применять необходимое ограничение. Большинство платформ применяют только `not_null`.
- Материализуйте вашу модель как `table` или `incremental` (**не** `view` или `ephemeral`).
- Определите полный контракт для этой модели, указав `name` и `data_type` для каждого столбца.

**Почему тесты не являются частью контракта?** В параллели с API программного обеспечения структура ответа API является контрактом. Качество и надежность ("время безотказной работы") также являются очень важными атрибутами качества API, но они не являются частью контракта как такового. Когда контракт изменяется в несовместимом с предыдущими версиями направлении, это является нарушением, требующим увеличения основной версии.

### Нужно ли определять каждый столбец для контракта?

В настоящее время контракты dbt применяются ко **всем** столбцам, определенным в модели, и требуют явного указания ожиданий относительно **всех** этих столбцов. Явное объявление контракта не является случайностью — это очень намерение этой функции.

В то же время, для моделей с большим количеством столбцов мы понимаем, что это может означать _много_ yaml. Мы исследуем возможность поддержки "выводимых" контрактов. Это позволит вам определить ограничения и строгую типизацию данных для подмножества столбцов, при этом все еще обнаруживая нарушения на других столбцах, сравнивая с той же моделью в производстве. Это не то же самое, что "частичный" контракт, потому что все столбцы в модели все равно проверяются во время выполнения и сопоставляются с тем, что определено _явно_ в вашем yaml-контракте или _неявно_ с состоянием сравнения. Если вас интересует "выводимый" контракт, пожалуйста, проголосуйте или прокомментируйте [dbt-core#7432](https://github.com/dbt-labs/dbt-core/issues/7432).

### Как обрабатываются нарушения изменений?

При сравнении с предыдущим состоянием проекта dbt будет искать нарушения изменений, которые могут повлиять на downstream потребителей. Если нарушения изменений обнаружены, dbt представит ошибку контракта.

import BreakingChanges from '/snippets/_versions-contracts.md';

<BreakingChanges 
value="Удаление контракта модели путем его удаления, переименования или отключения (dbt v1.9 или выше)."
value2="Версионированные модели вызовут ошибку. Неверсионированные модели вызовут предупреждение."
/>

Более подробная информация доступна в [справочнике по контрактам](/reference/resource-configs/contract#detecting-breaking-changes).