---
title: "Зависимости проекта"
id: project-dependencies
sidebar_label: "Зависимости проекта"
description: "Справка по публичным моделям в разных проектах dbt"
pagination_next: null
keyword: dbt mesh, зависимости проекта, ref, кросс-проектный ref, зависимости проекта
---

На протяжении долгого времени dbt поддерживает повторное использование кода и его расширение путем установки других проектов в качестве [пакетов](/docs/build/packages). Когда вы устанавливаете другой проект в качестве пакета, вы получаете его полный исходный код и добавляете его в свой проект. Это позволяет вам вызывать макросы и запускать модели, определенные в этом другом проекте.

Хотя это отличный способ повторного использования кода, обмена утилитами и установления отправной точки для общих преобразований, это не самый эффективный способ для обеспечения сотрудничества между командами и в масштабах, особенно в крупных организациях.

В этом году dbt Labs вводит расширенное понятие `зависимостей` между несколькими проектами dbt:
- **Пакеты** &mdash; Знакомый и существующий тип зависимости. Вы берете эту зависимость, устанавливая полный исходный код пакета (как библиотеку программного обеспечения).
- **Проекты** &mdash; _Новый_ способ установить зависимость от другого проекта. Используя сервис метаданных, который работает в фоновом режиме, dbt Cloud разрешает ссылки на лету на публичные модели, определенные в других проектах. Вам не нужно самостоятельно парсить или запускать эти модели. Вместо этого вы рассматриваете свою зависимость от этих моделей как API, который возвращает набор данных. Ответственность за качество и стабильность публичной модели лежит на ее поддерживающем.

## Предварительные условия
- Доступно в [dbt Cloud Enterprise](https://www.getdbt.com/pricing). Если у вас есть учетная запись Enterprise, вы можете разблокировать эти функции, назначив [публичную модель](/docs/collaborate/govern/model-access) и добавив [кросс-проектный ref](#how-to-write-cross-project-ref). <Lifecycle status="enterprise"/>
- Определите модели в верхнем ("производящем") проекте, которые настроены с [`access: public`](/reference/resource-configs/access). Вам нужно хотя бы одно успешное выполнение задания после определения их `access`.
- Определите среду развертывания в верхнем ("производящем") проекте [которая установлена как ваша производственная среда](/docs/deploy/deploy-environments#set-as-production-environment), и убедитесь, что в этой среде было хотя бы одно успешное выполнение задания.
- Если в верхнем проекте есть среда Staging, выполните задание в этой среде Staging, чтобы убедиться, что кросс-проектный ref разрешается.
- Каждое имя проекта должно быть уникальным в вашей учетной записи dbt Cloud. Например, если у вас есть проект dbt (кодовая база) для команды `jaffle_marketing`, вы не должны создавать отдельные проекты для `Jaffle Marketing - Dev` и `Jaffle Marketing - Prod`. Эта изоляция должна обрабатываться на уровне среды.
  - Мы добавляем поддержку разрешений на уровне среды и соединений с хранилищем данных; пожалуйста, свяжитесь с вашей командой dbt Labs для получения доступа к бета-версии.
- Файл `dbt_project.yml` чувствителен к регистру, что означает, что имя проекта должно точно совпадать с именем в вашем `dependencies.yml`. Например, если ваше имя проекта `jaffle_marketing`, вы должны использовать `jaffle_marketing` (не `JAFFLE_MARKETING`) во всех связанных файлах.

## Пример

В качестве примера, предположим, что вы работаете в команде маркетинга в Jaffle Shop. Название проекта вашей команды — `jaffle_marketing`:

<File name="dbt_project.yml">

```yml
name: jaffle_marketing
```

</File>

В рамках моделирования маркетинговых данных вам нужно установить зависимость от двух других проектов:
- `dbt_utils` в качестве [пакета](#packages-use-case): Коллекция утилитных макросов, которые вы можете использовать при написании SQL для своих моделей. Этот пакет является открытым и поддерживается dbt Labs.
- `jaffle_finance` в качестве [проектного случая использования](#projects-use-case): Модели данных о доходах Jaffle Shop. Этот проект является частным и поддерживается вашими коллегами из финансовой команды. Вы хотите выбрать некоторые из финальных моделей этого проекта в качестве отправной точки для своей работы.

<File name="dependencies.yml">

```yml
packages:
  - package: dbt-labs/dbt_utils
    version: 1.1.1

projects:
  - name: jaffle_finance  # чувствительно к регистру и совпадает с 'name' в 'dbt_project.yml'
```

</File>

Что здесь происходит?

Пакет `dbt_utils` &mdash; Когда вы запускаете `dbt deps`, dbt загрузит все содержимое этого пакета (более 100 макросов) как исходный код и добавит его в вашу среду. Вы сможете вызывать любой макрос из пакета, так же как и макросы, определенные в вашем собственном проекте.

Проект `jaffle_finance` &mdash; Это новый сценарий. В отличие от установки пакета, модели в проекте `jaffle_finance` _не_ будут загружены как исходный код и разобраны в вашем проекте. Вместо этого dbt Cloud предоставляет сервис метаданных, который разрешает ссылки на [**публичные модели**](/docs/collaborate/govern/model-access), определенные в проекте `jaffle_finance`.

### Преимущества

Когда вы строите на основе работы другой команды, разрешение ссылок таким образом имеет несколько преимуществ:
- Вы используете целенаправленный интерфейс, назначенный поддерживающим модели с `access: public`.
- Вы сохраняете узкий масштаб вашего проекта, избегая ненужных ресурсов и сложности. Это быстрее для вас и быстрее для dbt.
- Вам не нужно дублировать любую условную конфигурацию верхнего проекта, такую как `vars`, переменные окружения или `target.name`. Вы можете ссылаться на них напрямую, где бы команда финансов не строила свои модели в производстве. Даже если команда финансов вносит изменения, такие как переименование модели, изменение имени ее схемы или [обновление ее версии](/docs/collaborate/govern/model-versions), ваш `ref` все равно будет успешно разрешен.
- Вы исключаете риск случайного построения этих моделей с помощью `dbt run` или `dbt build`. Хотя вы можете выбрать эти модели, вы не можете их фактически построить. Это предотвращает неожиданные затраты на хранилище и проблемы с разрешениями. Это также обеспечивает надлежащее владение и распределение затрат для моделей каждой команды.

### Как написать кросс-проектный ref

**Написание `ref`:** Модели, на которые ссылаются из зависимости типа `project`, должны использовать [двухаргументный `ref`](/reference/dbt-jinja-functions/ref#ref-project-specific-models), включая имя проекта:

<File name="models/marts/roi_by_channel.sql">

```sql
with monthly_revenue as (
  
    select * from {{ ref('jaffle_finance', 'monthly_revenue') }}

),

...

```

</File>

#### Обнаружение циклов

import CycleDetection from '/snippets/_mesh-cycle-detection.md';

<CycleDetection />

Для получения дополнительной информации о том, как использовать dbt Mesh, обратитесь к специальному [руководству по dbt Mesh](/best-practices/how-we-mesh/mesh-1-intro) и также к нашему бесплатному [курсу обучения dbt Mesh](https://learn.getdbt.com/courses/dbt-mesh).

### Защита производственных данных с помощью сред Staging

При работе в среде разработки кросс-проектные `ref` обычно разрешаются в производственной среде проекта. Однако, чтобы защитить производственные данные, настройте [среду развертывания Staging](/docs/deploy/deploy-environments#staging-environment) в своих проектах.

С интегрированной средой Staging в проекте dbt Mesh автоматически извлекает информацию о публичной модели из среды Staging производителя, если потребитель также находится в Staging. Аналогично, dbt Mesh извлекает из производственной среды производителя, если потребитель находится в производственной среде. Это обеспечивает согласованность между средами и добавляет уровень безопасности, предотвращая доступ к производственным данным во время рабочих процессов разработки.

Читать [Почему использовать среду Staging](/docs/deploy/deploy-environments#why-use-a-staging-environment) для получения дополнительной информации о преимуществах.

#### Staging с зависимостями вниз по потоку

dbt Cloud начинает использовать среду Staging для разрешения кросс-проектных ссылок из проектов вниз по потоку, как только она существует в проекте, без "резервного" перехода к производственной среде. Это означает, что dbt Cloud будет последовательно использовать метаданные из среды Staging для разрешения ссылок в проектах вниз по потоку, даже если в настроенной среде Staging не было успешных запусков.

Чтобы избежать простоя для разработчиков вниз по потоку, вы должны определить и запустить задание перед тем, как пометить среду как Staging:

1. Создайте новую среду, но не помечайте ее как **Staging**.
2. Определите задание в этой среде.
3. Запустите задание и убедитесь, что оно завершилось успешно.
4. Обновите среду, чтобы пометить ее как **Staging**.

### Сравнение

Если бы вы вместо этого установили проект `jaffle_finance` в качестве зависимости `package`, вы бы загрузили его полный исходный код и добавили его в свою рабочую среду. Это означает:
- dbt нужно разобрать и разрешить больше входных данных (что медленнее)
- dbt ожидает, что вы настроите эти модели так, как если бы они были вашими собственными (с `vars`, переменными окружения и т.д.)
- dbt будет запускать эти модели как ваши собственные, если вы явно не исключите их с помощью `--exclude`
- Вы могли бы использовать модели проекта таким образом, как это не предполагал их поддерживающий (финансовая команда)

Есть несколько случаев, когда установка другого внутреннего проекта в качестве пакета может быть полезным паттерном:
- Унифицированные развертывания &mdash; В производственной среде, если центральная команда платформы данных Jaffle Shop хочет запланировать развертывание моделей как для `jaffle_finance`, так и для `jaffle_marketing`, они могут использовать [синтаксис выбора dbt](/reference/node-selection/syntax), чтобы создать новый "пропускающий" проект, который устанавливает оба проекта в качестве пакетов.
- Координированные изменения &mdash; В разработке, если вы хотите протестировать влияние изменения публичной модели в верхнем проекте (`jaffle_finance.monthly_revenue`) на модель вниз по потоку (`jaffle_marketing.roi_by_channel`) _до_ внесения изменений в среду Staging или производственную, вы можете установить пакет `jaffle_finance` в качестве пакета в `jaffle_marketing`. Установка может указывать на конкретную ветку git, однако, если вы часто обнаруживаете необходимость в проведении сквозного тестирования между обоими проектами, мы рекомендуем вам пересмотреть, представляет ли это стабильную границу интерфейса.

Это исключения, а не правило. Установка проекта другой команды в качестве пакета добавляет сложность, задержки и риск ненужных затрат. Определяя четкие границы интерфейса между командами, предоставляя публичные модели одной команды в качестве "API" для другой и позволяя практикам разрабатывать с более узким определением масштаба, мы можем позволить большему количеству людей вносить вклад с большей уверенностью, требуя при этом меньше контекста заранее.

## Часто задаваемые вопросы

<details>
<summary>Могу ли я определить частные пакеты в файле <code>dependencies.yml</code>?</summary>

Если вы используете частные пакеты с помощью [метода git-токена](/docs/build/packages#git-token-method), вы должны определить их в файле `packages.yml`, а не в файле `dependencies.yml`. Это связано с тем, что условная отрисовка (такая как Jinja-in-yaml) не поддерживается.
</details>

## Связанные документы
- Обратитесь к [руководству по dbt Mesh](/best-practices/how-we-mesh/mesh-1-intro) для получения дополнительной информации о том, как использовать dbt Mesh.
- [Быстрый старт с dbt Mesh](/guides/mesh-qs)