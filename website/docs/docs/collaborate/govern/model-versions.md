---
title: "Версии моделей"
id: model-versions
sidebar_label: "Версии моделей"
description: "Версионирование моделей для управления жизненным циклом"
keyword: управление, версия модели, версионирование модели, версионирование моделей dbt
---

<VersionBlock lastVersion="1.8">

:::info Новая функциональность
Эта функциональность новая в версии v1.5 — если у вас есть мысли, участвуйте в [обсуждении на GitHub](https://github.com/dbt-labs/dbt-core/discussions/6736)!
:::

</VersionBlock>

import VersionsCallout from '/snippets/_version-callout.md';

<VersionsCallout />

Версионирование API — это сложная задача в программной инженерии. Корень проблемы заключается в том, что у производителей и потребителей API есть конкурирующие интересы:
- Производители API нуждаются в возможности изменять его логику и структуру. Существуют реальные затраты на поддержание устаревших конечных точек навсегда, но потеря доверия со стороны пользователей ниже по потоку обходится гораздо дороже.
- Потребители API нуждаются в уверенности в его стабильности: их запросы будут продолжать работать и не сломаются без предупреждения. Хотя миграция на новую версию API влечет за собой расходы, неплановая миграция обходится гораздо дороже.

При совместном использовании окончательной модели dbt с другими командами или системами эта модель функционирует как API. Когда производителю этой модели необходимо внести значительные изменения, как он может избежать поломки запросов ее пользователей ниже по потоку?

Версионирование моделей — это инструмент для решения этой проблемы, продуманно и напрямую. Цель не в том, чтобы полностью устранить проблему, или притворяться, что она проще или легче, чем есть на самом деле.

## Связанная документация
- [`versions`](/reference/resource-properties/versions)
- [`latest_version`](/reference/resource-properties/latest_version)
- [`include` & `exclude`](/reference/resource-properties/include-exclude)
- [`ref` с аргументом `version`](/reference/dbt-jinja-functions/ref#versioned-ref)

## Зачем версионировать модель?

Если модель определяет ["контракт"](/docs/collaborate/govern/model-contracts) (набор гарантий для своей структуры), также возможно изменить структуру этой модели таким образом, что это нарушит предыдущий набор гарантий. Это может быть так же очевидно, как удаление или переименование столбца, или более тонко, например, изменение его типа данных или возможности быть нулевым.

Один из подходов заключается в том, чтобы заставить каждого потребителя модели немедленно справляться с нарушающим изменением, как только оно будет развернуто в производственной среде. Это на самом деле подходящий ответ для многих небольших организаций или во время быстрого итерационного процесса над еще не зрелым набором моделей данных. Но это не масштабируется за пределами этого.

Вместо этого, для зрелых моделей в крупных организациях, которые поддерживают запросы внутри и вне dbt, владелец модели может использовать **версии моделей** для:
- Тестирования изменений "предварительного релиза" (в производственной среде, в системах ниже по потоку)
- Увеличения последней версии, чтобы использовать ее как канонический источник правды
- Предложения окна миграции с "старой" версии

В течение этого окна миграции, где бы эта модель ни использовалась ниже по потоку, ее можно продолжать ссылаться на конкретную версию.

dbt Core 1.6 представил первоклассную поддержку для **декларации устаревших моделей** путем указания [`deprecation_date`](/reference/resource-properties/deprecation_date). В совокупности, версии моделей и устаревание предлагают путь для производителей моделей, чтобы _закрыть_ старые модели, а для потребителей — время для _миграции_ через нарушающие изменения. Это способ управления изменениями в организации: разработать новую версию, увеличить последнюю, запланировать старую версию на устаревание, обновить ссылки ниже по потоку, а затем удалить старую версию.

Существует реальный компромисс — стоимость частой миграции кода ниже по потоку и стоимость (и беспорядок) материализации нескольких версий модели в хранилище данных. Версии моделей не устраняют эту проблему, но, установив дату устаревания и сообщив четкое окно для потребителей, чтобы они могли плавно мигрировать с устаревших версий, они устанавливают известную границу на стоимость этой миграции.

## Когда следует версионировать модель?

Принуждая контракт модели, dbt может помочь вам поймать непреднамеренные изменения в именах столбцов и типах данных, которые могут вызвать большие проблемы для запросов ниже по потоку. Если вы вносите эти изменения намеренно, вам следует создать новую версию модели. Если вы вносите изменения, не нарушающие работу, новая версия не требуется — например, добавление нового столбца или исправление ошибки в расчете существующего столбца.

Конечно, возможно изменить определение модели и другими способами — пересчитывая столбец таким образом, что его имя, тип данных или обязательные характеристики не изменяются, но это существенно изменит результаты, которые видят запросы ниже по потоку.

Это всегда вопрос суждения. Как поддерживающий широко используемую модель, вы лучше всего знаете, что является исправлением ошибки, а что — неожиданным изменением поведения.

Процесс закрытия и миграции версий моделей требует реальной работы и, вероятно, значительной координации между командами. Вам следует выбирать изменения, не нарушающие работу, когда это возможно. Однако неизбежно, что эти не нарушающие изменения оставят ваши самые важные модели с множеством неиспользуемых или устаревших столбцов.

Вместо того чтобы постоянно добавлять новую версию для каждого небольшого изменения, вам следует выбрать предсказуемый ритм (один или два раза в год, хорошо заранее сообщенный), когда вы увеличиваете "последнюю" версию вашей модели, удаляя столбцы, которые больше не используются.

## Как это отличается от "контроля версий"?

[Контроль версий](/docs/collaborate/git-version-control) позволяет вашей команде одновременно сотрудничать над одним репозиторием кода, управлять конфликтами между изменениями и просматривать изменения перед развертыванием в производственной среде. В этом смысле контроль версий является важным инструментом для версионирования развертывания целого проекта dbt — всегда последнего состояния ветки `main`. В общем, только одна версия кода вашего проекта развертывается в среде в одно время. Если что-то пойдет не так, у вас есть возможность откатить изменения, отменив коммит или запрос на слияние, или воспользовавшись возможностями платформы данных по "путешествию во времени".

Когда вы вносите обновления в исходный код модели — ее логическое определение, на SQL или Python, или связанную конфигурацию — dbt может [сравнить ваш проект с предыдущим состоянием](/reference/node-selection/syntax#about-node-selection), позволяя вам перестраивать только измененные модели и модели ниже по потоку от изменения. Таким образом, возможно разрабатывать изменения в модели, быстро тестировать в CI и эффективно развертывать в производственной среде — все это координируется через вашу систему контроля версий.

**Версионированные модели отличаются.** Определение `versions` модели уместно, когда люди, системы и процессы, находящиеся вне контроля вашей команды, внутри или вне dbt, зависят от ваших моделей. Вы не можете просто мигрировать их всех или сломать их запросы по прихоти. Вам нужно предложить путь миграции с четкими различиями и датами устаревания.

Несколько версий модели будут существовать в одном и том же репозитории кода одновременно и развертываться в одной и той же среде данных одновременно. Это похоже на то, как версии веб-API: несколько версий существуют одновременно, две или три, и не более. Со временем новые версии появляются, а старые версии закрываются.

## Как это отличается от простого создания новой модели?

Честно говоря, это немного отличается! Здесь нет никакой магии, и это сделано намеренно.

Вы всегда могли копировать и вставлять, создавать новый файл модели и называть его `dim_customers_v2.sql`. Почему вам следует выбрать "реальную" версионированную модель вместо этого?

Как **производитель** версионированной модели:
- Вы отслеживаете все активные версии в одном месте, а не разбросаны по всему кодовой базе
- Вы можете повторно использовать конфигурацию модели и выделить только различия между версиями
- Вы можете выбирать модели для сборки (или нет) в зависимости от того, являются ли они `latest`, `prerelease` или `old` версией
- dbt уведомит потребителей вашей версионированной модели, когда новые версии станут доступны или когда они будут запланированы на устаревание

Как **потребитель** версионированной модели:
- Вы используете последовательный `ref`, с возможностью зафиксировать конкретную активную версию
- Вы будете уведомлены на протяжении всего жизненного цикла версионированной модели

Все версии модели сохраняют оригинальное имя модели. Они ссылаются на это имя, а не на имя файла, в котором они определены. По умолчанию `ref` разрешается на последнюю версию (как объявлено поддерживающим эту модель), но вы также можете `ref` конкретную версию модели с помощью ключевого слова `version`.

Предположим, что `dim_customers` имеет три определенные версии: `v2` является "последней", `v3` — "предварительной", а `v1` — старая версия, которая все еще находится в окне устаревания. Поскольку `v2` является последней версией, она получает особое обращение: ее можно определить в файле без суффикса, и `ref('dim_customers')` разрешится на `v2`, если не указана фиксация версии. Таблица ниже разбивает стандартные соглашения:

| v | версия    | синтаксис `ref`                                          | Имя файла                                       | Соотношение в базе данных                                                        |
|---|------------|-------------------------------------------------------|-------------------------------------------------|--------------------------------------------------------------------------|
| 3 | "предварительная" | `ref('dim_customers', v=3)`                           | `dim_customers_v3.sql`                          | `analytics.dim_customers_v3`                                             |
| 2 | "последняя"     | `ref('dim_customers', v=2)` **и** `ref('dim_customers')`  | `dim_customers_v2.sql` **или** `dim_customers.sql` | `analytics.dim_customers_v2` **и** `analytics.dim_customers` (рекомендуется) |
| 1 | "старая"        |  `ref('dim_customers', v=1)`                           | `dim_customers_v1.sql`                          | `analytics.dim_customers_v1`                                             |

Как вы увидите в разделе реализации ниже, версионированная модель может повторно использовать большинство своих свойств YAML и конфигурации. Каждая версия должна только указать, как она _отличается_ от общего набора атрибутов. Это дает вам, как производителю версионированной модели, возможность выделить различия между версиями — что в противном случае трудно обнаружить в моделях с десятками или сотнями столбцов — и четко отслеживать в одном месте все версии модели, которые в настоящее время активны.

dbt также поддерживает [`version`-основанный выбор](/reference/node-selection/methods#version). Например, вы можете определить [по умолчанию YAML селектор](/reference/node-selection/yaml-selectors#default), который избегает выполнения любых старых версий модели в разработке, даже если вы продолжаете выполнять их в производственной среде в течение периода закрытия и миграции. (Вы можете достичь чего-то подобного, применив `tags` к этим моделям и циклически проходя через эти теги со временем.)

<File name="selectors.yml">

```yml
selectors:
  - name: exclude_old_versions
    default: "{{ target.name == 'dev' }}"
    definition:
      method: fqn
      value: "*"
      exclude:
        - method: version
          value: old
```

</File>

Поскольку dbt знает, что эти модели _на самом деле одна и та же модель_, он может уведомлять потребителей ниже по потоку, когда новые версии становятся доступными и когда старые версии запланированы на устаревание.

```bash
Найдена ссылка на версионированную модель 'dim_customers', не зафиксированная.
Разрешение на последнюю версию: my_model.v2
Доступна предварительная версия 3. Она еще не была помечена как 'последняя' ее поддерживающим.
Когда это произойдет, эта ссылка разрешится на my_model.v3 вместо.

  Попробуйте v3: {{ ref('my_dbt_project', 'my_model', v='3') }}
  Зафиксируйте на v2: {{ ref('my_dbt_project', 'my_model', v='2') }}
```

## Как создать новую версию модели

Чаще всего вы начнете с модели, которая еще не имеет версии. Давайте вернемся назад во времени, когда `dim_customers` была простой самостоятельной моделью с обязательным контрактом. Для простоты предположим, что у нее всего два столбца: `customer_id` и `country_name`, хотя у большинства зрелых моделей будет гораздо больше.

<File name="models/dim_customers.sql">

```sql
-- много sql

final as (
  
    select
        customer_id,
        country_name
    from ...

)

select * from final
```

</File>

<File name="models/schema.yml">

```yaml
models:
  - name: dim_customers
    config:
      materialized: table
      contract:
        enforced: true
    columns:
      - name: customer_id
        description: Это первичный ключ
        data_type: int
      - name: country_name
        description: Где живет этот клиент
        data_type: varchar
```

</File>

Предположим, вам нужно внести нарушающее изменение в модель: удалить столбец `country_name`, который больше не является надежным. Сначала создайте новый файл модели (SQL или Python), охватывающий эти нарушающие изменения.

Стандартное соглашение — называть новый файл с суффиксом `_v<version>`. Давайте создадим новый файл с именем `dim_customers_v2.sql`. (Пока не нужно переименовывать существующий файл модели, пока он все еще является "последней" версией.)

<File name="models/dim_customers_v2.sql">

```sql
-- много sql

final as (
  
    select
        customer_id
        -- country_name был удален!
    from ...

)

select * from final
```

</File>

Теперь вы могли бы определить свойства и конфигурацию для `dim_customers_v2` как новой самостоятельной модели, без фактической связи с `dim_customers`, кроме поразительного сходства. Вместо этого мы собираемся объявить, что это версии одной и той же модели, обе называются `dim_customers`. Мы можем определить их свойства в общем, а затем **только** выделить различия между ними. (Или вы можете выбрать полное определение каждой версии модели с повторением значений, которые у них общие.)

<Tabs>
<TabItem value="Только различия (рекомендуется)">

<File name="models/schema.yml">

```yaml
models:
  - name: dim_customers
    latest_version: 1
    config:
      materialized: table
      contract: {enforced: true}
    columns:
      - name: customer_id
        description: Это первичный ключ
        data_type: int
      - name: country_name
        description: Где живет этот клиент
        data_type: varchar
    
    # Объявите версии и выделите различия
    versions:
    
      - v: 1
        # Совпадает с тем, что выше — ничего больше не нужно
    
      - v: 2
        # Удален столбец — это нарушающее изменение!
        columns:
          # Это означает: используйте список 'columns' выше, но исключите country_name
          - include: all
            exclude: [country_name]
      
```

</File>

</TabItem>

<TabItem value="Полностью указано">

<File name="models/schema.yml">

```yaml
models:
  - name: dim_customers
    latest_version: 1
    
    # объявите версии и полностью укажите их
    versions:
      - v: 2
        config:
          materialized: table
          contract: {enforced: true}
        columns:
          - name: customer_id
            description: Это первичный ключ
            data_type: int
          # нет столбца country_name
      
      - v: 1
        config:
          materialized: table
          contract: {enforced: true}
        columns:
          - name: customer_id
            description: Это первичный ключ
            data_type: int
          - name: country_name
            description: Где живет этот клиент
            data_type: varchar
```

</File>

</TabItem>

</Tabs>

Конфигурация выше говорит: вместо двух несвязанных моделей у меня есть две версионированные определения одной и той же модели: `dim_customers_v1` и `dim_customers_v2`.

**Где они определены?** dbt ожидает, что каждая версия модели будет определена в файле с именем `<model_name>_v<v>`. В этом случае: `dim_customers_v1.sql` и `dim_customers_v2.sql`. Также возможно определить "последнюю" версию в `dim_customers.sql` (без суффикса), без дополнительной конфигурации. Наконец, вы можете переопределить это соглашение, установив [`defined_in: любое_имя_файла_которое_вы_хотите`](/reference/resource-properties/versions#defined_in) — но мы настоятельно рекомендуем следовать соглашению, если у вас нет очень веской причины.

**Где они будут материализованы?** Каждая версия модели создаст соотношение базы данных с псевдонимом `<model_name>_v<v>`. В этом случае: `dim_customers_v1` и `dim_customers_v2`. См. [раздел ниже](#configuring-database-location-with-alias) для получения дополнительных сведений о конфигурации псевдонимов.

**Какая версия является "последней"?** Если не указано явно, `latest_version` будет `2`, потому что она численно больше. В этом случае мы явно указали, что `latest_version: 1`. Это означает, что `v2` является "предварительной", на ранней стадии разработки и тестирования. Когда мы будем готовы развернуть `v2` для всех по умолчанию, мы увеличим `latest_version: 2` или удалим `latest_version` из спецификации.

### Конфигурирование версионированных моделей

Вы можете перенастроить каждую версию независимо. Например, вы можете материализовать `v2` как таблицу, а `v1` как представление:

<File name="models/schema.yml">

```yml
versions:
  - v: 2
    config:
      materialized: table
  - v: 1
    config:
      materialized: view
```

</File>

Как и с любой наследуемой конфигурацией, любые конфигурации, установленные _внутри_ определения версионированной модели (`.sql` или `.py` файл), будут иметь приоритет над конфигурациями, установленными в YAML.

### Конфигурирование местоположения базы данных с помощью `alias`

Следуя примеру, предположим, вы хотите, чтобы `dim_customers_v1` продолжала заполнять таблицу базы данных с именем `dim_customers`. Так называлась таблица ранее, и у вас могут быть несколько других панелей или инструментов, ожидающих чтения ее данных из `<dbname>.<schemaname>.dim_customers`.

Вы можете использовать конфигурацию `alias`:

<File name="models/schema.yml">

```yml
      - v: 1
        config:
          alias: dim_customers   # сохранить v1 в его оригинальном местоположении в базе данных
```

</File>

**Рекомендуемый шаблон:** Создайте представление или клон таблицы с каноническим именем модели, который всегда указывает на последнюю версию. Следуя этому шаблону, вы можете предложить ту же гибкость, что и `ref`, даже если кто-то запрашивает вне dbt. Хотите конкретную версию? Зафиксируйте на версии X, добавив суффикс `_vX`. Хотите последнюю версию? Без суффикса, и представление перенаправит вас.

Мы намерены встроить это в `dbt-core` как функциональность "из коробки". (Поддержите или прокомментируйте [dbt-core#7442](https://github.com/dbt-labs/dbt-core/issues/7442).) Тем временем вы можете реализовать этот шаблон самостоятельно с помощью пользовательского макроса и пост-хука:

<File name="macros/create_latest_version_view.sql">

```sql
{% macro create_latest_version_view() %}

    -- этот хук будет выполняться только если модель версионирована и только если это последняя версия
    -- в противном случае это no-op
    {% if model.get('version') and model.get('version') == model.get('latest_version') %}

        {% set new_relation = this.incorporate(path={"identifier": model['name']}) %}

        {% set existing_relation = load_relation(new_relation) %}

        {% if existing_relation and not existing_relation.is_view %}
            {{ drop_relation_if_exists(existing_relation) }}
        {% endif %}
        
        {% set create_view_sql -%}
            -- этот синтаксис может варьироваться в зависимости от платформы данных
            create or replace view {{ new_relation }}
              as select * from {{ this }}
        {%- endset %}
        
        {% do log("Создание представления " ~ new_relation ~ " указывающего на " ~ this, info = true) if execute %}
        
        {{ return(create_view_sql) }}
        
    {% else %}
    
        -- no-op
        select 1 as id
    
    {% endif %}

{% endmacro %}
```

</File>


<File name="dbt_project.yml">

```yml
# dbt_project.yml
models:
  post-hook:
    - "{{ create_latest_version_view() }}"
```

</File>

:::info
Если ваш проект исторически реализовывал [пользовательские псевдонимы](/docs/build/custom-aliases), повторно реализуя макрос `generate_alias_name`, и вы хотите начать использовать версии моделей, вам следует обновить вашу пользовательскую реализацию, чтобы учесть версии моделей. В частности, мы рекомендуем вам добавить [условие, подобное этому](https://github.com/dbt-labs/dbt-core/blob/ada8860e48b32ac712d92e8b0977b2c3c9749981/core/dbt/include/global_project/macros/get_custom_name/get_custom_alias.sql#L26-L30).

Ваша существующая реализация `generate_alias_name` не должна сталкиваться с ошибками при первом обновлении до v1.5. Только когда вы создадите свою первую версионированную модель, вы можете увидеть ошибку, подобную:

```sh
dbt.exceptions.AmbiguousAliasError: Ошибка компиляции
  dbt нашел два ресурса с представлением базы данных "database.schema.model_name".
  dbt не может создать два ресурса с идентичными представлениями базы данных. Чтобы исправить это,
  измените конфигурацию одного из этих ресурсов:
  - model.project_name.model_name.v1 (models/.../model_name.sql)
  - model.project_name.model_name.v2 (models/.../model_name_v2.sql)
```

Мы выбрали использовать `generate_alias_name` для этой функциональности, чтобы логика оставалась доступной конечным пользователям и могла быть повторно реализована с пользовательской логикой.
:::

### Запуск модели с несколькими версиями

Чтобы запустить модель с несколькими версиями, вы можете использовать флаг [`--select`](/reference/node-selection/syntax). Например:

- Запустите все версии `dim_customers`:

  ```bash
  dbt run --select dim_customers # Запустите все версии модели
  ```
- Запустите только версию 2 `dim_customers`:

  Вы можете использовать любую из следующих команд (обе достигают одного и того же результата):

  ```bash
    dbt run --select dim_customers.v2 # Запустите конкретную версию модели
    dbt run --select dim_customers_v2 # Альтернативный синтаксис для конкретной версии
  ```

- Запустите последнюю версию `dim_customers`, используя сокращенный флаг `--select`:

  ```bash
  dbt run -s dim_customers,version:latest # Запустите последнюю версию модели
  ```

Эти команды обеспечивают гибкость в управлении и выполнении различных версий модели dbt.

### Оптимизация версий моделей

Как вы определяете каждую версию модели, полностью зависит от вас. Хотя легко начать с копирования и вставки из одного определения SQL модели в другое, вам следует подумать о _том, что на самом деле меняется_ от одной версии к другой.

Например, если ваша новая версия модели только переименовывает или удаляет определенные столбцы, вы можете определить одну версию как представление на основе другой:

<File name="models/dim_customers_v2.sql">

```sql
{{ config(materialized = 'view') }}

{% set dim_customers_v1 = ref('dim_customers', v=1) %}

select
{{ dbt_utils.star(from=dim_customers_v1, except=["country_name"]) }}
from {{ dim_customers_v1 }}
```

</File>

Конечно, если одна версия модели вносит значительные и существенные изменения в логику другой, может быть невозможно оптимизировать это таким образом. В этот момент стоимость человеческой интуиции и читаемости важнее, чем стоимость пересчета аналогичных преобразований.

Мы ожидаем, что разработаем более целенаправленные рекомендации, когда команды начнут применять версии моделей на практике. Один рекомендуемый шаблон, который мы можем представить: приоритизируйте определение `latest_version` и определяйте другие версии (старые и предварительные) на основе их различий от последней. Как?
- Определите свойства и конфигурацию для последней версии на верхнем уровне модели YAML, а различия для других версий ниже (через `include`/`exclude`)
- Где это возможно, определяйте другие версии как `select` преобразования, которые берут последнюю версию в качестве отправной точки
- При увеличении `latest_version` мигрируйте SQL и YAML соответственно.

В приведенном выше примере третий пункт может быть сложным. Проще _исключить_ `country_name`, чем добавить его обратно. Вместо этого нам может потребоваться сохранить полную оригинальную логику для `dim_customers_v1` — но материализовать ее как `view`, чтобы минимизировать затраты на хранилище данных для ее построения. Если запросы ниже по потоку видят немного ухудшенную производительность, это все равно значительно лучше, чем сломанные запросы, и тем более причина мигрировать на новую "последнюю" версию.