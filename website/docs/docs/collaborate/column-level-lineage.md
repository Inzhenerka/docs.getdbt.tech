---
title: "Потомственность на уровне столбцов"
description: "Используйте потомственность на уровне столбцов в dbt Explorer, чтобы получить представление о ваших данных на более детальном уровне."
---

Теперь dbt Explorer предлагает потомственность на уровне столбцов (CLL) для ресурсов в вашем проекте dbt. Аналитические инженеры могут быстро и легко получить представление о происхождении своих продуктов данных на более детальном уровне. Для каждого столбца в ресурсе (модели, источнике или снимке) в проекте dbt Explorer предоставляет полную потомственность для данных в этом столбце в зависимости от того, как они используются.

CLL доступна для учетных записей dbt Cloud Enterprise, которые могут использовать Explorer.

<Lightbox src="/img/docs/collaborate/dbt-explorer/example-overview-cll.png" width="95%" title="Обзор потомственности на уровне столбцов"/>

import ExplorerCourse from '/snippets/_explorer-course-link.md';

<ExplorerCourse />

## Доступ к потомственности на уровне столбцов

Дополнительная настройка для CLL не требуется, если ваша учетная запись находится на корпоративном плане, который может использовать Explorer. Вы можете получить доступ к CLL, развернув карточку столбца на вкладке **Столбцы** на странице [подробностей ресурса](/docs/collaborate/explore-projects#view-resource-details) для модели, источника или снимка.

dbt Cloud обновляет потомственность в Explorer после каждого выполнения, которое осуществляется в производственной или тестовой среде. По крайней мере, одна задача в производственной или тестовой среде должна выполнить `dbt docs generate`. Смотрите [Генерация метаданных](/docs/collaborate/explore-projects#generate-metadata) для получения дополнительных сведений.

<Lightbox src="/img/docs/collaborate/dbt-explorer/example-cll.png" width="40%" title="Пример вкладки Столбцы и где развернуть для CLL"/>

## Линза эволюции столбца {#column-lens}

Вы можете использовать линзу эволюции столбца, чтобы определить, когда столбец преобразуется или повторно используется (передача или переименование). Эта линза помогает вам различать, когда и как столбец фактически изменяется по мере его прохождения через вашу потомственность dbt, что особенно полезно для отладки.

<Lightbox src="/img/docs/collaborate/dbt-explorer/example-evolution-lens.png" width="90%" title="Пример линзы эволюции столбца"/>

### Унаследованные описания столбцов

Повторно используемый столбец, помеченный как **Передача** или **Переименование** в потомственности, автоматически наследует свое описание от столбцов источника и вышестоящей модели. Наследование происходит настолько далеко, насколько это возможно. Пока столбец не преобразован, вам не нужно вручную определять описание; оно автоматически передается вниз по потоку.

Столбцы передачи и переименования четко помечены и цветом выделены в потомственности.

В следующем примере модели `dim_salesforce_accounts` (расположенной в конце потомственности) описание для столбца, унаследованного от модели `stg_salesforce__accounts` (расположенной второй слева), указывает на его происхождение. Это помогает разработчикам быстро определить оригинальный источник столбца, что упрощает внесение изменений в документацию.

<Lightbox src="/img/docs/collaborate/dbt-explorer/example-prop-inherit.jpg" width="100%" title="Пример потомственности с переданными и унаследованными описаниями столбцов."/>

## Сценарии использования потомственности на уровне столбцов {#use-cases}

Узнайте больше о том, почему и как вы можете использовать CLL в следующих разделах.

### Анализ причин

Когда в конвейере данных происходит неожиданная ошибка, потомственность на уровне столбцов может быть ценным инструментом для понимания точного места, где произошла ошибка в конвейере. Например, сбой теста данных для определенного столбца в вашей модели dbt мог возникнуть из-за непроверенного столбца выше по потоку. Использование CLL может помочь быстро выявить и исправить ошибки, когда они происходят.

### Анализ воздействия

Во время разработки аналитические инженеры могут использовать потомственность на уровне столбцов, чтобы понять полный масштаб воздействия своих предложенных изменений. Эти знания позволяют им создавать более качественные запросы на слияние, которые требуют меньшего количества правок, так как они могут предвидеть и предотвратить проблемы, которые остались бы незамеченными без понимания на уровне столбцов.

### Сотрудничество и эффективность

При исследовании ваших продуктов данных навигация по потомственности столбцов позволяет аналитическим инженерам и аналитикам данных легче ориентироваться и понимать происхождение и использование своих данных, что позволяет им принимать более обоснованные решения с большей уверенностью.

## Ограничения

Обратите внимание на следующие ограничения или недостатки CLL, когда вы используете dbt Explorer.

### Использование столбцов
Потомственность на уровне столбцов отражает потомственность из операторов `select` в SQL-коде ваших моделей. Она не отражает другое использование, такое как соединения и фильтры.

### Парсинг SQL

Потомственность на уровне столбцов зависит от парсинга SQL. Ошибки могут возникать, когда парсинг не удается или происхождение столбца неизвестно (например, при распаковке JSON, боковых соединениях и т. д.). В этих случаях потомственность может быть неполной, и dbt Cloud предоставит предупреждение об этом в потомственности столбца.

<Lightbox src="/img/docs/collaborate/dbt-explorer/example-parsing-error-pill.png" title="Пример предупреждения в полном графе потомственности"/>

Чтобы просмотреть детали ошибки:
1. Нажмите на значок **Развернуть** в правом верхнем углу, чтобы открыть граф потомственности столбца
1. Выберите узел, чтобы открыть панель деталей столбца

Возможные случаи ошибок:

- **Ошибка парсинга** &mdash; Ошибка возникает, когда SQL неоднозначен или слишком сложен для парсинга. Примером неоднозначных сценариев парсинга являются _сложные_ боковые соединения.
- **Ошибка Python** &mdash; Ошибка возникает, когда в потомственности используется модель Python. Из-за природы моделей Python невозможно выполнить парсинг и определить потомственность.
- **Неизвестная ошибка** &mdash; Ошибка возникает, когда потомственность не может быть определена по неизвестной причине. Примером этого может быть несоблюдение лучших практик dbt, таких как использование жестко закодированных имен таблиц вместо операторов `ref`.