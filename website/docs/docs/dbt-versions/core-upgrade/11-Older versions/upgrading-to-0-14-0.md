---
title: "Обновление до 0.14.0"
id: "upgrading-to-0-14-0"
displayed_sidebar: "docs"
---

Этот гид содержит инструкции по миграции для:

1. [Обновления архивов до снимков](#upgrading-to-snapshot-blocks)
2. [Использования обновлений макроса `generate_schema_name`](#upgrading-the-generate_schema_name-signature)
3. [Удаления флага `--non-destructive`](#non-destructive-runs)
4. [Изменений в том, как создаются инкрементальные модели в Snowflake](#snowflake-incremental-model-changes)

## Обновление до Снимков

В dbt v0.14.0 `archives` были заменены на `snapshots`. Снимки достигают той же цели, что и архивы, но являются более мощными и гибкими. Для полного руководства по использованию снимков обратитесь к [документации по снимкам](/docs/build/snapshots).

Существует несколько изменений, о которых следует знать при миграции с архивов на снимки:
- Имена мета-колонок теперь начинаются с префикса `dbt_`
- Снимки указываются в .sql файлах, в то время как архивы указывались в файле `dbt_project.yml`

### Изменения имен колонок снимков
Эта <Term id="table" /> показывает различия между именами колонок, создаваемыми `dbt archive` и `dbt snapshot`. **Примечание:** Эти новые имена мета-колонок снимков _не заключены в кавычки_. Если вы используете Snowflake, это означает, что имена колонок ваших снимков будут отображаться в верхнем регистре, а не в нижнем.

| Колонка Архива (в кавычках) | Колонка Снимка (без кавычек) |
| ----------------------------- | ------------------------------ |
| valid_from                   | dbt_valid_from                |
| valid_to                     | dbt_valid_to                  |
| scd_id                       | dbt_scd_id                    |

### Миграция архивов в снимки
Миграция архивов в снимки включает два различных типа изменений в вашем проекте dbt:

1. Переименование колонок в ваших существующих таблицах архивов
2. Замена секции `archive:` в файле `dbt_project.yml` на блоки `snapshot`

Мы предоставили скрипт миграции в dbt v0.14.0, который выполняет обе эти задачи. Этот скрипт:

1. Создает резервную копию ваших таблиц архивов
2. Переименовывает колонки в соответствии с таблицей выше
3. Генерирует блоки снимков для ваших существующих архивов в новых .sql файлах

Предоставленный скрипт миграции должен быть выполнен _один раз_ одним пользователем dbt. Этот пользователь базы данных должен иметь достаточные права для работы с существующими таблицами архивов в базе данных.

### Запуск скрипта миграции

:::caution Пользовательские Материализации

Этот гид предполагает, что вы используете встроенную архивную <Term id="materialization" />. Если вы используете пользовательскую архивную материализацию, смотрите раздел "Миграция архивов вручную" ниже.

:::

По умолчанию скрипт миграции не внесет никаких изменений в ваш проект или базу данных. Вместо этого он сообщит о изменениях, которые _должны_ быть внесены для миграции ваших архивов в снимки. Чтобы запустить скрипт миграции в режиме предварительного просмотра, выполните:
```
$ dbt snapshot-migrate --from-archive
```

**Пример вывода:**
```
$ dbt snapshot-migrate --from-archive
Запуск с dbt=0.14.0
Найден 1 архив для миграции

Архив 1 из 1: "analytics"."archived"."orders_archived"
  - Пропуск миграции в режиме предварительного просмотра
  - Пропуск нового файла снимка в режиме предварительного просмотра

Повторно запустите этот скрипт с `--apply`, чтобы применить эти миграции
```

Эта команда выведет список таблиц архивов, которые должны быть мигрированы. После проверки списка таблиц архивов примените миграцию, используя флаг `--apply`:

```
$ dbt snapshot-migrate --from-archive --apply
```

**Пример вывода**:
```
$ dbt snapshot-migrate --from-archive --apply
Запуск с dbt=0.14.0
Найден 1 архив для миграции

Архив 1 из 1: "analytics"."archived"."orders_archived"
  - Начало миграции таблицы
  - Создание резервной копии таблицы в "analytics"."archived"."orders_archived_dbt_archive_migration_backup"
  - Завершение миграции таблицы
  - Запись нового файла снимка в snapshots/orders_archived.sql

Были созданы следующие резервные таблицы:
  - "analytics"."archived"."orders_archived_dbt_archive_migration_backup"

Были созданы следующие файлы снимков:
  - snapshots/orders_archived.sql

После проверки мигрированных таблиц в базе данных, пожалуйста, удалите резервные
таблицы и уберите любые конфигурации архивов из вашего файла dbt_project.yml.
```

Если этот шаг прошел успешно, то поздравляем! Ваши архивы были мигрированы в снимки.

### Завершение миграции

После выполнения скрипта выше важно проверить данные в ваших новых таблицах снимков. Запросите таблицы снимков, чтобы убедиться, что они существуют и содержат мета-колонки с префиксами `dbt_`.

Затем проверьте новые снимки в вашей директории `snapshots/`. Должен быть один файл снимка на каждый архив, который существует в вашем проекте. Если эти файлы снимков присутствуют и действительны, вы можете удалить секцию `archive:` из вашего файла `dbt_project.yml`.

Когда вы будете уверены, что миграция завершена успешно, вы можете вручную удалить резервные таблицы в ваших архивных схемах. Эти резервные таблицы будут иметь суффикс `_dbt_archive_migration_backup`.

Снимки участвуют в графе dbt, поэтому не стесняйтесь заменять любые ссылки `schema.table` в вашем коде модели на `{{ ref('archive_name') }}`. Вам также может потребоваться внести изменения в модели или отчеты нижнего уровня, чтобы учесть изменения в именах мета-колонок ваших снимков. Обратитесь к [документации по снимкам](/docs/build/snapshots) для получения полных инструкций по использованию.

### Миграция архивов вручную (не рекомендуется)

Если вы не можете использовать скрипт миграции архивов, вы можете вместо этого мигрировать ваши архивы в снимки вручную. Точные шаги, необходимые для миграции архивов в снимки, варьируются в зависимости от базы данных, но в общем вам нужно будет переименовать мета-колонки архивов в соответствии с таблицей миграции выше. Примеры запросов миграции (с использованием синтаксиса postgres):
```sql
alter table archived.orders_archived rename "valid_from" to dbt_valid_from;
alter table archived.orders_archived rename "valid_to" to dbt_valid_to;
alter table archived.orders_archived rename "scd_id" to dbt_scd_id;
```

## Обновление сигнатуры generate_schema_name

В dbt v0.14.0 сигнатура макроса `generate_schema_name` была изменена, чтобы принимать второй аргумент, `node`. Для получения дополнительной информации о новом аргументе `node` обратитесь к документации по [использованию пользовательских схем](/docs/build/custom-schemas).

Существующие реализации макросов `generate_schema_name` с одним аргументом по-прежнему поддерживаются, но поддержка этой формы макроса будет удалена в будущем релизе. Если у вас в настоящее время есть версия этого макроса с одним аргументом, вы увидите предупреждение при запуске вашего проекта dbt.

### Пример предупреждения
```
С версии dbt v0.14.0 макрос `generate_schema_name` принимает второй аргумент "node".
Форма `generate_schema_name` с одним аргументом устарела и
будет поддерживаться в будущем релизе
```

### Обновление
Чтобы обновить этот макрос (и подавить это предупреждение), добавьте второй аргумент, `node`, в ваш макрос `generate_schema_name`.

<File name='generate_schema_name.sql'>

```jinja2
{% macro generate_schema_name(schema_name, node) -%}
  ... ваша логика здесь ...
{%- endmacro %}
```

</File>


## Ненасильственные запуски

Флаг `--non-destructive` был удален из dbt в v0.14.0. Этот флаг существовал как обходной путь для отсутствия позднего связывания <Term id="view">представлений</Term> в Amazon Redshift. С введением [соглашения без связывания схемы](https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_VIEW.html) для представлений Redshift ненасильственные запуски больше не нужны.

Флаг `--non-destructive` был проблемным по нескольким причинам:

1. Он использовал оператор `truncate`, который фиксировал существующую транзакцию. Это означает, что ненасильственные запуски не были атомарными, и ошибки в построении модели могли оставить вас с пустыми таблицами!
2. Это усложняло материализации dbt и делало их трудными для поддержки
3. Это полностью пропускало создание представлений, что редко бывает желаемым
4. Это давало сбои в сложных и коварных ситуациях, когда колонки добавлялись или удалялись из таблиц моделей

Пользователи Snowflake, BigQuery, SparkSQL и Presto не должны испытывать проблем с этим изменением, так как использование флага `--non-destructive` в этих базах данных имеет ограниченные преимущества.

Пользователи Redshift должны рассмотреть возможность использования конфигурации [bind: false](/reference/resource-configs/redshift-configs#late-binding-views), чтобы указать dbt создавать несвязанные представления.

Пользователи Postgres должны убедиться, что они используют таблицы или инкрементальные модели для отношений, которые запрашиваются конечными пользователями.

## Изменения инкрементальных моделей Snowflake

В dbt v0.14.0 реализация инкрементальных моделей в Snowflake была изменена. По умолчанию dbt будет использовать оператор [merge](https://docs.snowflake.net/manuals/sql-reference/sql/merge.html) для атомарного обновления записей в <Term id="table" /> инкрементально. В предыдущих версиях dbt использовался двухэтапный подход `delete+insert` для обновления данных.

Оператор `merge` требует, чтобы записи, участвующие в обновлении, были уникальными. Если эти записи не уникальны, оператор завершится с ошибкой "недетерминированное слияние". Если вы видите эту ошибку после обновления до 0.14.0, вы можете решить ее одним из двух способов:

1. Измените логику запроса вашей модели, чтобы убедиться, что указанный параметр `unique_key` действительно уникален
2. Установите конфигурацию `incremental_strategy` в `delete+insert`, чтобы продолжить использовать предыдущий двухэтапный инкрементальный подход

Конфигурацию `incremental_strategy` можно установить в вашем файле `dbt_project.yml` (если вы хотите применить эту конфигурацию ко всем моделям) или ее можно применить в конкретных моделях, где это необходимо.

**Настройка `incremental_strategy` для всех моделей:**

<File name='dbt_project.yml'>

```yaml
# Ваш файл dbt_project.yml

models:
  incremental_strategy: "delete+insert"
```

</File>

**Настройка `incremental_strategy` для одной модели:**

<File name='models/my_model.sql'>

```sql

{{
  config(
    materialized='incremental',
    unique_key='id',
    incremental_strategy='delete+insert'
  )
}}

select ...
```

</File>