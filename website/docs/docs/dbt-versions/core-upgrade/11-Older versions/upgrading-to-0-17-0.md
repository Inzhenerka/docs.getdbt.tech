---
title: "Обновление до 0.17.0"
id: "upgrading-to-0-17-0"
displayed_sidebar: "docs"

---

dbt v0.17.0 делает компиляцию более последовательной, улучшает производительность и исправляет ряд ошибок.

## Статьи:

 - [Список изменений](https://github.com/dbt-labs/dbt-core/blob/dev/octavius-catto/CHANGELOG.md)

## Значительные изменения

Обратите внимание на следующие изменения в версии 0.17.0, которые могут потребовать обновления кода в вашем проекте dbt.

### Новая версия конфигурации dbt_project.yml

dbt v0.17.0 вводит новую версию конфигурации для файла `dbt_project.yml`. Эта новая версия конфигурации изменяет семантику того, как dbt интерпретирует файл `dbt_project.yml`.

#### Указание версии конфигурации

Версию конфигурации можно объявить с помощью ключа `config-version` в файле `dbt_project.yml`:

```yml
name: my_project
version: 1.0.0

config-version: 2

models:
  ...
```

Допустимые значения для `config-version` — это `1` и `2`. При использовании `config-version: 2` открывается новая функциональность в dbt.

#### Использование config-version: 2

##### Улучшенные семантики области видимости переменных

Предыдущие версии dbt позволяли переменным (`vars:`) иметь область видимости на уровне папки в иерархии `models:`. Это создает несколько проблем:

- Переменные должны применяться только к _моделям_ (так как объявление переменной находится в конфигурации `models:`), но переменные также часто ссылаются в тестах, файлах `schema.yml`, макросах, снимках и так далее.
- Существует неоднозначность в том, как переменные разрешаются в файлах `schema.yml`. Рассмотрим случай, когда файл `schema.yml` имеет одну область видимости для переменной, но модель, на которую он ссылается, имеет другую область видимости для той же переменной. Поведение `var()` в этом сценарии плохо определено и часто не соответствует вашим ожиданиям.

В версии 2 конфигурации `dbt_project.yml` переменные теперь должны быть определены в верхнем уровне словаря `vars:`, например:

<File name='dbt_project.yml'>

```yml
name: my_project
version: 1.0.0

config-version: 2

vars:
  my_var: 1
  another_var: true

models:
  ...
```

</File>

Этот синтаксис делает область видимости переменных однозначной, так как все узлы в данном пакете будут получать одно и то же значение для данной переменной. Обратите внимание, что этот синтаксис _по-прежнему_ поддерживает область видимости переменных на уровне пакета. Дополнительную информацию можно найти в документации по синтаксису файла `dbt_project.yml`.

##### Однозначные конфигурации ресурсов

Версия 1 файла `dbt_project.yml` позволяла создавать неоднозначные конфигурации моделей, когда словарные конфигурации определялись в блоке `models:`. Рассмотрим:

<File name='dbt_project.yml'>

```yml
models:
  my_project:
    reporting:
      partition_by:
        field: date_day
        data_type: timestamp

```

</File>

Этот пример предназначен для настройки параметра `partition_by` для всех моделей BigQuery в папке `models/reporting/`. Однако из синтаксиса этого файла можно сделать два возможных вывода:

- Настроить значение `partition_by` для моделей в папке `models/reporting`
- Настроить значения `field` и `data_type` для моделей в папке `models/reporting/partition_by`

Чтобы разрешить эту неоднозначность, теперь конфигурации можно предоставлять с помощью синтаксиса `+` для ключей конфигурации. Для приведенного выше примера это будет выглядеть так:

<File name='dbt_project.yml'>

```yml

models:
  my_project:
    reporting:
      +partition_by:
        field: date_day
        data_type: timestamp
```
</File>

Этот синтаксис однозначно определяет `partition_by` как конфигурацию со словарным значением `{field: date_day, data_type: timestamp}`. Этот декоратор `+` можно использовать для _любой_ конфигурации и он может быть полезен, если у вас есть имя папки, которое совпадает с известным ключом конфигурации проекта dbt. Пример:

<File name='dbt_project.yml'>

```yml
# Ваша модель находится в models/materialized/my_model.sql

models:
  my_project:
    materialized:
      +materialized: table

```
</File>

Эта конфигурация будет работать в dbt v0.17.0 при использовании `config-version: 2`, но не могла быть представлена в предыдущих версиях dbt.

##### Инструкции по обновлению

- Добавьте `config-version: 2` в ваш файл `dbt_project.yml`
- Убедитесь, что все объявления `vars:` в вашем файле `dbt_project.yml` были перемещены на верхний уровень файла
- Убедитесь, что любые пакеты, на которые ссылается ваш проект, также объявлены с `config-version: 2`

Поддержка версии 1 будет удалена в будущих релизах dbt.

### Рендеринг полей YAML с использованием NativeEnvironment

В dbt v0.17.0 dbt включил использование Native Environment Jinja для рендеринга значений в YML файлах. Этот Native Environment преобразует строковые значения в их примитивные типы Python (логические значения, целые числа, числа с плавающей запятой и кортежи). С этим изменением вы теперь можете предоставлять логические и целочисленные значения для конфигураций через строковые входные данные, такие как переменные окружения или переменные командной строки.

:::danger Внимание

  В dbt v0.17.1 рендеринг по умолчанию не включен. Возможно, рендерить конкретные значения с использованием фильтров [`as_bool`](/reference/dbt-jinja-functions/as_bool),
  [`as_number`](/reference/dbt-jinja-functions/as_number) и [`as_native`](/reference/dbt-jinja-functions/as_native).

  Примеры ниже были обновлены, чтобы отразить функциональность 0.17.1.

:::

Этот пример указывает номер порта как целое число из переменной окружения. Это было невозможно в предыдущих версиях dbt.

```yml

debug:
  target: dev
  outputs:
    dev:
      type: postgres
      user: "{{ env_var('DBT_USER') }}"
      password: "{{ env_var('DBT_PASS') }}"
      host: "{{ env_var('DBT_HOST') }}"

      # Номер порта будет преобразован из строки в целое число
      port: "{{ env_var('DBT_PORT') | as_number }}"

      dbname: analytics
      schema: analytics
```

Наконец, вы теперь можете включать или отключать модели условно в зависимости от среды, в которой работает dbt. В этом примере модели в пакете `admin` будут отключены в dev. Это было невозможно в предыдущих версиях dbt.

<File name='dbt_project.yml'>

```yml
name: my_project
version: 1.0.0

config-version: 2

models:
  my_project:
    +enabled: true

  admin:
    +enabled: "{{ (target.name == 'prod') | as_bool }}"
```

</File>

### Доступ к источникам в объекте `graph`

В предыдущих версиях dbt источники в проекте dbt можно было получить в контексте компиляции, используя переменную контекста [graph.nodes](/reference/dbt-jinja-functions/graph). В dbt v0.17.0 эти источники были перемещены из словаря `graph.nodes` в новый словарь `graph.sources`. Это изменение также отражено в артефакте `manifest.json`, создаваемом dbt. Если вы получаете доступ к этим источникам программно, пожалуйста, обновите любые ссылки с `graph.nodes` на `graph.sources`.

### Поле `locations` BigQuery удалено из каталога

В качестве обходного пути для проблем с разрешениями, с которыми сталкивались многие пользователи dbt, поле `location` было удалено из каталога, создаваемого dbt. Соответственно, это поле больше не будет видно на автоматически сгенерированном веб-сайте документации dbt. Это поле может быть добавлено снова в будущих релизах dbt.

### Макросы больше не видят переменные, определенные вне блоков макросов

В предыдущих версиях dbt переменная могла быть объявлена вне области видимости макроса и ссылаться на нее из любых макросов в том же файле:

```jinja
{% set my_global = ['a', 'b', 'c'] %}
{% macro use_my_global() %}
    {% for value in my_global %}
        {% do log('value: ' ~ value) %}
    {% endfor %}
{% endmacro %}
```

Теперь это ошибка, потому что `my_global` недоступна макросу `use_my_global`. Чтобы предоставить значение, доступное глобально, используйте макрос, который возвращает постоянное значение:

```jinja
{% macro get_my_global() %}
    {% do return(['a', 'b', 'c']) %}
{% endmacro %}
{% macro use_my_global() %}
    {% for value in get_my_global() %}
        {% do log('value: ' ~ value) %}
    {% endfor %}
{% endmacro %}
```

## Требования к Python

Если вы устанавливаете dbt в среде Python вместе с другими модулями Python, пожалуйста, обратите внимание на следующие изменения в зависимостях Python dbt:

Core:
- Зафиксированная зависимость `Jinja2` на `2.11.2`
- Зафиксирован `hologram` на `0.0.7`
- Требуется Python >= `3.6.3`

BigQuery:
- Требуется `protobuf>=3.6.0,<3.12`

## Новая и измененная документация

**Core**
- [`path:` селекторы](/reference/node-selection/methods#path)
- [`--fail-fast` команда](/reference/commands/run#failing-fast)
- Фильтр Jinja `as_text`: удален этот устаревший фильтр
- [доступ к узлам в объекте `graph`](/reference/dbt-jinja-functions/graph)
- [persist_docs](/reference/resource-configs/persist_docs)
- [свойства источника](/reference/source-properties)
- [переопределения источников](/reference/resource-properties/overrides)

**BigQuery**
- [maximum_bytes_billed](/docs/core/connect-data-platform/bigquery-setup#maximum-bytes-billed)