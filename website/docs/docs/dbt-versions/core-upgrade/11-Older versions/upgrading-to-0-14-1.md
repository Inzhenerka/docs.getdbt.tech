---
title: "Обновление до 0.14.1"
id: "upgrading-to-0-14-1"
displayed_sidebar: "docs"
---

В выпуске dbt v0.14.1 _нет_ никаких разрушающих изменений в коде для пользователей, обновляющихся с версии v0.14.0. Если вы обновляетесь с версии ниже 0.14.0, ознакомьтесь с руководством по миграции [Обновление до 0.14.0](upgrading-to-0-14-0). В следующем разделе содержится важная информация для пользователей стратегии `check` на Snowflake и BigQuery. Возможно, потребуется предпринять действия в вашей базе данных.

## Изменения в алгоритме "check" для Snapshots

:::caution Snowflake и BigQuery

Следующий раздел применим только к Snapshots, работающим с Snowflake или BigQuery. Если вы используете другую базу данных, то следующий раздел не относится к вашему проекту dbt.

:::

Когда [Snapshot](/docs/build/snapshots) настроен на использование стратегии `check`, dbt будет сравнивать указанные `check_cols` между исходным набором данных и набором данных, находящимся в Snapshot, чтобы определить, изменилась ли строка в Snapshot. Логическая ошибка в выпуске v0.14.0 dbt привела к тому, что эта стратегия не работала, если значения указанных `check_cols` для данной строки возвращались в ранее известное состояние. Важно отметить, что эта проблема затрагивает только Snowflake и BigQuery из-за их соответствующего использования оператора `merge` в Snapshots.

В этом режиме сбоя dbt "финализировал" существующие записи, устанавливая дату `dbt_valid_to` для измененной записи, не вставляя соответствующую новую запись для изменения. **В этом состоянии финализированные записи больше не будут отслеживаться в Snapshot <Term id="table" />**.

### Решение

Чтобы определить, затрагивает ли вашу Snapshot <Term id="table" /> эта проблема, вы можете выполнить запрос для поиска "застрявших" записей. Эти "застрявшие" записи:
 - Являются последними записями для данного `unique_key` в snapshot
 - Имеют значение как для `dbt_valid_from`, так и для `dbt_valid_to`

Следующий запрос вернет строки, которые соответствуют этому критерию:

<File name='snapshot_check_cols_migrate.sql'>

```sql
with base as (

    select *,

        -- Замените `<your unique key>` на ваш указанный unique_key 
        <your unique key> as dbt_unique_key

    -- Замените <your snapshot table> на имя таблицы snapshot
    from <your snapshot table>

),

ranked as (

    select *,
        row_number() over (
            partition by dbt_unique_key
            order by dbt_valid_from desc
        ) as change_idx

    from base

),

to_migrate as (

    select *
    from ranked
    where change_idx = 1
    and dbt_valid_to is not null

)

select * from to_migrate
limit 100;
```

</File>

Если вышеуказанный запрос возвращает ненулевое количество записей, вам необходимо вручную исправить "застрявшие" записи в этой таблице snapshot.

Существует два метода для решения этой проблемы. В любом случае рекомендуется как можно скорее обновить ваши задачи Snapshot до v0.14.1, чтобы предотвратить возникновение этого режима сбоя в последующих snapshots.

### Подход #1: Ручное обновление ваших таблиц snapshot

:::caution Внимание!

Эта миграция требуется только для пользователей стратегии snapshot `check` на Snowflake и BigQuery. Если ваш проект не соответствует этим критериям, то вам не нужно мигрировать ваши таблицы Snapshot.

:::

Запрос, показанный выше, сгенерирует набор строк, которые находятся в "застрявшем" состоянии. Вы можете использовать вывод этого запроса для обновления записей в вашей таблице snapshot, чтобы они стали "разблокированными". Для этого используйте оператор `update`, который устанавливает столбец `dbt_valid_to` в `null` для записей, идентифицированных в запросе выше. **Будьте осторожны при выполнении <Term id="dml" /> непосредственно против таблицы snapshot. Хорошей идеей будет сделать резервную копию этой таблицы перед тем, как вручную применять эту миграцию!** Пример запроса приведен ниже: пожалуйста, тщательно протестируйте этот запрос _перед_ его выполнением в производственной среде.

<File name='fix_snapshot_stuck_records.sql'>

```sql

-- Замените <your snapshot table> на имя таблицы snapshot
update <your snapshot table>
set dbt_valid_to = null
where dbt_scd_id in (

  with base as (

      select *,

          -- Замените `<your unique key>` на ваш указанный unique_key 
          <your unique key> as dbt_unique_key

      -- Замените <your snapshot table> на имя таблицы Snapshot
      from <your snapshot table>

  ),

  ranked as (

      select *,
          row_number() over (
              partition by dbt_unique_key
              order by dbt_valid_from desc
          ) as change_idx

      from base

  ),

  to_migrate as (

      select *
      from ranked
      where change_idx = 1
      and dbt_valid_to is not null

  )
 
  select dbt_scd_id from to_migrate

);
```

</File>

### Подход #2: Удаление существующих таблиц snapshot

:::caution Внимание!

Эта миграция требуется только для пользователей стратегии snapshot `check` на Snowflake и BigQuery. Если ваш проект не соответствует этим критериям, то вам не нужно мигрировать ваши таблицы Snapshot.

:::

Если вы только недавно начали создавать snapshots таблиц с использованием стратегии `check`, вы можете просто удалить существующие таблицы snapshot и начать запись новых таблиц snapshot с нуля. **В общем, вы должны быть очень осторожны при ручной работе с таблицами snapshot. Будьте очень внимательны при удалении таблиц Snapshot.** Если вы решите пойти по этому пути, вы _потеряете_ данные. Уравновесьте этот компромисс с сложностью, указанной в первом подходе.

### Получение помощи

Мы рады помочь с этой миграцией, если у вас есть какие-либо вопросы или проблемы. Пожалуйста, дайте нам знать [в Slack](https://community.getdbt.com), если вам нужна помощь!