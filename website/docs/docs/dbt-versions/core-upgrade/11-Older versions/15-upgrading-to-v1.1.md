---
title: "Обновление до v1.1"
description: Новые функции и изменения в dbt Core v1.1
id: "upgrading-to-v1.1"
displayed_sidebar: "docs"
---

### Ресурсы

- [Журнал изменений](https://github.com/dbt-labs/dbt-core/blob/1.1.latest/CHANGELOG.md)
- [Руководство по установке dbt Core CLI](/docs/core/installation-overview)
- [Руководство по обновлению в облаке](/docs/dbt-versions/upgrade-dbt-version-in-cloud)

## Что нужно знать перед обновлением

Нет никаких разрушающих изменений для кода в проектах и пакетах dbt. Мы стремимся обеспечить обратную совместимость для всех версий 1.x. Если вы столкнетесь с ошибкой при обновлении, пожалуйста, дайте нам знать, [открыв проблему](https://github.com/dbt-labs/dbt-core/issues/new).

### Для поддерживающих адаптеры

Мы переработали тестовый пакет для функциональности адаптеров. Для получения подробной информации о новом тестовом пакете обратитесь к шагу "Протестируйте ваш адаптер" в руководстве [Создание, тестирование, документирование и продвижение адаптеров](/guides/adapter-creation).

Абстрактные методы `get_response` и `execute` теперь возвращают только `connection.AdapterReponse` в подсказках типов. Ранее они могли возвращать строку. Мы рекомендуем вам обновить ваши методы, чтобы они возвращали объект класса `AdapterResponse`, или реализовать подкласс, специфичный для вашего адаптера. Это также дает вам возможность добавить поля, специфичные для выполнения запросов вашего адаптера, такие как `rows_affected` или `bytes_processed`.

### Для пользователей артефактов dbt (метаданные)

Версия схемы манифеста будет обновлена до v5. Единственное изменение касается значения по умолчанию для `config` для разобранных узлов.

Для пользователей [функциональности на основе состояния](/reference/node-selection/syntax#about-node-selection), такой как селектор `state:modified`, помните, что:

> Артефакты `--state` должны быть совместимы с версиями схем, которые соответствуют текущей версии dbt.

Если у вас есть две задачи, одна из которых сравнивает или ссылается на артефакты, созданные другой, вам нужно будет обновить обе одновременно. Если произойдет несоответствие, dbt уведомит вас об этом сообщением об ошибке:

```
Ожидалась версия схемы "https://schemas.getdbt.com/dbt/manifest/v5.json" в <state-path>/manifest.json, но найдена "https://schemas.getdbt.com/dbt/manifest/v4.json". Вы используете другую версию dbt?
```

## Новая и измененная документация

[**Инкрементальные модели**](/docs/build/incremental-models) теперь могут принимать список нескольких столбцов в качестве `unique_key`, для моделей, которым необходимо сочетание столбцов для уникальной идентификации каждой строки. Это поддерживается большинством распространенных <Term id="data-warehouse">хранилищ данных</Term> для инкрементальных стратегий, использующих конфигурацию `unique_key` (`merge` и `delete+insert`).

[**Общие тесты**](/reference/resource-properties/data-tests) могут определять пользовательские имена. Это полезно для "украшения" синтетического имени, которое dbt применяет автоматически. Это необходимо для устранения неоднозначности в случае, если один и тот же общий тест определяется несколько раз с разными конфигурациями.

[**Источники**](/reference/source-properties) могут определять конфигурацию встраиваемым образом с другими свойствами `.yml`, так же как и другие типы ресурсов. Единственной поддерживаемой конфигурацией является `enabled`; вы можете использовать это для динамического включения/выключения источников в зависимости от переменных окружения или пакетов.

### Расширенная и экспериментальная функциональность

**Свежие перестройки.** Появился новый _экспериментальный_ метод выбора: [`source_status:fresher`](/reference/node-selection/methods#source_status). Подобно методам `state:` и `result`, цель состоит в том, чтобы использовать метаданные dbt для более эффективного выполнения вашего DAG. Если dbt имеет доступ к предыдущим и текущим результатам `dbt source freshness` (артефакт `sources.json`), dbt может сравнить их, чтобы определить, какие источники загрузили новые данные, и выбрать только ресурсы, находящиеся ниже по потоку от "свежих" источников. Узнайте больше в [Понимание состояния](/reference/node-selection/syntax#about-node-selection) и [CI/CD в dbt Cloud](/docs/deploy/continuous-integration).

[**Функции dbt-Jinja**](/reference/dbt-jinja-functions) имеют новую целевую страницу и двух новых участников:
- [`print`](/reference/dbt-jinja-functions/print) предоставляет функцию Python `print()`. Она может использоваться как альтернатива `log()`, и вместе с конфигурацией `QUIET` для сложных макро-ориентированных рабочих процессов.
- [`selected_resources`](/reference/dbt-jinja-functions/selected_resources) предоставляет в режиме выполнения список узлов DAG, выбранных текущей задачей.

[**Глобальные конфигурации**](/reference/global-configs/about-global-configs) включают несколько новых дополнений:

- `QUIET` и `NO_PRINT`, для управления тем, какие сообщения журнала dbt выводит в терминал. Для использования в сложных макро-ориентированных рабочих процессах, таких как [codegen](https://hub.getdbt.com/dbt-labs/codegen/latest/).
- `CACHE_SELECTED_ONLY` — это _экспериментальная_ конфигурация, которая может значительно ускорить подготовку dbt к запуску, в случаях, когда вы запускаете только несколько моделей из большого проекта, который управляет многими схемами.

### Для пользователей конкретных адаптеров

**dbt-bigquery** добавил поддержку <Term id="grain">более детальной</Term> конфигурации времени ожидания запросов и повторных попыток при определении вашего [профиля подключения](/docs/core/connect-data-platform/bigquery-setup).

**dbt-spark** добавил поддержку [`метода подключения session`](/docs/core/connect-data-platform/spark-setup#session) для использования с сессией pySpark, чтобы поддерживать быструю итерацию при разработке сложной или экспериментальной функциональности. Этот метод подключения не рекомендуется для новых пользователей и не поддерживается в dbt Cloud.

### Зависимости

[Совместимость с Python](/faqs/Core/install-python-compatibility): dbt Core официально поддерживает Python 3.10.