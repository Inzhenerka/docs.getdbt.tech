---
title: "Обновление до v1.7"
id: upgrading-to-v1.7
description: Новые функции и изменения в dbt Core v1.7
displayed_sidebar: "docs"
---

## Ресурсы

- [Журнал изменений](https://github.com/dbt-labs/dbt-core/blob/1.7.latest/CHANGELOG.md)
- [Руководство по установке dbt Core CLI](/docs/core/installation-overview)
- [Руководство по обновлению в облаке](/docs/dbt-versions/upgrade-dbt-version-in-cloud)
- [График релизов](https://github.com/dbt-labs/dbt-core/issues/8260)

## Что нужно знать перед обновлением

dbt Labs стремится обеспечить обратную совместимость для всех версий 1.x, за исключением изменений, явно упомянутых ниже. Если вы столкнулись с ошибкой при обновлении, пожалуйста, дайте нам знать, [открыв проблему](https://github.com/dbt-labs/dbt-core/issues/new).

### Изменения в поведении

dbt Core v1.7 расширяет количество источников, для которых вы можете настраивать свежесть. Ранее свежесть ограничивалась источниками с `loaded_at_field`; теперь свежесть может быть сгенерирована из метаданных таблиц хранилища, когда это возможно.

В рамках этого изменения `loaded_at_field` больше не требуется для генерации свежести источника. Если у источника есть блок `freshness:`, dbt попытается рассчитать свежесть для этого источника:
- Если предоставлено `loaded_at_field`, dbt будет рассчитывать свежесть с помощью запроса select (предыдущее поведение).
- Если `loaded_at_field` _не_ предоставлено, dbt будет рассчитывать свежесть с помощью метаданных таблиц хранилища, когда это возможно (новое поведение).

Это относительно небольшое изменение в поведении, но стоит отметить, если вы заметите, что dbt рассчитывает свежесть для _большего_ количества источников, чем раньше. Чтобы исключить источник из расчетов свежести, у вас есть два варианта:
1. Не добавлять блок `freshness:`.
2. Явно установить `freshness: null`.

Начиная с v1.7, выполнение [`dbt deps`](/reference/commands/deps) создает или обновляет файл `package-lock.yml` в _project_root_, где записан `packages.yml`. Файл `package-lock.yml` содержит запись обо всех установленных пакетах, и если последующие запуски `dbt deps` не содержат обновленных пакетов в `dependencies.yml` или `packages.yml`, dbt-core устанавливает из `package-lock.yml`.

Чтобы сохранить поведение, предшествующее v1.7, есть два основных варианта:
1. Используйте `dbt deps --upgrade` везде, где ранее использовался `dbt deps`.
2. Добавьте `package-lock.yml` в ваш файл `.gitignore`.

## Новые и измененные функции и функциональность

- [`dbt docs generate`](/reference/commands/cmd-docs) теперь поддерживает `--select` для генерации [каталогов метаданных](/reference/artifacts/catalog-json) для подмножества вашего проекта. В настоящее время доступно только для Snowflake и Postgres, но другие адаптеры скоро появятся.
- [Свежесть источников](/docs/deploy/source-freshness) теперь может быть сгенерирована из метаданных таблиц хранилища, в настоящее время только для Snowflake, но другие адаптеры с метаданными таблицами скоро появятся.

### Улучшения MetricFlow

- Автоматическое создание метрик для мер с [`create_metric: true`](/docs/build/semantic-models).
- Необязательный [`label`](/docs/build/semantic-models) в семантических моделях, мерах, измерениях и сущностях.
- Новые конфигурации для семантических моделей - [включить/выключить](/reference/resource-configs/enabled), [группа](/reference/resource-configs/group) и [мета](/reference/resource-configs/meta).
- Поддержка `fill_nulls_with` и `join_to_timespine` для узлов метрик.
- `saved_queries` расширяет управление за пределы семантических объектов до их потребления.

### Для потребителей артефактов dbt (метаданные)

- Версия схемы [manifest](/reference/artifacts/manifest-json) была обновлена до v11.
- Версия схемы [run_results](/reference/artifacts/run-results-json) была обновлена до v5.
- Есть несколько конкретных изменений в [catalog.json](/reference/artifacts/catalog-json):
    - Добавлены [атрибуты узлов](/reference/artifacts/run-results-json), связанные с компиляцией (`compiled`, `compiled_code`, `relation_name`) в `catalog.json`.
    - Словарь узлов в `catalog.json` теперь может быть "частичным", если `dbt docs generate` выполняется с селектором.

### Управление моделями

dbt Core v1.5 представил управление моделями, которое мы продолжаем уточнять. v1.7 включает в себя эти дополнительные функции и функциональность:

- **[Обнаружение разрушающих изменений](/reference/resource-properties/versions#detecting-breaking-changes) для моделей с обязательными контрактами:** Когда dbt обнаруживает разрушающее изменение в модели с обязательным контрактом во время сравнения состояния, он теперь будет выдавать ошибку для версионированных моделей и предупреждение для моделей, которые не являются версионированными.
- **[Установить `access` как конфигурацию](/reference/resource-configs/access):** Теперь вы можете установить `access` модели в блоках конфигурации в файле модели или в `dbt_project.yml` для всей подпапки сразу.
- **[Типовое алиасирование для контрактов моделей](/reference/resource-configs/contract):** dbt будет использовать встроенное алиасирование типов каждого адаптера для пользовательских типов данных, что означает, что вы теперь можете всегда писать `string`, и dbt будет переводить это в `text` на Postgres/Redshift. Это включено по умолчанию, но вы можете отказаться от этого.
- **[Выдавать предупреждение для числовых типов](/reference/resource-configs/contract):** Из-за проблем при использовании `numeric` в контрактах моделей без учета того, что значения по умолчанию, такие как `numeric(38,0)`, могут округлять десятичные значения соответственно. Теперь dbt будет предупреждать вас, если он найдет числовой тип без указанной точности/масштаба.

### dbt clean

Начиная с v1.7, `dbt clean` будет очищать только пути в текущем рабочем каталоге. Флаг `--no-clean-project-files-only` удалит все пути, указанные в `clean-paths`, даже если они находятся за пределами проекта dbt.

Поддерживаемые флаги:
-  `--clean-project-files-only` (по умолчанию) 
-  `--no-clean-project-files-only`

### Дополнительные атрибуты в run_results.json

Файл run_results.json теперь включает три атрибута, связанные с состоянием `applied`, которые дополняют `unique_id`:

- `compiled`: Логическое значение статуса компиляции узла (`False` после разбора, но `True` после компиляции).
- `compiled_code`: Отрендеренная строка кода, который был скомпилирован (пусто после разбора, но полная строка после компиляции).
- `relation_name`: Полное имя объекта, который был (или будет) создан/обновлен в базе данных.

### Устаревшая функциональность

Возможность для установленных пакетов переопределять встроенные материализации без явного согласия пользователя устаревает.

- Переопределение встроенной материализации из установленного пакета вызывает предупреждение об устаревании.
- Использование пользовательской материализации из установленного пакета не вызывает предупреждения об устаревании.
- Использование переопределения встроенной материализации пакета из корневого проекта через обертывающую материализацию по-прежнему поддерживается. Например:

  ```
  {% materialization view, default %}
  {{ return(my_cool_package.materialization_view_default()) }}
  {% endmaterialization %}
  ```

### Быстрые обновления

С этими быстрыми обновлениями вы теперь можете:
- Настроить [`delimiter`](/reference/resource-configs/delimiter) для seed файла.
- Использовать пакеты с одним и тем же git репозиторием и уникальной подпапкой.
- Получить доступ к макросу `date_spine` напрямую из dbt-core (перемещен из dbt-utils).
- Синтаксис для `DBT_ENV_SECRET_` изменился на `DBT_ENV_SECRET` и больше не требует закрывающего подчеркивания.