---
title: "Зависимости проекта"
id: project-dependencies
sidebar_label: "Зависимости проекта"
description: "Использование публичных моделей из других проектов dbt"
pagination_next: null
keyword: dbt mesh, project dependencies, ref, cross project ref, project dependencies
---

# Зависимости проекта <Lifecycle status='managed,managed_plus'/>

<IntroText>

Доступно на тарифных планах dbt [Enterprise или Enterprise+](https://www.getdbt.com/pricing).

</IntroText>

Хотя это отличный способ повторного использования кода, обмена утилитарными макросами и создания отправной точки для общих преобразований, это не лучший способ для обеспечения сотрудничества между командами и в масштабах, особенно в крупных организациях.

Хотя это отличный способ повторно использовать код, делиться служебными макросами и задавать стартовую точку для типовых преобразований, он плохо подходит для организации совместной работы между командами и для масштабирования, особенно в крупных организациях.

dbt Labs поддерживает расширенное понимание `dependencies` между несколькими dbt‑проектами:
- **Packages** &mdash; знакомый и уже существующий тип зависимости. Вы подключаете такую зависимость, устанавливая полный исходный код пакета (аналогично программной библиотеке).
- **Projects** &mdash; способ dbt брать зависимость от другого проекта. Используя сервис метаданных, работающий «за кулисами», <Constant name="cloud" /> на лету разрешает ссылки на публичные модели, определённые в других проектах. Вам не нужно самостоятельно парсить или запускать эти апстрим‑модели. Вместо этого вы рассматриваете зависимость от них как API, которое возвращает датасет. Ответственность за качество и стабильность публичной модели несёт её владелец.

## Предварительные требования
- Доступно в [<Constant name="cloud" /> Enterprise или Enterprise+](https://www.getdbt.com/pricing). Чтобы использовать эту возможность, необходимо назначить [public model](/docs/mesh/govern/model-access) и добавить [cross-project ref](#how-to-write-cross-project-ref).
- Требования к настройке апстрим‑проекта («producer»):
  - Настройте модели в апстрим‑проекте с параметром [`access: public`](/reference/resource-configs/access) и выполните как минимум один успешный запуск job после задания `access`.
  - Определите [Production deployment environment](/docs/deploy/deploy-environments#set-as-production-environment) в апстрим‑проекте и убедитесь, что там успешно отработал как минимум _один deployment job_. Этот job должен сгенерировать файл [`manifest.json`](/reference/artifacts/manifest-json) &mdash; он содержит метаданные, необходимые для даунстрим‑проектов.
  - Если в апстрим‑проекте есть Staging‑окружение, выполните там как минимум один успешный deployment job, чтобы обеспечить корректное разрешение cross‑project ссылок в даунстрим‑проектах.
- Имя каждого проекта (`name`) должно быть уникальным в рамках вашего аккаунта <Constant name="cloud" />. Например, если у вас есть dbt‑проект (кодовая база) для команды `jaffle_marketing`, не создавайте отдельные проекты `Jaffle Marketing - Dev` и `Jaffle Marketing - Prod`; вместо этого используйте [изоляцию на уровне окружений](/docs/dbt-cloud-environments#types-of-environments).
  - <Constant name="cloud" /> поддерживает [Connections](/docs/cloud/connect-data-platform/about-connections#connection-management), доступные всем пользователям <Constant name="cloud" />. Connections позволяют использовать разные подключения к платформе данных для разных окружений, устраняя необходимость дублировать проекты. Проекты могут использовать несколько подключений одного и того же типа хранилища. Connections переиспользуются между проектами и окружениями.
- Файл `dbt_project.yml` чувствителен к регистру, поэтому имя проекта должно **точно** совпадать с именем, указанным в `dependencies.yml`. Например, `jaffle_marketing`, а не `JAFFLE_MARKETING`.

import UseCaseInfo from '/snippets/_packages_or_dependencies.md';

<UseCaseInfo/>

## Пример

Например, предположим, что вы работаете в команде маркетинга в Jaffle Shop. Имя проекта вашей команды - `jaffle_marketing`:

<File name="dbt_project.yml">

```yml
name: jaffle_marketing
```

</File>

В рамках моделирования маркетинговых данных вам нужно взять зависимость от двух других проектов:
- `dbt_utils` как [пакет](#packages-use-case): Коллекция утилитарных макросов, которые вы можете использовать при написании SQL для своих моделей. Этот пакет является открытым и поддерживается dbt Labs.
- `jaffle_finance` как [проектный кейс](#projects-use-case): Модели данных о доходах Jaffle Shop. Этот проект является частным и поддерживается вашими коллегами из финансовой команды. Вы хотите выбрать некоторые из финальных моделей этого проекта в качестве отправной точки для своей работы.

<File name="dependencies.yml">

```yml
packages:
  - package: dbt-labs/dbt_utils
    version: 1.1.1

projects:
  - name: jaffle_finance  # чувствителен к регистру и соответствует 'name' в 'dbt_project.yml'
```

</File>

Что здесь происходит?

Пакет `dbt_utils` &mdash; Когда вы запускаете `dbt deps`, dbt загружает полный контент этого пакета (более 100 макросов) как исходный код и добавляет его в вашу среду. Вы можете затем вызывать любой макрос из пакета, так же как вы можете вызывать макросы, определенные в вашем собственном проекте.

Проекты `jaffle_finance` — это новый сценарий. В отличие от установки пакета, модели из проекта `jaffle_finance` **не** будут загружены как исходный код и разобраны (parsed) в вашем проекте. Вместо этого <Constant name="cloud" /> предоставляет сервис метаданных, который разрешает ссылки на [**публичные модели**](/docs/mesh/govern/model-access), определённые в проекте `jaffle_finance`.

### Преимущества

Когда вы строите что‑то поверх работы другой команды, разрешение ссылок таким образом даёт несколько преимуществ:

- Вы используете осознанно спроектированный интерфейс, обозначенный владельцем модели с помощью `access: public`.
- Вы сохраняете узкий фокус своего проекта и избегаете лишних ресурсов и сложности. Это быстрее для вас и быстрее для dbt.
- Вам не нужно дублировать какую‑либо условную конфигурацию вышестоящего проекта, такую как `vars`, переменные окружения или `target.name`. Вы можете напрямую ссылаться на модели там, где команда Finance собирает их в продакшене. Даже если команда Finance внесёт изменения — например, переименует модель, изменит имя схемы или [повысит её версию](/docs/mesh/govern/model-versions), — ваш `ref` всё равно будет успешно разрешаться.
- Вы исключаете риск случайной сборки этих моделей с помощью `dbt run` или `dbt build`. Хотя вы можете выбрать эти модели, вы не можете фактически их собрать. Это предотвращает неожиданные затраты на хранилище данных и проблемы с правами доступа, а также обеспечивает корректное владение и распределение затрат для моделей каждой команды.

### Как написать межпроектную ссылку

**Написание `ref`:** Модели, на которые ссылаются из зависимости типа `project`, должны использовать [двухаргументную `ref`](/reference/dbt-jinja-functions/ref#ref-project-specific-models), включая имя проекта:

<File name="models/marts/roi_by_channel.sql">

```sql
with monthly_revenue as (
  
    select * from {{ ref('jaffle_finance', 'monthly_revenue') }}

),

...

```

</File>

#### Обнаружение циклов

import CycleDetection from '/snippets/_mesh-cycle-detection.md';

<CycleDetection />

Для получения дополнительных рекомендаций по использованию <Constant name="mesh" /> см. специализированное [руководство по <Constant name="mesh" />](/best-practices/how-we-mesh/mesh-1-intro), а также наш бесплатный [обучающий курс по <Constant name="mesh" />](https://learn.getdbt.com/courses/dbt-mesh).

### Защита производственных данных с помощью промежуточных сред

При работе в среде разработки, межпроектные `ref` обычно разрешаются в производственную среду проекта. Однако, чтобы защитить производственные данные, настройте [среду развертывания Staging](/docs/deploy/deploy-environments#staging-environment) в ваших проектах.

При наличии в проекте staging-окружения <Constant name="mesh" /> автоматически получает публичную информацию о моделях из staging-окружения продюсера, если консьюмер также работает в staging. Аналогично, <Constant name="mesh" /> получает данные из production-окружения продюсера, если консьюмер работает в production. Это обеспечивает согласованность между окружениями и добавляет уровень безопасности, предотвращая доступ к production-данным в процессе разработки.

Прочтите [Почему использовать промежуточную среду](/docs/deploy/deploy-environments#why-use-a-staging-environment) для получения дополнительной информации о преимуществах.

#### Промежуточная среда с нисходящими зависимостями

<Constant name="cloud" /> начинает использовать окружение Staging для разрешения межпроектных ссылок из downstream‑проектов сразу после того, как это окружение появляется в проекте, без «fail-over» на Production. Это означает, что <Constant name="cloud" /> будет последовательно использовать метаданные из окружения Staging для разрешения ссылок в downstream‑проектах, даже если в настроенном окружении Staging ещё не было ни одного успешного запуска.

Чтобы избежать простоя для нисходящих разработчиков, вы должны определить и запустить задание перед тем, как пометить среду как промежуточную:

1. Создайте новую среду, но НЕ помечайте ее как **Staging**.
2. Определите задание в этой среде.
3. Запустите задание и убедитесь, что оно завершилось успешно.
4. Обновите среду, чтобы пометить ее как **Staging**.

### Сравнение

Если бы вы вместо этого установили проект `jaffle_finance` как зависимость `package`, вы бы загружали его полный исходный код и добавляли его в свою среду выполнения. Это означает:
- dbt нужно разбирать и разрешать больше входных данных (что медленнее)
- dbt ожидает, что вы настроите эти модели так, как если бы они были вашими собственными (с `vars`, переменными среды и т.д.)
- dbt будет запускать эти модели как ваши собственные, если вы явно не `--exclude` их
- Вы могли бы использовать модели проекта таким образом, который их поддерживающий (финансовая команда) не предполагал

Существуют несколько случаев, когда установка другого внутреннего проекта как пакета может быть полезной:
- Объединенные развертывания &mdash; В производственной среде, если центральная команда платформы данных Jaffle Shop хотела бы запланировать развертывание моделей как в `jaffle_finance`, так и в `jaffle_marketing`, они могли бы использовать [синтаксис выбора](/reference/node-selection/syntax) dbt для создания нового "проходного" проекта, который устанавливает оба проекта как пакеты.
- Скоординированные изменения &mdash; В разработке, если вы хотите протестировать эффекты изменения публичной модели в вышестоящем проекте (`jaffle_finance.monthly_revenue`) на нисходящей модели (`jaffle_marketing.roi_by_channel`) _до_ внесения изменений в промежуточную или производственную среду, вы можете установить пакет `jaffle_finance` как пакет в `jaffle_marketing`. Установка может указывать на конкретную ветку git, однако, если вы часто нуждаетесь в проведении сквозного тестирования между обоими проектами, мы рекомендуем пересмотреть, представляет ли это стабильную границу интерфейса.

Это исключения, а не правило. Установка проекта другой команды как пакета добавляет сложность, задержку и риск ненужных затрат. Определяя четкие границы интерфейса между командами, предоставляя публичные модели одной команды как "API" для другой, и позволяя практикам разрабатывать с более узко определенной областью, мы можем позволить большему количеству людей вносить вклад с большей уверенностью, требуя при этом меньше контекста заранее.

## Часто задаваемые вопросы

<FAQ path="Project_ref/define-private-packages" />
<FAQ path="Project_ref/indirectly-reference-upstream-model" />

## Связанные материалы
- Подробнее о том, как использовать <Constant name="mesh" />, см. руководство [<Constant name="mesh" />](/best-practices/how-we-mesh/mesh-1-intro).
- [Быстрый старт с <Constant name="mesh" />](/guides/mesh-qs)
