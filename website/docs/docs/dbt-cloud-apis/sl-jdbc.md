---
title: "JDBC"
id: sl-jdbc
description: "Интеграция и использование API JDBC для запроса ваших метрик."
tags: [Семантический уровень, API]
---

API Java Database Connectivity (JDBC) семантического уровня dbt позволяет пользователям запрашивать метрики и измерения с использованием протокола JDBC, а также предоставляет стандартные функции метаданных.

Драйвер JDBC — это программный компонент, позволяющий Java-приложению взаимодействовать с платформой данных. Вот дополнительная информация о нашем API JDBC:

- API JDBC семантического уровня использует драйвер JDBC с открытым исходным кодом с протоколом ArrowFlight SQL.
- Вы можете скачать драйвер JDBC с [Maven](https://search.maven.org/remotecontent?filepath=org/apache/arrow/flight-sql-jdbc-driver/12.0.0/flight-sql-jdbc-driver-12.0.0.jar).
- Семантический уровень dbt поддерживает драйвер ArrowFlight SQL версии 12.0.0 и выше.
- Вы можете встроить драйвер в свой стек приложений по мере необходимости, и вы можете использовать [пример проекта](https://github.com/dbt-labs/example-semantic-layer-clients) от dbt Labs в качестве справки.
- Если вы партнер или пользователь, создающий собственное приложение, вам нужно будет установить корневой сертификат AWS CA в документацию по Java Trust [документации](https://www.amazontrust.com/repository/) (специфично для Java и вызовов JDBC).

Партнеры dbt Labs могут использовать API JDBC для создания интеграций в своих инструментах с семантическим уровнем dbt.

## Использование API JDBC

Если вы являетесь пользователем dbt или партнером с доступом к dbt Cloud и [семантическому уровню dbt](/docs/use-dbt-semantic-layer/dbt-sl), вы можете [настроить](/docs/use-dbt-semantic-layer/setup-sl) и протестировать этот API с данными из вашего собственного экземпляра, настроив семантический уровень и получив правильные параметры подключения JDBC, описанные в этом документе.

Вы *можете* использовать наш API JDBC с инструментами, которые не имеют официальной интеграции с семантическим уровнем dbt. Если используемый вами инструмент позволяет писать SQL и поддерживает опцию общего драйвера JDBC (например, DataGrip) или поддерживает Dremio и использует драйвер ArrowFlightSQL версии 12.0.0 или выше, вы можете получить доступ к API семантического уровня.

Смотрите [Начало работы с семантическим уровнем dbt](/guides/sl-snowflake-qs) для получения дополнительной информации.

Обратите внимание, что API семантического уровня dbt не поддерживает `ref` для вызова объектов dbt. Вместо этого используйте полное квалифицированное имя таблицы. Если вы используете макросы dbt во время запроса для расчета ваших метрик, вам следует переместить эти расчеты в определения метрик семантического уровня в виде кода.

## Аутентификация

dbt Cloud авторизует запросы к API семантического уровня dbt. Вам необходимо предоставить идентификатор окружения, хост и [токены сервисной учетной записи](/docs/dbt-cloud-apis/service-tokens).

## Параметры подключения

Подключение JDBC требует несколько различных параметров подключения.

Вот пример строки подключения URL и отдельных компонентов:

```
jdbc:arrow-flight-sql://semantic-layer.cloud.getdbt.com:443?&environmentId=202339&token=SERVICE_TOKEN
```

| Параметр JDBC | Описание | Пример |
| -------------- | ----------- | ------- |
| `jdbc:arrow-flight-sql://` | Протокол для драйвера JDBC. | `jdbc:arrow-flight-sql://` |
| `semantic-layer.cloud.getdbt.com` | [URL доступа](/docs/cloud/about-cloud/access-regions-ip-addresses) для региона dbt Cloud вашего аккаунта. Вы всегда должны добавлять префикс `semantic-layer` перед URL доступа. | Для развертывания dbt Cloud, размещенного в Северной Америке, используйте `semantic-layer.cloud.getdbt.com` |
| `environmentId` | Уникальный идентификатор для производственной среды dbt, вы можете получить его из URL dbt Cloud <br /> когда вы переходите в **Environments** под **Deploy**. | Если ваш URL заканчивается на `.../environments/222222`, ваш `environmentId` равен `222222`<br /><br />   |
| `SERVICE_TOKEN` | dbt Cloud [токен сервиса](/docs/dbt-cloud-apis/service-tokens) с разрешениями "Только семантический уровень" и "Только метаданные". Создайте новый токен сервиса на странице **Настройки аккаунта**. | `token=SERVICE_TOKEN` |

*Примечание &mdash; Если вы тестируете локально на инструменте, таком как DataGrip, вам также может потребоваться предоставить следующую переменную в конце или начале URL JDBC `&disableCertificateVerification=true`.

## Запрос метаданных метрик через API

API JDBC семантического уровня имеет встроенные вызовы метаданных, которые могут предоставить пользователю информацию о его метриках и измерениях.

Разверните следующие переключатели для примеров и команд метаданных:

<Expandable alt_header="Получить определенные метрики">

Вы можете использовать этот запрос, чтобы получить все определенные метрики в вашем проекте dbt:

```bash
select * from {{ 
	semantic_layer.metrics() 
}}
```
</Expandable>

<Expandable alt_header="Получить измерение для метрики">

Вы можете использовать этот запрос, чтобы получить все измерения для метрики.

Обратите внимание, что метрики являются обязательным аргументом, который перечисляет одну или несколько метрик.

```bash
select * from {{ 
    semantic_layer.dimensions(metrics=['food_order_amount'])}}
```
</Expandable>

<Expandable alt_header="Получить значения измерений">

Вы можете использовать этот запрос, чтобы получить значения измерений для одной или нескольких метрик и одного измерения.

Обратите внимание, что метрики являются обязательным аргументом, который перечисляет одну или несколько метрик, и одно измерение.

```bash
select * from {{ 
semantic_layer.dimension_values(metrics=['food_order_amount'], group_by=['customer__customer_name'])}}
```
</Expandable>

<Expandable alt_header="Получить гранулярности для метрик">

Вы можете использовать этот запрос, чтобы получить запрашиваемые гранулярности для списка метрик.

Этот запрос API позволяет показывать только временные гранулярности, которые имеют смысл для первичного временного измерения метрик (таких как metric_time), но если вы хотите запрашиваемые гранулярности для других временных измерений, вы можете использовать вызов dimensions() и найти столбец queryable_granularities.

Обратите внимание, что метрики являются обязательным аргументом, который перечисляет одну или несколько метрик.
```bash
select * from {{
    semantic_layer.queryable_granularities(metrics=['food_order_amount', 'order_gross_profit'])}}
```

</Expandable>

<Expandable alt_header="Получить доступные метрики с учетом измерений">

Вы можете использовать этот запрос, чтобы получить доступные метрики с учетом измерений. Эта команда по сути является противоположной получению измерений с учетом списка метрик.

Обратите внимание, что group_by является обязательным аргументом, который перечисляет одно или несколько измерений.

```bash
select * from {{
    semantic_layer.metrics_for_dimensions(group_by=['customer__customer_type'])
}}
```

</Expandable>

<Expandable alt_header="Получить гранулярности для всех временных измерений">

Вы можете использовать этот пример запроса, чтобы получить доступные гранулярности для всех временных измерений (аналогичный вызов API запрашиваемых гранулярностей возвращает только гранулярности для первичных временных измерений для метрик).

Следующий вызов является производным от вызова dimensions() и специально выбирает поле гранулярности.

```bash
select NAME, QUERYABLE_GRANULARITIES from {{
    semantic_layer.dimensions(
        metrics=["order_total"]
    )
}}
```

</Expandable>

<Expandable alt_header="Получить имена первичных временных измерений">

В вашем приложении может быть полезно раскрыть имена временных измерений, которые представляют metric_time или общую нить для всех метрик.

Сначала вы можете запросить аргумент metrics() для получения списка мер, затем использовать вызов measures(), который вернет имя(имена) временных измерений, которые составляют временную метрику.

```bash
select * from {{
    semantic_layer.measures(metrics=['orders'])
}}
```

</Expandable>

<Expandable alt_header="Получить метрики по подстроке">

Вы можете отфильтровать свои метрики, чтобы включить только те, которые содержат определенную подстроку (последовательность символов, содержащуюся в более длинной строке (тексте)). Используйте аргумент `search`, чтобы указать подстроку, которую вы хотите сопоставить.

```sql
select * from {{ semantic_layer.metrics(search='order') }}
```

Если подстрока не указана, запрос вернет все метрики.

</Expandable> 

<Expandable alt_header="Пагинация вызовов метаданных">

В случае, если вы не хотите возвращать полный набор результатов из вызова метаданных, вы можете разбить результаты на страницы для вызовов `semantic_layer.metrics()` и `semantic_layer.dimensions()`, используя параметры `page_size` и `page_number`.

- `page_size`: Это необязательная переменная, которая устанавливает количество записей на странице. Если оставить как None, ограничения по страницам нет.
- `page_number`: Это необязательная переменная, которая указывает номер страницы для получения. По умолчанию равен `1` (первая страница), если не указано.

Примеры:

```sql
-- Получает 5-ю страницу с размером страницы 10 метрик
select * from {{ semantic_layer.metrics(page_size=10, page_number=5) }}

-- Получает 1-ю страницу с размером страницы 10 метрик
select * from {{ semantic_layer.metrics(page_size=10) }}

-- Получает все метрики без пагинации
select * from {{ semantic_layer.metrics() }}
```

Вы можете использовать те же параметры пагинации для `semantic_layer.dimensions(...)`.
</Expandable> 

<Expandable alt_header="Список сохраненных запросов">

Вы можете использовать этот пример запроса, чтобы перечислить все доступные сохраненные запросы в вашем проекте dbt.

**Команда**

```bash
select * from semantic_layer.saved_queries()
```

**Вывод**

```bash
| NAME | DESCRIPTION | LABEL | METRICS | GROUP_BY | WHERE_FILTER |
```

</Expandable>

## Запрос значений метрик через API

Чтобы запросить значения метрик, доступны следующие параметры. Ваш запрос должен содержать _либо_ параметр `metric`, **либо** параметр `group_by`, чтобы быть действительным.

| Параметр | <div style={{width:'400px'}}>Описание</div>  | <div style={{width:'100px'}}>Пример</div>  | 
| --------- | -----------| ------------ |
| `metrics`   | Имя метрики, как определено в вашей конфигурации метрик dbt   | `metrics=['revenue']` | 
| `group_by`  | Имена измерений или сущностей для группировки. Мы требуем ссылку на сущность измерения (кроме первичного временного измерения), которая предварительно добавляется к имени измерения с двойным подчеркиванием. | `group_by=['user__country', 'metric_time']`    |
| `grain`   | Параметр, специфичный для любого временного измерения и изменяющий гранулярность данных по умолчанию для метрики. | `group_by=[Dimension('metric_time')` <br/> `grain('week\|day\|month\|quarter\|year')]` | 
| `where`     | Условие where, которое позволяет вам фильтровать по измерениям и сущностям, используя параметры. Это принимает список фильтров ИЛИ строку. Входные данные поступают с объектами `Dimension` и `Entity`. Гранулярность обязательна, если `Dimension` является временным измерением | `"{{ where=Dimension('customer__country') }} = 'US')"`   | 
| `limit`   | Ограничивает возвращаемые данные    | `limit=10` | 
|`order`  | Упорядочивает возвращаемые данные по определенному полю     | `order_by=['order_gross_profit']`, используйте `-` для убывающего порядка или полную объектную нотацию, если объект обрабатывается: `order_by=[Metric('order_gross_profit').descending(True)`]   | 
| `compile`   | Если true, возвращает сгенерированный SQL для платформы данных, но не выполняет | `compile=True`  |
| `saved_query` | Сохраненный запрос, который вы можете использовать для часто используемых запросов. | `select * from {{ semantic_layer.query(saved_query="new_customer_orders"` |

## Примечание о временных измерениях и `metric_time`

Вы заметите, что в списке измерений для всех метрик есть измерение с именем `metric_time`. `Metric_time` — это зарезервированное ключевое слово для временных измерений, специфичных для агрегирования мер. Для любой временной метрики ключевое слово `metric_time` всегда должно быть доступно для использования в запросах. Это общее измерение для *всех* метрик в семантической графе.

Вы можете рассматривать одну метрику или сотни метрик, и если вы группируете по `metric_time`, это всегда даст вам правильный временной ряд.

Кроме того, при выполнении расчетов гранулярности, которые являются глобальными (не специфичными для конкретного временного измерения), мы рекомендуем всегда работать с `metric_time`, и вы получите правильный ответ.

Обратите внимание, что `metric_time` должен быть доступен в дополнение к любым другим временным измерениям, которые доступны для метрик. В случае, если вы рассматриваете одну метрику (или несколько метрик из одного источника данных), значения в ряде для первичного временного измерения и `metric_time` эквивалентны.

## Примеры

Смотрите следующие примеры, чтобы помочь вам начать работу с API JDBC.

### Получить метаданные для метрик

Вы можете фильтровать/добавлять любой SQL вне синтаксиса шаблонов. Например, вы можете использовать следующий запрос, чтобы получить имя и измерения для метрики:

```bash
select name, dimensions from {{ 
	semantic_layer.metrics() 
	}}
	WHERE name='food_order_amount'
``` 

### Запрос общих измерений

Вы можете выбрать общие измерения для нескольких метрик. Используйте следующий запрос, чтобы получить имя и измерения для нескольких метрик:

```bash
select * from {{ 
	semantic_layer.dimensions(metrics=['food_order_amount', 'order_gross_profit'])
	}}
``` 

### Запрос, сгруппированный по времени

Следующий пример запроса использует [сокращенный метод](#faqs) для получения дохода и новых клиентов, сгруппированных по времени:

```bash
select * from {{
	semantic_layer.query(metrics=['food_order_amount','order_gross_profit'], 
	group_by=['metric_time'])
	}}
``` 

### Запрос с временной гранулярностью

Используйте следующий пример запроса, чтобы получить несколько метрик с изменением гранулярности временного измерения:

```bash
select * from {{
	semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'], 
	group_by=[Dimension('metric_time').grain('month')])
	}}
```

### Группировка по категориальному измерению

Используйте следующий запрос для группировки по категориальному измерению:

```bash
select * from {{
	semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'], 
	group_by=[Dimension('metric_time').grain('month'), 'customer__customer_type'])
	}}
``` 

### Запрос только одного измерения

В этом случае вы получите полный список значений измерений для выбранного измерения.

```bash
select * from {{
    semantic_layer.query(group_by=['customer__customer_type'])
                  }}
```

### Запрос с фильтрами where

Фильтры where в API позволяют использовать список фильтров или строку. Мы рекомендуем использовать список фильтров для производственных приложений, так как этот формат реализует все преимущества <Term id="predicate-pushdown"  /> где это возможно.

Фильтры where имеют несколько объектов, которые вы можете использовать:

- `Dimension()` &mdash; Используется для любых категориальных или временных измерений. `Dimension('metric_time').grain('week')` или `Dimension('customer__country')`.

- `TimeDimension()` &mdash; Используется как более явное определение для временных измерений, опционально принимает гранулярность `TimeDimension('metric_time', 'month')`.

- `Entity()` &mdash; Используется для сущностей, таких как первичные и внешние ключи - `Entity('order_id')`.

Для `TimeDimension()` гранулярность требуется только в фильтре `WHERE`, если временные измерения для мер и метрик, связанных с фильтром where, имеют разные гранулярности.

Например, рассмотрим эту семантическую модель и конфигурацию метрик, которые содержат две метрики, агрегируемые по различным временным гранулярностям. Этот пример показывает одну семантическую модель, но то же самое относится к метрикам из более чем одной семантической модели.

```yaml
semantic_model:
  name: my_model_source

defaults:
  agg_time_dimension: created_month
  measures:
    - name: measure_0
      agg: sum
    - name: measure_1
      agg: sum
      agg_time_dimension: order_year
  dimensions:
    - name: created_month
      type: time
      type_params:
        time_granularity: month
    - name: order_year
      type: time
      type_params:
        time_granularity: year

metrics:
  - name: metric_0
    description: Метрика с месячной гранулярностью.
    type: simple
    type_params:
      measure: measure_0
  - name: metric_1
    description: Метрика с годовой гранулярностью.
    type: simple
    type_params:
      measure: measure_1

```

Предположим, что пользователь запрашивает `metric_0` и `metric_1` вместе в одном запросе, действительным фильтром `WHERE` будет:

  * `"{{ TimeDimension('metric_time', 'year') }} > '2020-01-01'"`

Недействительные фильтры будут:

  * `"{{ TimeDimension('metric_time') }} > '2020-01-01'"` &mdash; метрики в запросе определены на основе мер с разными гранулярностями.

  * `"{{ TimeDimension('metric_time', 'month') }} > '2020-01-01'"` &mdash; `metric_1` недоступна с месячной гранулярностью.


- Используйте следующий пример для запроса с использованием фильтра `where` в строковом формате:

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
group_by=[Dimension('metric_time').grain('month'),'customer__customer_type'],
where="{{ Dimension('metric_time').grain('month')  }} >= '2017-03-09' AND {{ Dimension('customer__customer_type' }} in ('new') AND {{ Entity('order_id') }} = 10")
}}
```

- (Рекомендуется для лучшей производительности) Используйте следующий пример для запроса с использованием фильтра `where` в формате списка фильтров:

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
group_by=[Dimension('metric_time').grain('month'),'customer__customer_type'],
where=["{{ Dimension('metric_time').grain('month') }} >= '2017-03-09'", "{{ Dimension('customer__customer_type') }} in ('new')", "{{ Entity('order_id') }} = 10"])
}}
```

### Запрос с ограничением

Используйте следующий пример для запроса с использованием условия `limit` или `order_by`:

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
  group_by=[Dimension('metric_time')],
  limit=10)
  }}
```

### Запрос с примерами Order By 

Order By может принимать базовую строку, которая является измерением, метрикой или сущностью, и это будет по умолчанию в порядке возрастания.

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
  group_by=[Dimension('metric_time')],
  limit=10,
  order_by=['order_gross_profit'])
  }}
``` 

Для убывающего порядка вы можете добавить знак `-` перед объектом. Однако вы можете использовать эту сокращенную нотацию только в том случае, если вы не работаете с объектом или не используете полную объектную нотацию. 

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
  group_by=[Dimension('metric_time')],
  limit=10,
  order_by=['-order_gross_profit'])
  }}
``` 

Если вы упорядочиваете по объекту, с которым проводились операции (например, вы изменили гранулярность временного измерения), или вы используете полную объектную нотацию, убывающий порядок должен выглядеть так:

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
  group_by=[Dimension('metric_time').grain('week')],
  limit=10,
  order_by=[Metric('order_gross_profit').descending(True), Dimension('metric_time').grain('week').descending(True) ])
  }}
``` 

Аналогично, это приведет к порядку возрастания: 

```bash
select * from {{
semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
  group_by=[Dimension('metric_time').grain('week')],
  limit=10,
  order_by=[Metric('order_gross_profit'), Dimension('metric_time').grain('week')])
  }}
``` 


### Запрос с ключевым словом compile

- Используйте следующий пример для запроса с использованием ключевого слова `compile`:
  ```sql
  select * from {{
  semantic_layer.query(metrics=['food_order_amount', 'order_gross_profit'],
      group_by=[Dimension('metric_time').grain('month'),'customer__customer_type'],
      compile=True)
      }}
  ```

- Используйте следующий пример для компиляции SQL с [сохраненным запросом](/docs/build/saved-queries). Вы можете использовать это для часто используемых запросов.

  ```sql
  select * from {{ semantic_layer.query(saved_query="new_customer_orders", limit=5, compile=True}}
  ```

:::info Примечание о запросах сохраненных запросов
При запросе [сохраненных запросов](/docs/build/saved-queries) вы можете использовать параметры, такие как `where`, `limit`, `order`, `compile` и т. д. Однако имейте в виду, что вы не можете получить доступ к параметрам `metric` или `group_by` в этом контексте. Это связано с тем, что они являются предопределенными и фиксированными параметрами для сохраненных запросов, и вы не можете изменять их во время запроса. Если вы хотите запросить больше метрик или измерений, вы можете построить запрос, используя стандартный формат.
:::

### Запрос сохраненного запроса

Используйте следующий пример для запроса [сохраненного запроса](/docs/build/saved-queries):

```sql
select * from {{ semantic_layer.query(saved_query="new_customer_orders", limit=5}}
```

API JDBC будет использовать сохраненный запрос (`new_customer_orders`), как определено, и применит ограничение в 5 записей.

### Многоуровневые соединения

В случаях, когда вам нужно запросить данные из нескольких связанных таблиц (многоуровневые соединения), используйте аргумент `entity_path`, чтобы указать путь между связанными сущностями. Вот примеры того, как вы можете определить эти соединения:

- В этом примере вы запрашиваете измерение `location_name`, но указываете, что оно должно быть соединено с использованием поля `order_id`.
	```sql
	{{Dimension('location__location_name', entity_path=['order_id'])}}
	```
- В этом примере измерение `salesforce_account_owner` соединяется с полем `region`, при этом путь проходит через `salesforce_account`.
	```sql
	{{ Dimension('salesforce_account_owner__region',['salesforce_account']) }}
	```

## Часто задаваемые вопросы

<FAQ path="Troubleshooting/sl-alpn-error" />

<DetailsToggle alt_header="Почему некоторые измерения используют разный синтаксис, например, `metric_time` против `Dimension('metric_time')`?">
Когда вы выбираете измерение отдельно, например, `metric_time`, вы можете использовать сокращенный метод, который не требует синтаксиса “Dimension”.

Однако, когда вы выполняете операции с измерением, такие как добавление гранулярности, синтаксис объекта `[Dimension('metric_time')` требуется.
</DetailsToggle>

<DetailsToggle alt_header="Что означает синтаксис с двойным подчеркиванием `'__'` в измерениях?">

Синтаксис с двойным подчеркиванием `"__"` указывает на сопоставление от сущности к измерению, а также на то, где находится измерение. Например, `user__country` означает, что кто-то смотрит на измерение `country` из таблицы `user`.
</DetailsToggle>

<DetailsToggle alt_header="Какой вывод по умолчанию при добавлении гранулярности?">

Вывод по умолчанию следует формату `{{time_dimension_name}__{granularity_level}}`. 

Таким образом, например, если `time_dimension_name` — это `ds`, а уровень гранулярности — годовой, вывод будет `ds__year`.

</DetailsToggle>

## Связанные документы

- [Лучшие практики интеграции семантического уровня dbt](/guides/sl-partner-integration-guide)