---
title: "Continuous integration jobs in dbt"
sidebar_label: "CI jobs"
description: "Learn how to create and set up CI checks to test code changes before deploying to production."
---

Вы можете настроить задания [непрерывной интеграции](/docs/deploy/continuous-integration) (CI), которые будут запускаться, когда кто‑то открывает новый pull request (PR) в вашем репозитории <Constant name="git" />. Запуская и тестируя только _изменённые_ модели, <Constant name="cloud" /> обеспечивает максимальную эффективность таких заданий и бережное использование ресурсов вашей платформы данных.

:::note Triggering CI jobs in monorepos
Если у вас монорепозиторий с несколькими dbt‑проектами, открытие одного pull request в одном из проектов приведёт к запуску заданий для всех проектов, подключённых к этому монорепозиторию. Чтобы избежать этого, вы можете использовать отдельные целевые ветки для каждого проекта (например, `main-project-a`, `main-project-b`), чтобы разделить триггеры CI.
:::

## Prerequisites
- У вас есть аккаунт <Constant name="cloud" />. 
- Возможности CI:
   - Для функций [параллельных CI‑проверок](/docs/deploy/continuous-integration#concurrent-ci-checks) и [умной отмены устаревших сборок](/docs/deploy/continuous-integration#smart-cancellation) ваш аккаунт <Constant name="cloud" /> должен быть на тарифе [Starter, Enterprise или Enterprise+](https://www.getdbt.com/pricing/).
   - [SQL‑линтинг](/docs/deploy/continuous-integration#sql-linting) доступен на [release tracks <Constant name="cloud" />](/docs/dbt-versions/cloud-release-tracks) и для аккаунтов <Constant name="cloud" /> на тарифах [Starter, Enterprise или Enterprise+](https://www.getdbt.com/pricing/). В вашем проекте должен быть настроен [SQLFluff](/docs/deploy/continuous-integration#to-configure-sqlfluff-linting).
- Возможности [Advanced CI](/docs/deploy/advanced-ci):
   - Для функции [compare changes](/docs/deploy/advanced-ci#compare-changes) ваш аккаунт <Constant name="cloud" /> должен быть на тарифе уровня [Enterprise](https://www.getdbt.com/pricing/) и иметь включённые функции Advanced CI. Пожалуйста, попросите [администратора <Constant name="cloud" /> включить](/docs/cloud/account-settings#account-access-to-advanced-ci-features) эту возможность. После включения в настройках CI‑задания станет доступна опция **dbt compare**.
- Настройте [подключение к вашему провайдеру <Constant name="git" />](/docs/cloud/git/git-configuration-in-dbt-cloud). Эта интеграция позволяет <Constant name="cloud" /> запускать задания от вашего имени при срабатывании триггеров.
   - Если вы используете нативную интеграцию с [GitLab](/docs/cloud/git/connect-gitlab), вам потребуется платный или self‑hosted аккаунт, который поддерживает GitLab webhooks и [project access tokens](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html). Если вы используете GitLab Free, merge request’ы будут запускать CI‑задания, но статус выполнения CI (успех или ошибка задания) не будет передаваться обратно в GitLab.

import GitProvidersCI from '/snippets/_git-providers-supporting-ci.md';

<GitProvidersCI />   

## Set up CI jobs {#set-up-ci-jobs}

dbt Labs рекомендует создавать CI‑задания в отдельной [deployment environment](/docs/deploy/deploy-environments#create-a-deployment-environment) <Constant name="cloud" />, подключённой к staging‑базе данных. Наличие отдельного окружения, выделенного специально для CI, обеспечивает лучшую изоляцию между временными схемами, создаваемыми в CI, и вашими production‑сборками данных.  

Кроме того, иногда командам требуется, чтобы CI‑задания запускались при создании PR не только в ветку main. Если в рамках процесса релизов ваша команда поддерживает staging‑ветку, отдельное окружение позволит задать [пользовательскую ветку](/faqs/Environments/custom-branch-settings). Соответственно, CI‑задание в этом выделенном окружении будет запускаться только при создании PR в указанную пользовательскую ветку. Подробнее см. в разделе [Get started with CI tests](/guides/set-up-ci).

Чтобы упростить создание CI заданий, многие параметры на странице **CI задания** установлены на значения по умолчанию, которые dbt Labs рекомендует использовать. Если вы не хотите использовать значения по умолчанию, вы можете их изменить.

1. На странице вашей среды развертывания нажмите **Создать задание** > **Задание непрерывной интеграции**, чтобы создать новое CI задание.

2. Параметры в разделе **Настройки задания**:
    - **Имя задания** &mdash; Укажите имя для этого CI задания.
    - **Описание** &mdash; Предоставьте описание CI задания.
    - **Среда** &mdash; По умолчанию будет установлена среда, из которой вы создали CI задание. Используйте выпадающий список, чтобы изменить настройку по умолчанию.

3. Опции в разделе **<Constant name="git" /> trigger**:
    - **Triggered by pull requests** &mdash; По умолчанию эта опция включена. Каждый раз, когда разработчик открывает pull request или отправляет коммит в уже существующий pull request, эта задача будет автоматически запускаться.
      - **Run on draft pull request** &mdash; Включите эту опцию, если вы хотите, чтобы задача также запускалась каждый раз, когда разработчик открывает черновик pull request (draft pull request) или отправляет коммит в этот черновик.

4. Опции в разделе **Execution settings**:
    - **Commands** &mdash; По умолчанию здесь указан командный вызов `dbt build --select state:modified+`. Он сообщает <Constant name="cloud" />, что нужно собирать только новые или изменённые модели и все зависящие от них downstream‑модели. Важно отметить, что сравнение состояния (state comparison) возможно только в том случае, если выбрано отложенное окружение (deferred environment), с которым будет выполняться сравнение. Нажмите **Add command**, чтобы добавить дополнительные [commands](/docs/deploy/job-commands), которые должны выполняться при запуске этой задачи.
    - **Linting** &mdash; Включите эту опцию, чтобы dbt выполнил [linting SQL‑файлов](/docs/deploy/continuous-integration#sql-linting) в вашем проекте в качестве первого шага `dbt run`. Если в ходе этой проверки возникает ошибка, dbt может либо **Stop running on error**, либо **Continue running on error**.
    - **dbt compare**<Lifecycle status="managed,managed_plus" /> &mdash; Включите эту опцию, чтобы сравнить последнее применённое состояние production‑окружения (если оно существует) с последними изменениями из pull request и определить, в чём заключаются различия. Чтобы включить сравнение на уровне записей и анализ по первичному ключу, необходимо добавить [primary key constraint](/reference/resource-properties/constraints) или [uniqueness test](/reference/resource-properties/data-tests#unique). В противном случае в <Constant name="cloud" /> вы получите сообщение об ошибке «Primary key missing».
    
      Чтобы просмотреть отчёт о сравнении, перейдите на вкладку [Compare tab](/docs/deploy/run-visibility#compare-tab) в деталях запуска задачи. Краткая сводка отчёта также доступна непосредственно из pull request в вашем провайдере <Constant name="git" /> (см. [пример CI‑отчёта](#example-ci-report)).

      Чтобы просмотреть отчет о сравнении, перейдите на вкладку [Сравнение](/docs/deploy/run-visibility#compare-tab) в деталях выполнения задания. Краткое содержание отчета также доступно из pull запроса в вашем Git провайдере (см. [пример отчета CI](#example-ci-report)).

      :::info Совет по оптимизации
      Когда вы включаете флажок **dbt compare**, вы можете настроить команду сравнения для оптимизации вашего CI задания. Например, если у вас есть большие модели, которые занимают много времени для сравнения, вы можете исключить их, чтобы ускорить процесс, используя флаг [`--exclude`](/reference/node-selection/exclude). Обратитесь к [пользовательским командам сравнения изменений](/docs/deploy/job-commands#compare-changes-custom-commands) для получения более подробной информации.

      Кроме того, если вы установите [`event_time`](/reference/resource-configs/event-time) в ваших моделях/семенах/снимках/источниках, это позволит вам сравнивать совпадающие диапазоны дат между таблицами, фильтруя их по пересекающимся диапазонам дат. Это полезно для более быстрого рабочего процесса CI или настройки пользовательской выборки.
      :::

- **Сравнение изменений с окружением (Deferral)** &mdash; По умолчанию в качестве такого окружения используется **Production**, если вы его создали. Эта опция позволяет <Constant name="cloud" /> сравнивать состояние кода в PR с кодом, который выполняется в отложенном окружении, чтобы проверять только изменённый код, а не пересобирать всю таблицу или весь DAG целиком.

  :::info
  В более ранних версиях <Constant name="cloud" /> была доступна возможность отложенного выполнения только относительно конкретного job, а не окружения. При deferral к job состояние сравнивается с кодом проекта из последнего успешного запуска этого job. Deferral к окружению более эффективен, поскольку <Constant name="cloud" /> сравнивает код с представлением проекта (которое хранится в `manifest.json`) из последнего успешного deploy job, выполненного в этом окружении. Учитывая _все_ [deploy jobs](/docs/deploy/deploy-jobs), которые выполняются в отложенном окружении, <Constant name="cloud" /> получает более точное и актуальное представление состояния проекта.
      :::

    - **Тайм-аут выполнения** &mdash; Отмените CI задание, если время выполнения превышает значение тайм-аута. Вы можете использовать эту опцию, чтобы гарантировать, что проверка CI не потребляет слишком много ресурсов вашего хранилища. Если вы включите опцию **dbt compare**, значение тайм-аута по умолчанию будет `3600` (один час), чтобы предотвратить длительные сравнения.

5. (необязательно) Параметры в разделе **Расширенные настройки**:
    - **Переменные окружения** &mdash; Определите [переменные окружения](/docs/build/environment-variables), чтобы настроить поведение вашего проекта при запуске этого CI задания. Вы можете указать, что CI задание выполняется в _Промежуточной_ или _CI_ среде, установив переменную окружения и изменив код вашего проекта для различного поведения в зависимости от контекста. Обычно команды обрабатывают только подмножество данных для CI запусков, используя переменные окружения для ветвления логики в своем коде проекта dbt.
    - **Имя цели** &mdash; Определите [имя цели](/docs/build/custom-target-names). Подобно **Переменным окружения**, эта опция позволяет настроить поведение проекта. Вы можете использовать эту опцию, чтобы указать, что CI задание выполняется в _Промежуточной_ или _CI_ среде, установив имя цели и изменив код вашего проекта для различного поведения в зависимости от контекста.
    - **Версия dbt** &mdash; По умолчанию установлено наследование [версии dbt](/docs/dbt-versions/core) из окружения. dbt Labs настоятельно рекомендует не изменять настройку по умолчанию. Эта опция изменения версии на уровне задания полезна только при обновлении проекта до следующей версии dbt; в противном случае несоответствие версий между окружением и заданием может привести к запутанному поведению.
    - **Потоки** &mdash; По умолчанию установлено 4 [потока](/docs/core/connect-data-platform/connection-profiles#understanding-threads). Увеличьте количество потоков, чтобы увеличить параллелизм выполнения моделей.
   - **Генерация документации при запуске** &mdash; Включите это, если вы хотите [генерировать документацию проекта](/docs/collaborate/build-and-view-your-docs) при запуске этого задания. Это отключено по умолчанию, так как тестирование генерации документации при каждом проверке CI не является рекомендуемой практикой.
    - **Запуск свежести источников** &mdash; Включите эту опцию, чтобы вызвать команду `dbt source freshness` перед запуском этого CI задания. Обратитесь к [Свежесть источников](/docs/deploy/source-freshness) для получения более подробной информации.

5. (необязательно) Параметры в разделе **Advanced settings**:
    - **Environment variables** &mdash; Определите [переменные окружения](/docs/build/environment-variables), чтобы настроить поведение проекта при выполнении этого CI‑задания. Вы можете указать, что CI‑задание запускается в окружении _Staging_ или _CI_, задав переменную окружения и изменив код проекта так, чтобы он вел себя по‑разному в зависимости от контекста. Для команд распространена практика обрабатывать в CI только подмножество данных, используя переменные окружения для ветвления логики в коде dbt‑проекта.
    - **Target name** &mdash; Определите [target name](/docs/build/custom-target-names). Аналогично **Environment Variables**, этот параметр позволяет настраивать поведение проекта. Его можно использовать, чтобы указать, что CI‑задание выполняется в окружении _Staging_ или _CI_, задав имя таргета и изменив код проекта так, чтобы он вел себя по‑разному в зависимости от контекста.
    - **dbt version** &mdash; По умолчанию используется [версия dbt](/docs/dbt-versions/core), унаследованная от окружения. dbt Labs настоятельно рекомендует не менять значение по умолчанию. Возможность переопределить версию на уровне задания полезна только при обновлении проекта на следующую версию dbt; в остальных случаях несоответствие версий между окружением и заданием может привести к запутанному поведению.
    - **Threads** &mdash; По умолчанию установлено значение 4 [threads](/docs/core/connect-data-platform/connection-profiles#understanding-threads). Увеличьте количество потоков, чтобы повысить параллельность выполнения моделей.
    - **Generate docs on run** &mdash; Включите этот параметр, если хотите [генерировать документацию проекта](/docs/explore/build-and-view-your-docs) при выполнении этого задания. По умолчанию он отключён, поскольку проверка генерации документации при каждом CI‑прогоне не является рекомендуемой практикой.
    - **Run source freshness** &mdash; Включите этот параметр, чтобы перед запуском CI‑задания выполнить команду `dbt source freshness`. Подробнее см. в разделе [Source freshness](/docs/deploy/source-freshness).

   <Lightbox src="/img/docs/dbt-cloud/using-dbt-cloud/create-ci-job.png" width="90%" title="Example of CI Job page in the dbt UI"/>

### Example of CI check in pull request {#example-ci-check}
Ниже приведён пример CI‑проверки в pull request на GitHub. Зелёная галочка означает, что сборка dbt и тесты прошли успешно. При нажатии на раздел <Constant name="cloud" /> вы перейдёте к соответствующему CI‑прогону в <Constant name="cloud" />.

### Пример отчета CI в pull запросе <Lifecycle status="preview" /> {#example-ci-report}
Ниже приведен пример отчета CI в pull запросе GitHub, который отображается, когда для CI задания включена опция **dbt compare**. Он показывает краткое содержание моделей, измененных в pull запросе.

<Lightbox src="/img/docs/dbt-cloud/using-dbt-cloud/example-github-ci-report.png" width="75%" title="Пример комментария отчета CI в pull запросе GitHub"/>

## Запуск CI задания с помощью API

## Запуск CI-задачи через API <Lifecycle status="managed,managed_plus" />

Если вы не используете нативную интеграцию <Constant name="cloud" /> с <Constant name="git" /> — через [GitHub](/docs/cloud/git/connect-github), [GitLab](/docs/cloud/git/connect-gitlab) или [Azure DevOps](/docs/cloud/git/connect-azure-devops) — вы можете воспользоваться [Administrative API](/docs/dbt-cloud-apis/admin-cloud-api), чтобы запустить CI-задачу. Однако <Constant name="cloud" /> не будет автоматически удалять временную схему. Это связано с тем, что автоматическое удаление опирается на входящие вебхуки от провайдеров <Constant name="git" />, которые доступны только при использовании нативных интеграций.

- У вас есть аккаунт dbt Cloud.
- Для функций [Параллельных проверок CI](/docs/deploy/continuous-integration#concurrent-ci-checks) и [Умной отмены устаревших сборок](/docs/deploy/continuous-integration#smart-cancellation) ваш аккаунт dbt Cloud должен быть на [Team или Enterprise плане](https://www.getdbt.com/pricing/).

- У вас есть аккаунт <Constant name="cloud" />.
- У вас есть тарифный план <Constant name="cloud" /> [Enterprise или Enterprise+](https://www.getdbt.com/pricing/). Устаревшие планы Team также сохраняют доступ.
  - Для функций [Concurrent CI checks](/docs/deploy/continuous-integration#concurrent-ci-checks) и [Smart cancellation of stale builds](/docs/deploy/continuous-integration#smart-cancellation) ваш аккаунт <Constant name="cloud" /> должен быть на плане [Enterprise или Enterprise+](https://www.getdbt.com/pricing/) либо на устаревшем плане Team. Планы Starter не имеют доступа к этим функциям при запуске CI-задачи через API.

1. Настройте CI-задачу с помощью API-эндпоинта [Create Job](/dbt-cloud/api-v2#/operations/Create%20Job), указав `"job_type": ci`, либо через [интерфейс <Constant name="cloud" />](#set-up-ci-jobs).
2. Вызовите API-эндпоинт [Trigger Job Run](/dbt-cloud/api-v2#/operations/Trigger%20Job%20Run), чтобы запустить CI-задачу. В payload необходимо передать оба следующих поля:
   - Укажите идентификатор pull request (PR), используя одно из следующих полей:

      - `github_pull_request_id`
      - `gitlab_merge_request_id`
      - `azure_devops_pull_request_id`
      - `non_native_pull_request_id` (например, BitBucket)
   - Укажите `git_sha` или `git_branch`, чтобы нацелиться на правильный коммит или ветку для запуска задания.

## Семантические проверки в CI  <Lifecycle status="self_service,managed,managed_plus" />

Автоматически тестируйте ваши семантические узлы (метрики, семантические модели и сохраненные запросы) во время обзоров кода, добавляя проверки валидации хранилища в ваше CI задание, гарантируя, что любые изменения кода в dbt моделях не нарушают эти метрики.

Для этого добавьте команду `dbt sl validate --select state:modified+` в CI задание. Это обеспечивает валидацию измененных семантических узлов и их зависимостей.

<Lightbox src="/img/docs/dbt-cloud/deployment/sl-ci-job.png" width="90%" title="Семантические проверки в рабочем процессе CI" />

#### Преимущества
- Тестирование семантических узлов в CI-задаче поддерживает deferral и selection для семантических узлов.
- Это позволяет выявлять проблемы на ранних этапах разработки и предоставлять конечным пользователям данные высокого качества.
- Семантическая валидация выполняет explain-запрос в хранилище данных для семантических узлов, чтобы убедиться, что сгенерированный SQL будет корректно выполняться.
- Для семантических узлов и моделей, которые не находятся ниже по графу зависимостей от изменённых моделей, <Constant name="cloud" /> выполняет deferral к продакшн‑моделям.

### Настройка семантических проверок в вашем CI задании
Чтобы узнать, как это настроить, обратитесь к следующим шагам:

1. Перейдите на страницу **Настройки задания** и нажмите **Редактировать**.
2. Добавьте команду `dbt sl validate --select state:modified+` в раздел **Команды** в **Настройках выполнения**. Команда использует выбор состояния и отложение для выполнения валидации на любых семантических узлах, зависимых от изменений модели. Чтобы сократить время выполнения задания, мы рекомендуем запускать CI только на измененных семантических моделях.
3. Нажмите **Сохранить**, чтобы сохранить изменения.

Существуют дополнительные команды и варианты использования, описанные в [следующем разделе](#use-cases), такие как валидация всех семантических узлов, валидация конкретных семантических узлов и так далее.

<Lightbox src="/img/docs/dbt-cloud/deployment/ci-dbt-sl-validate-downstream.png" width="90%" title="Проверка семантических узлов, находящихся ниже по графу зависимостей от изменений моделей, в вашем CI‑джобе." />

### Варианты использования

Используйте или комбинируйте различные селекторы или команды для проверки семантических узлов в вашем CI задании. Семантические проверки в CI поддерживают следующие варианты использования:

<Expandable alt_header="Семантические узлы, зависимые от изменений модели (рекомендуется)" > 

Чтобы проверить семантические узлы, которые зависят от изменения модели, добавьте две команды в раздел **Настройки выполнения** вашего задания:

```bash
dbt build --select state:modified+
dbt sl validate --select state:modified+
```

- Первая команда строит измененные модели.
- Вторая команда проверяет семантические узлы, зависимые от измененных моделей.

Перед запуском семантических проверок <Constant name="cloud" /> должен собрать изменённые модели. Этот процесс гарантирует, что нижележащие (downstream) семантические узлы будут валидироваться с использованием CI‑схемы через API семантического слоя dbt.

Для семантических узлов и моделей, которые не находятся ниже по графу от изменённых моделей, <Constant name="cloud" /> использует (defer) продакшн‑модели.

<Lightbox src="/img/docs/dbt-cloud/deployment/ci-dbt-sl-validate-downstream.png" width="90%" title="Validate semantic nodes downstream of model changes in your CI job." />

</Expandable>

<Expandable alt_header="Семантические узлы, которые изменены или затронуты зависимыми измененными узлами.">

Чтобы проверять **только изменённые семантические узлы**, используйте следующую команду (с применением [state selection](/reference/node-selection/state-selection)):

```bash
dbt sl validate --select state:modified+
```

<Lightbox src="/img/docs/dbt-cloud/deployment/ci-dbt-sl-validate-modified.png" width="90%" title="Используйте state selection, чтобы валидировать изменённые модели определения метрик в вашем CI‑джобе." />

Это проверит только семантические узлы. Он будет использовать отложенное состояние, настроенное в вашем оркестрационном задании, откладывая на ваши производственные модели.

</Expandable>

<Expandable alt_header="Выбор конкретных семантических узлов">

Используйте синтаксис селектора, чтобы выбрать _конкретный_ семантический узел(ы), который вы хотите проверить:

```bash
dbt sl validate --select metric:revenue
```

<Lightbox src="/img/docs/dbt-cloud/deployment/ci-dbt-sl-validate-select.png" width="90%" title="Используйте выбор по состоянию (state selection) для валидации изменённых моделей определений метрик в вашем CI‑задании." />

В этом примере CI задание проверит выбранный семантический узел `metric:revenue`. Чтобы выбрать несколько семантических узлов, используйте синтаксис селектора: `dbt sl validate --select metric:revenue metric:customers`.

Если вы не укажете селектор, <Constant name="cloud" /> будет валидировать все семантические узлы в вашем проекте.

</Expandable>

<Expandable alt_header="Выбор всех семантических узлов">

Чтобы проверить _все_ семантические узлы в вашем проекте, добавьте следующую команду, чтобы отложить на вашу производственную схему при генерации запросов проверки хранилища:

   ```bash
   dbt sl validate
   ```

<Lightbox src="/img/docs/dbt-cloud/deployment/ci-dbt-sl-validate-all.png" width="90%" title="Проверяйте все семантические узлы в вашем CI‑джобе, добавив команду: 'dbt sl validate' в настройки выполнения джобы." />

</Expandable>

## Устранение неполадок

<FAQ path="Troubleshooting/gitlab-webhook"/>

<DetailsToggle alt_header="CI-задания иногда не запускаются при открытии PR с использованием интеграции Azure DevOps (ADO)">

<Constant name="cloud" /> не запустит CI-задачу, если последний коммит в pull request или merge request уже запускал эту задачу. Однако некоторые провайдеры (например, GitHub) будут применять результат существующего запуска к нескольким pull/merge request.

Сценарии, в которых <Constant name="cloud" /> **не** запускает CI-задачу в Azure DevOps:

1. Повторное использование ветки в новом PR  
   - Если вы закрыли (abandon) предыдущий PR (PR 1), который запустил CI-задачу для той же ветки (`feature-123`) при слиянии в `main`, а затем открыли новый PR (PR 2) с этой же веткой, также направленный в `main`, — <Constant name="cloud" /> не запустит новую CI-задачу для PR 2.

2. Повторное использование того же коммита  
   - Если вы создаёте новый PR (PR 2) на том же самом коммите (`#4818ceb`), что и предыдущий PR (PR 1), который уже запускал CI-задачу, — <Constant name="cloud" /> не запустит новую CI-задачу для PR 2.

</DetailsToggle>

<DetailsToggle alt_header="Временные схемы не удаляются">
Если ваши временные схемы не удаляются после слияния или закрытия PR, это обычно указывает на одну из следующих проблем:
- Вы переопределили макрос <code>generate_schema_name</code>, и он не использует <code>dbt_cloud_pr_</code> в качестве префикса.

Чтобы решить эту проблему, измените ваш макрос так, чтобы имя временной схемы PR содержало требуемый префикс. Например:

- ✅ Имя временной схемы PR содержит префикс <code>dbt_cloud_pr_</code> (например, <code>dbt_cloud_pr_123_456_marketing</code>).
- ❌ Имя временной схемы PR не содержит префикс <code>dbt_cloud_pr_</code> (например, <code>marketing</code>).

Макрос создаёт схему, но при этом ни одна модель dbt не записывает данные в эту схему. <Constant name="cloud" /> не удаляет временные схемы, в которые не было выполнено записи в результате запуска модели dbt.

</DetailsToggle>

<DetailsToggle alt_header="Сообщения об ошибках, ссылающиеся на схемы из предыдущих PR">

Если вы получаете сообщение об ошибке, связанное со схемой, ссылающееся на <i>предыдущий</i> PR, это обычно указывает на то, что вы не используете производственное задание для вашего отложения и вместо этого используете <i>self</i>. Если предыдущий PR уже был объединен, схема предыдущего PR могла быть удалена к моменту запуска CI задания для текущего PR.

Чтобы исправить эту проблему, выберите производственное задание для отложения вместо self.

</DetailsToggle>

<DetailsToggle alt_header="Производственные задания не выполняются на этапе 'Клонирование Git репозитория'">

<Constant name="cloud" /> может выполнять checkout только тех коммитов, которые принадлежат исходному репозиторию. <Constant name="cloud" /> <i>не может</i> выполнять checkout коммитов, которые принадлежат форку этого репозитория.

Если при выполнении вашего job run на шаге **Clone <Constant name="git" /> Repository** вы получаете следующее сообщение об ошибке:

```
Сообщение об ошибке:
Клонирование в '/tmp/jobs/123456/target'...
Репозиторий успешно клонирован.
Переход на e845be54e6dc72342d5a8f814c8b3316ee220312...>
Не удалось перейти на указанную ревизию.
git checkout e845be54e6dc72342d5a8f814c8b3316ee220312
fatal: reference is not a tree: e845be54e6dc72342d5a8f814c8b3316ee220312
```

Дважды проверьте, что ваш PR не пытается объединиться, используя коммит, принадлежащий форку репозитория, прикрепленного к вашему проекту dbt.
</DetailsToggle>

<DetailsToggle alt_header="CI задание не запускается для пользователей Virtual Private dbt"> 

Чтобы запускать задания в <Constant name="cloud" /> с помощью [API](/docs/dbt-cloud-apis/admin-cloud-api), ваш Git‑провайдер должен быть подключён к вашей учётной записи <Constant name="cloud" />.

Если вы находитесь на плане Virtual Private dbt Enterprise, используя функции безопасности, такие как ingress PrivateLink или IP Allowlisting, регистрация CI хуков может быть недоступна и может привести к тихому сбою задания.
</DetailsToggle>

<DetailsToggle alt_header="Статус PR для CI задания остается 'в ожидании' в Azure DevOps после завершения выполнения задания">

Когда вы запускаете CI задание, статус pull запроса должен отображаться как `в ожидании`, пока он ждет обновления от dbt. После завершения CI задания dbt отправляет статус в Azure DevOps (ADO), и статус изменится на `успешно` или `неудачно`.

Если статус не обновляется после выполнения задания, проверьте, есть ли какие-либо политики веток git, блокирующие ADO от получения этих обновлений.

Одной из возможных проблем является **Сброс условий** в разделе **Проверки статуса** в политике ветки репозитория ADO. Если вы включите флажок **Сбрасывать статус при наличии новых изменений** (в разделе **Сброс условий**), это может помешать dbt обновлять ADO о статусе выполнения вашего CI задания.
Вы можете найти соответствующую информацию здесь:
- [Azure DevOps Services Status checks](https://learn.microsoft.com/en-us/azure/devops/repos/git/branch-policies?view=azure-devops&tabs=browser#status-checks)
- [Azure DevOps Services Pull Request Stuck Waiting on Status Update](https://support.hashicorp.com/hc/en-us/articles/18670331556627-Azure-DevOps-Services-Pull-Request-Stuck-Waiting-on-Status-Update-from-Terraform-Cloud-Enterprise-Run)
- [Pull request status](https://learn.microsoft.com/en-us/azure/devops/repos/git/pull-request-status?view=azure-devops#pull-request-status)

</DetailsToggle>