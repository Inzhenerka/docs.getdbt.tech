---
id: upper
title: SQL UPPER
description: Использование функции UPPER для строкового значения вернет входные данные в виде строки, состоящей только из заглавных букв. Это эффективный способ создать ожидаемую капитализацию для определенных строковых значений в ваших данных.
slug: /sql-reference/upper
---

<head>
    <title>Работа с функцией SQL UPPER</title>
</head>

UPPER является аналогом [LOWER](/sql-reference/lower) (кто бы мог подумать?) — и, вероятно, это самые интуитивно понятные функции SQL.

Использование функции UPPER для строкового значения вернет входные данные в виде строки, состоящей только из заглавных букв. Это эффективный способ создать ожидаемую капитализацию для определенных строковых значений в ваших данных.

## Как использовать функцию SQL UPPER

Синтаксис для использования функции UPPER выглядит следующим образом:

```sql
upper(<string_column>)
```
Выполнение этой команды в операторе SELECT вернет строку в верхнем регистре. Вы также можете использовать функцию UPPER в условиях WHERE и для значений соединения.

Ниже мы рассмотрим практический пример использования функции UPPER.

### Пример функции SQL UPPER

Вы можете преобразовать имя клиента в верхний регистр в модели `customers` [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop) с помощью следующего кода:

```sql
select 
	customer_id,
	upper(first_name) as first_name,
	last_name
from {{ ref('customers') }}
```

После выполнения этого запроса таблица `customers` будет выглядеть примерно так:

| customer_id | first_name | last_name |
|---|---|---|
| 1 | MICHAEL | P. |
| 2 | SHAWN | M. |
| 3 | KATHLEEN | P. |

Теперь все символы в `first_name` находятся в верхнем регистре (а `last_name` остались без изменений).

> Преобразование строковых столбцов в верхний регистр для создания единообразия между источниками данных обычно происходит в [стадийных моделях нашего проекта dbt](https://docs.getdbt.com/best-practices/how-we-structure/2-staging). На это есть несколько причин: очистка и стандартизация данных, такие как создание псевдонимов, приведение типов и изменение регистра, должны происходить в стадийных моделях, чтобы создать единообразие на следующих этапах и улучшить производительность на следующих этапах.

## Синтаксис функции SQL UPPER в Snowflake, Databricks, BigQuery и Redshift

Google BigQuery, Amazon Redshift, Snowflake, Postgres и Databricks все поддерживают функцию UPPER. Кроме того, синтаксис для использования функции UPPER одинаков для всех этих систем.

## Сценарии использования функции UPPER

Создавая единообразный формат капитализации (верхний или нижний регистр) для всех строковых значений в ваших моделях данных, вы тем самым создаете определенные ожидания для бизнес-пользователей в вашем BI-инструменте.
- Заглавные коды стран в источниках данных для соответствия ожиданиям пользователей
- Создание единообразного формата капитализации для строковых значений в ваших моделях данных, что также создает ожидания для бизнес-пользователей в вашем BI-инструменте

Скорее всего, никогда не будет 100% согласованности в ваших моделях данных, но все, что вы можете сделать, чтобы смягчить этот хаос, сделает вашу жизнь и жизнь ваших бизнес-пользователей, надеюсь, немного проще. Используйте функцию UPPER для создания единообразного регистра для всех строк в ваших источниках данных.