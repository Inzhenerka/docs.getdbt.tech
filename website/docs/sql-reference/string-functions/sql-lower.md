---
id: lower
title: SQL LOWER
description: Использование функции LOWER для строкового значения вернет ввод в виде строки, состоящей только из строчных букв. Это эффективный способ создать единообразное написание строковых значений в ваших данных.
slug: /sql-reference/lower
---

<head>
    <title>Работа с функцией SQL LOWER</title>
</head>

Мы все с этим сталкивались:
- В форме регистрации пользователя пользователь A ввел свое имя как `Kira Furuichi`, пользователь B ввел его как `john blust`, а пользователь C написал `DAvid KrevitT` (что с тобой, Дэвид??)
- Ваши инженеры приложений на стороне сервера настаивают на том, что адреса электронной почты клиентов написаны заглавными буквами
- Все ваши названия отслеживания событий написаны строчными буквами

В реальном мире человеческих несовершенств, мнений и ошибок строковые значения, вероятно, будут иметь несогласованное написание в разных источниках данных (или даже в одном и том же источнике данных). Всегда есть небольшая доля абсурда в том, почему некоторые значения передаются в верхнем или нижнем регистре, и не стоит тратить время на разбор этого.

Итак, как создать единообразие для строковых значений, которые вы собираете из всех ваших источников данных? Функция LOWER!

Использование функции LOWER для строкового значения вернет ввод в виде строки, состоящей только из строчных букв. Это эффективный способ создать единообразное написание строковых значений в ваших данных.

## Как использовать функцию SQL LOWER

Синтаксис для использования функции LOWER выглядит следующим образом:

```sql
lower(<string_column>)
```

Выполнение этой команды в операторе SELECT вернет строку в нижнем регистре. Вы также можете использовать функцию LOWER в условиях WHERE и для значений соединения.

Давайте рассмотрим практический пример использования функции LOWER.

### Пример функции SQL LOWER

Вы можете привести к нижнему регистру имя и фамилию модели `customers` [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop) с помощью следующего кода:

```sql
select 
	customer_id,
	lower(first_name) as first_name,
	lower(last_name) as last_name
from {{ ref('customers') }}
```

После выполнения этого запроса таблица `customers` будет выглядеть примерно так:

| customer_id | first_name | last_name |
|---|---|---|
| 1 | michael | p. |
| 2 | shawn | m. |
| 3 | kathleen | p. |

Теперь все символы в столбцах `first_name` и `last_name` написаны строчными буквами.

> Приведение всех строковых столбцов к нижнему регистру для создания единообразия между источниками данных обычно происходит в [стадийных моделях нашего проекта dbt](https://docs.getdbt.com/best-practices/how-we-structure/2-staging). На это есть несколько причин: очистка и стандартизация данных, такие как алиасинг, приведение типов и приведение к нижнему регистру, должны происходить в стадийных моделях, чтобы создать единообразие на следующих этапах и улучшить производительность на следующих этапах.

## Синтаксис функции SQL LOWER в Snowflake, Databricks, BigQuery и Redshift

Google BigQuery, Amazon Redshift, Snowflake, Postgres и Databricks все поддерживают функцию LOWER. Кроме того, синтаксис использования LOWER одинаков для всех из них.

## Сценарии использования функции LOWER

Вернемся к нашему хаотичному трио пользователей A, B и C, которые использовали разные регистры для ввода своих имен. Если вы не создадите единообразное написание строковых значений, как бизнес-пользователь сможет понять, что фильтровать в своем BI-инструменте? Бизнес-пользователь может отфильтровать поле имени по “John Blust”, так как именно так он ожидает его увидеть, и в итоге не получить никаких результатов. Создавая единообразный формат написания (верхний или нижний регистр) для всех строковых значений в ваших моделях данных, вы тем самым создаете определенные ожидания для бизнес-пользователей в вашем BI-инструменте.

Скорее всего, никогда не будет 100% согласованности в ваших моделях данных, но все, что вы можете сделать, чтобы смягчить этот хаос, сделает вашу жизнь и жизнь ваших бизнес-пользователей, надеюсь, немного проще. Используйте функцию LOWER, чтобы создать единообразный регистр для всех строк в ваших источниках данных.