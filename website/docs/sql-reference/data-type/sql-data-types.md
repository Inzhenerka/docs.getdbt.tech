---
id: data-types
title: SQL Типы Данных
description: Различные типы данных в SQL включают числовые, строковые, даты, булевы значения и полуструктурированные. В этом содержании рассматриваются различия между ними и их подкатегории.
slug: /sql-reference/data-types
---

<head>
    <title>Что такое типы данных SQL?</title>
</head>

Ниже мы рассмотрим различные категории типов данных и уникальные типы данных, которые относятся к каждой категории.

## Числовые типы данных

В SQL существует множество различных числовых типов, и это имеет смысл, потому что… мы работаем с данными, и числа важны, длина бит важна, количество десятичных знаков еще важнее, и именно числа позволяют заинтересованным сторонам принимать определенные решения.

Существует небольшое различие в том, какие числовые типы данных поддерживаются в каждом хранилище данных, но в основном важно понимать различия между целыми числами, десятичными числами и числами с плавающей запятой.

| **Тип** | **Определение** | **Сценарии использования** |
|:---:|:---:|:---:|
| Integer | Целые числа — это числа без дробной части. Например, 1, 2, 72384191203 — простые, четкие числа. | Хотя многие значения столбцов могут выглядеть как целые числа (и теоретически они таковы), их часто отображают или приводят к десятичным/числовым типам для обеспечения будущей точности и масштаба, если это необходимо. |
| Decimal | Десятичный тип, также известный как тип NUMERIC, — это числовой тип данных с заданной точностью 38 и масштабом 0. | Типичные числовые столбцы в наборах данных, такие как пожизненная ценность или идентификаторы пользователей. Скорее всего, это наиболее распространенная форма числовых данных в ваших таблицах. |
| Float | Числа с плавающей запятой используются для предоставления приблизительных числовых значений дробей с точностью до 64 бит. Числа с плавающей запятой предлагают более широкий диапазон значений по сравнению с десятичными. | Столбцы, которые представляют проценты; долгота/широта. |

## Строковые типы данных

Строки повсюду в данных — они позволяют людям иметь описательные текстовые поля, использовать регулярные выражения в своей работе с данными, и, честно говоря, они просто делают мир данных более живым. Формально, строковый тип — это слово или комбинация символов, которые вы обычно видите в одинарных кавычках (например, 'Jaffle Shop', '1234 Shire Lane', 'Plan A').

Snowflake, Databricks, Google BigQuery и Amazon Redshift все поддерживают строковый тип данных. У них могут быть немного разные подтипы для строк; некоторые хранилища данных, такие как Snowflake и Redshift, поддерживают типы строк `text`, `char` и `character`, которые обычно отличаются по длине в байтах по сравнению с общим строковым типом.

Снова, поскольку большинство столбцов строкового типа являются неотъемлемой частью ваших данных, вы, вероятно, сможете использовать общий varchar или строки для приведения типов, но никогда не помешает ознакомиться с документацией, специфичной для поддержки строк вашего хранилища данных!

## Дата-тип данных

Даты, временные метки, часовые пояса — все эти интересные (немного болезненные) аспекты данных, которые делают аналитиков настоящими практиками данных (людьми, которые иногда хотят вырвать себе волосы).

Ниже мы рассмотрим даты, даты и время, время и временные метки, чтобы помочь вам лучше понять основные типы данных даты.

Двигаясь от простейшего к более сложному, даты, обычно представленные типом DATE, — это то, что вы обычно ассоциируете с календарной датой (например, 2022-12-16), и они ограничены диапазоном от 0001-01-01 до 9999-12-31.

Значения DATETIME содержат как календарную дату, так и время (например, 2022-12-16 02:33:24) и могут дополнительно включать доли секунды. Типы TIME обычно представлены в формате HH:MM:SS и не содержат указанного часового пояса.

Типы данных TIMESTAMP позволяют наиболее точно и детально указывать момент времени и могут быть указаны с часовым поясом или без него. Большинство полей данных, основанных на событиях (например, время завершения заказа, время создания аккаунта, время оттока пользователя), будут представлены как временные метки в ваших источниках данных. Некоторые хранилища данных, такие как [Amazon Redshift](https://docs.amazonaws.cn/en_us/redshift/latest/dg/r_Datetime_types.html) и [Snowflake](https://docs.snowflake.com/en/sql-reference/data-types-datetime.html#date-time-data-types), поддерживают различные варианты временных меток, которые позволяют явно указывать часовой пояс (или его отсутствие).

В общем, две лучшие практики, касающиеся дат и времени, таковы:
1. Сохраняйте (или преобразуйте) временные метки в одном часовом поясе.
2. Держите типы дат в наиболее специфичном формате: вы всегда можете уменьшить временную метку до даты, но не сможете получить временную метку из даты.

В конечном итоге вы будете использовать удобные функции работы с датами, чтобы увеличивать и уменьшать даты, преобразовывать даты или добавлять время к датам.

## Булевы значения

Булевое значение — это значение столбца, которое может быть истинным, ложным или null. В ваших наборах данных вы будете использовать булевы значения для создания полей `is_` или `has_`, чтобы создать четкие сегменты в ваших данных; например, вы можете использовать булевы значения, чтобы указать, оттек ли клиент (`has_churned`) или обозначить записи сотрудников (`is_employee`), или отфильтровать записи, которые были удалены из ваших исходных данных (`is_deleted`).

Обычно вы увидите `True` или `False` как фактические булевы значения в столбце, но также можете выбрать использование числовых значений, таких как 1 и 0, для представления истинных и ложных значений. Однако строки `True` и `False` обычно легче читать и интерпретировать для конечных пользователей бизнеса.

## Полуструктурированные типы данных

Полуструктурированные типы данных — это отличный способ объединить или агрегировать данные из нескольких полей; вы также можете оказаться в обратной ситуации, когда вам нужно распаковать полуструктурированные данные, такие как объект <Term id="json">JSON</Term>, и развернуть его в отдельные пары ключ-значение. Два основных полуструктурированных типа данных, которые вы увидите в хранилищах данных, — это JSON и массивы.

Ниже мы рассмотрим, в чем разница между ними, и приведем пример каждого из них.

| **Тип** | **Определение** | **Пример** | **Сценарий использования** |
|:---:|:---:|:---:|:---:|
| JSON | Когда мы смотрим на данные, отформатированные в JSON, мы говорим, что данные хранятся в JSON-объектах. Они состоят из пар ключ-значение. JSON-объекты заключены в фигурные скобки (\{ \}) и каждая пара ключ-значение разделена запятой. Узнайте больше о использовании JSON здесь. | \{"customer_id":2947, "order_id":4923, "order_items":"cheesecake"\} | Одно из замечательных свойств данных JSON заключается в том, что они не требуют определения схемы — до тех пор, пока вы их не развернете. Извлекайте именно то, что вам нужно из вашего JSON-объекта, и можете забыть о остальном! Значения JSON часто присутствуют в ваших источниках данных, поэтому научитесь их разворачивать, и ваша жизнь станет проще. |
| Array | Подобно массивам в других языках программирования, массив содержит несколько элементов, доступных по их позиции в этом массиве. | ["cheesecake", "cupcake", "brownie"] | Массивы — это ясный способ агрегировать несколько значений вместе, чтобы создать единое значение. Здесь много сценариев использования, но будьте осторожны: использование агрегатных функций, таких как `array_agg`, может стать неэффективным на больших наборах данных. |