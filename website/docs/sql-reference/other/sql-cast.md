---
id: cast
title: SQL CAST
description: Выполнение функции CAST в операторе SELECT вернет указанный вами столбец в новом заданном типе данных.
slug: /sql-reference/cast
---

<head>
    <title>Работа с функцией SQL CAST</title>
</head>

Представим ситуацию: вы погружены в новую модель данных и не можете понять, почему соединение между `user_id` в `table a` не удается соединить с `user_id` в `table b`. Вы копаете глубже и обнаруживаете, что `user_id` в `table a` — это целое число, а `user_id` в `table b` — строка.

*Время бросить руки в воздух.*

Это *произойдет*: вы столкнетесь с типами столбцов в ваших исходных данных или в моделях выше по потоку, которые, вероятно, нужно будет преобразовать в другие типы данных; возможно, чтобы упростить соединения, сделать вычисления более интуитивными или данные более читаемыми. Независимо от причины, вы неизбежно будете преобразовывать некоторые данные в качестве аналитического инженера и использовать функцию SQL CAST, чтобы помочь себе.

## Как использовать функцию SQL CAST

Синтаксис для использования функции CAST выглядит следующим образом:

```sql
cast(<column_name> as <new_data_type>)
```

Выполнение этой функции в операторе SELECT вернет указанный вами столбец в новом заданном типе данных. Аналитические инженеры обычно преобразуют поля в более подходящие или полезные числовые, строковые и типы даты. Вы также можете использовать функцию CAST в условиях WHERE и в соединениях.

Ниже мы рассмотрим практический пример использования функции CAST.

### Пример функции SQL CAST

Вы можете преобразовать поля `order_id` и `customer_id` модели [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop) `orders` из числовых типов в строки, используя следующий код:

```sql
select 
	cast(order_id as string) as order_id,
	cast(customer_id as string) as customer_id,
	order_date,
	status
from {{ ref('orders') }}
```

После выполнения этого запроса таблица `orders` будет выглядеть примерно так:

| order_id | customer_id | order_date | status |
|---|---|---|---|
| 1 | 1 | 2018-01-01 | returned |
| 2 | 3 | 2018-01-02 | completed |
| 3 | 94 | 2018-01-04 | completed |

Давайте проясним: полученные данные из этого запроса выглядят точно так же, как и в модели `orders` выше по потоку. Однако поля `order_id` и `customer_id` теперь являются строками, что означает, что вы можете легко объединять их с другими строковыми переменными.

> Преобразование столбцов в их соответствующие типы обычно происходит в [стадийных моделях](https://docs.getdbt.com/best-practices/how-we-structure/2-staging) нашего проекта dbt. Несколько причин для этого: очистка и стандартизация данных, такие как присвоение псевдонимов, преобразование типов и приведение к нижнему или верхнему регистру, должны происходить в стадийных моделях, чтобы создать единообразие и улучшить производительность на следующих этапах.

## Синтаксис функции SQL CAST в Snowflake, Databricks, BigQuery и Redshift

Google BigQuery, Amazon Redshift, Snowflake, Postgres и Databricks все поддерживают возможность преобразования столбцов и данных в разные типы. Кроме того, синтаксис для преобразования одинаков во всех этих системах с использованием функции CAST.

Вы также можете увидеть, что функция CAST заменяется двойным двоеточием (::), за которым следует тип данных для преобразования; `cast(order_id as string)` — это то же самое, что и `order_id::string` в большинстве хранилищ данных.

## Сценарии использования функции CAST

Вы знаете, что в какой-то момент вам нужно будет преобразовать столбец в другой тип данных. Но какие сценарии возникают, которые требуют этих преобразований? В своей основе эти преобразования необходимы, потому что исходные данные не соответствуют аналитическим или бизнес-требованиям. Это обычно происходит по нескольким причинам:

- Различия в потребностях или недопонимание со стороны [бэкенд-разработчиков](https://docs.getdbt.com/blog/when-backend-devs-spark-joy#signs-the-data-is-sparking-joy)
- <Term id="etl" /> инструменты [по умолчанию используют определенные типы данных](https://airbytehq.github.io/integrations/sources/google-sheets/)
- BI инструменты требуют, чтобы определенные поля имели конкретные типы данных

Ключевое, что нужно помнить при преобразовании данных, — это пользовательский опыт в вашем конечном BI инструменте: ожидают ли бизнес-пользователи, что `customer_id` будет отфильтрован по 1 или '1'? Что для них более интуитивно? Если одно поле `id` является целым числом, все поля `id` должны быть целыми числами. Как и в случае с моделированием данных, последовательность и стандартизация являются ключевыми при определении, когда и что преобразовывать.