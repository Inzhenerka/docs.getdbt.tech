---
id: rank
title: SQL RANK
description: Функция RANK возвращает ранг значения (начиная с 1) в упорядоченной группе или наборе данных.
slug: /sql-reference/rank
---

<head>
    <title>Работа с SQL RANK</title>
</head>

Существует множество различных оконных функций ранжирования… [ROW_NUMBER](/sql-reference/row-number), DENSE_RANK, RANK. Давайте начнем с самой базовой (RANK) и обсудим, что это такое, как ее использовать и почему она важна в аналитической инженерии.

Функция RANK является эффективным способом создания ранжированного столбца или фильтрации запроса на основе рангов. Более конкретно, функция RANK возвращает ранг значения (начиная с 1) в упорядоченной группе или наборе данных. Важно отметить, что если несколько значений, обработанных функцией ранжирования, одинаковы, они будут иметь одинаковый ранг.

## Как использовать функцию RANK

Функция RANK имеет довольно простую синтаксис, с необязательным полем разделения и поддержкой настройки порядка:

`rank() over ([partition by <field(s)>] order by field(s) [asc | desc])`

Некоторые примечания к синтаксису этой функции:

- Поле `partition by` является необязательным; если вы хотите ранжировать весь ваш набор данных по определенным полям (в отличие от разделения *и ранжирования* внутри набора данных), вы просто опустите `partition by` из вызова функции (см. пример ниже).
- По умолчанию порядок функции ранжирования установлен на восходящий. Чтобы явно установить порядок в нисходящем порядке, вам нужно передать `desc` в часть `order by` функции.

Давайте рассмотрим практический пример использования функции RANK ниже.

### Пример функции RANK

```sql
select
	order_id,
	order_date,
	rank() over (order by order_date) as order_rank
from {{ ref('orders') }}
```

Этот простой запрос, использующий таблицу `orders` [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop), вернет ранг заказов по их `order_date`:

| order_id | order_date | order_rank |
|:---:|:---:|:---:|
| 1 | 2018-01-01 | 1 |
| 2 | 2018-01-02 | 2 |
| 3 | 2018-01-04 | 3 |
| 4 | 2018-01-05 | 4 |
| 5 | 2018-01-05 | 4 |
| 6 | 2018-01-07 | 6 |

Некоторые примечания к этим результатам:

- Заказы, имеющие одинаковую `order_date` (например, заказы 4 и 5), имеют одинаковый `order_rank` (4).
- `order_rank` заказа 6 равен 6 (если вы хотите, чтобы ранг был равен 5, вам следует использовать функцию DENSE_RANK).

:::tip Функции ранжирования, которые стоит знать
RANK — это всего лишь одна из функций ранжирования, которые практикующие аналитические инженеры будут использовать в своих моделях данных. Существуют также DENSE_RANK и [ROW_NUMBER](/sql-reference/row-number), которые ранжируют строки иначе, чем RANK.
:::

## Синтаксис RANK в Snowflake, Databricks, BigQuery и Redshift

Большинство, если не все, современные хранилища данных поддерживают RANK и другие подобные функции ранжирования; синтаксис также одинаков во всех них. Используйте таблицу ниже, чтобы узнать больше о документации для функции RANK в вашем хранилище данных.

| Хранилище данных | Поддержка RANK? |
|:---:|:---:|
| Snowflake | ✅ |
| Databricks | ✅ |
| Amazon Redshift | ✅ |
| Google BigQuery | ✅ |

## Сценарии использования функции RANK

Чаще всего мы видим, что функция RANK используется в работе с данными для:

- В [SELECT выражениях](/sql-reference/select) для добавления явного ранжирования к строкам
- В выражениях QUALIFY для фильтрации запроса по рангу без необходимости добавлять ранг в результат запроса

Это не исчерпывающий список того, где ваша команда может использовать функцию RANK в своих моделях dbt и логике BI-инструментов, но он содержит некоторые распространенные сценарии, с которыми сталкиваются аналитические инженеры в повседневной работе.