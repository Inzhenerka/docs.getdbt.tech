---
id: row-number
title: SQL ROW_NUMBER
description: Функция ROW_NUMBER возвращает уникальный номер строки в упорядоченной группе или наборе данных.
slug: /sql-reference/row-number
---

<head>
    <title>Работа с SQL ROW_NUMBER</title>
</head>

На этой странице мы подробно рассмотрим функцию ROW_NUMBER, обсудим, что это такое, как ее использовать и почему она важна в аналитическом инжиниринге.

Функция ROW_NUMBER является эффективным способом создания ранжированного столбца или фильтрации запроса на основе рангов. Более конкретно, функция ROW_NUMBER возвращает *уникальный* номер строки в упорядоченной группе или наборе данных.

В отличие от функций [RANK](/sql-reference/rank) и DENSE_RANK, ROW_NUMBER является недетерминированной, что означает, что *уникальный* номер присваивается произвольно для строк с дублирующимися значениями.

## Как использовать функцию ROW_NUMBER

Функция ROW_NUMBER имеет довольно простую синтаксис, с необязательным полем разделения и поддержкой настройки порядка:

`row_number() over ([partition by <field(s)>] order by field(s) [asc | desc])`

Некоторые примечания по синтаксису этой функции:

- Поле `partition by` является необязательным; если вы хотите получить номера строк для всего вашего набора данных (в отличие от получения номера строки в группе строк вашего набора данных), вы просто опустите `partition by` в вызове функции (см. пример ниже).
- По умолчанию порядок функции ROW_NUMBER устанавливается по возрастанию. Чтобы явно задать порядок по убыванию, вам нужно передать `desc` в часть `order by` функции.

Давайте рассмотрим практический пример использования функции ROW_NUMBER ниже.

### Пример функции ROW_NUMBER

```sql
select
    customer_id,
    order_id,
    order_date,
    row_number() over (partition by customer_id order by order_date) as row_n
from {{ ref('orders') }}
order by 1
```

Этот простой запрос, использующий таблицу [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop) `orders`, вернет уникальный номер строки для каждого клиента по их `order_date`:

| customer_id | order_id | order_date | row_n |
|:---:|:---:|:---:|:---:|
| 1 | 1 | 2018-01-01 | 1 |
| 1 | 37 | 2018-02-10 | 2 |
| 2 | 8 | 2018-01-11 | 1 |
| 3 | 2 | 2018-01-02 | 1 |
| 3 | 24 | 2018-01-27 | 2 |
| 3 | 69 | 2018-03-11 | 3 |

Поскольку ROW_NUMBER является недетерминированной, заказы по каждому клиенту, имеющие одинаковую `order_date`, будут иметь уникальные значения `row_n` (в отличие от использования функций RANK или DENSE_RANK).

## Синтаксис ROW_NUMBER в Snowflake, Databricks, BigQuery и Redshift

Большинство, если не все, современные хранилища данных поддерживают ROW_NUMBER и другие подобные функции ранжирования; синтаксис также одинаков во всех них. Используйте таблицу ниже, чтобы узнать больше о документации по функции ROW_NUMBER в вашем хранилище данных.

| Хранилище данных | Поддержка ROW_NUMBER? |
|:---:|:---:|
| [Snowflake](https://docs.snowflake.com/en/sql-reference/functions/row_number.html) | ✅ |
| [Databricks](https://docs.databricks.com/sql/language-manual/functions/row_number.html) | ✅ |
| [Amazon Redshift](https://docs.aws.amazon.com/redshift/latest/dg/r_WF_ROW_NUMBER.html) | ✅ |
| [Google BigQuery](https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions#row_number) | ✅ |

## Сценарии использования функции ROW_NUMBER

Чаще всего мы видим, что функция ROW_NUMBER используется в работе с данными для:

- В [SELECT выражениях](/sql-reference/select) для добавления явных и уникальных номеров строк в группе данных или по всей таблице
- В паре с оператором QUALIFY, фильтрации <Term id="cte">CTE</Term>, запросов или моделей для захвата одной уникальной строки на указанную партию с помощью функции ROW_NUMBER. Это особенно полезно, когда вам нужно удалить дублирующиеся строки из набора данных (но используйте это с осторожностью!).

Это не исчерпывающий список того, где ваша команда может использовать функцию ROW_NUMBER в ваших моделях dbt, но он содержит некоторые распространенные сценарии, с которыми сталкиваются аналитические инженеры в повседневной работе.