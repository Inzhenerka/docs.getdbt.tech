---
id: array-agg
title: SQL ARRAY_AGG
description: Функция ARRAY_AGG позволяет создавать массив из нескольких значений данных в SQL.
slug: /sql-reference/array-agg
---

<head>
    <title>Работа с функцией SQL ARRAY_AGG</title>
</head>

В любом типичном языке программирования, таком как Python или Javascript, массивы обычно являются врожденными и обильными; когда вы обрабатываете данные в SQL, массивы встречаются немного реже, но они являются удобным способом предоставить больше структуры вашим данным.

Чтобы создать массив из нескольких значений данных в SQL, вы, вероятно, воспользуетесь функцией ARRAY_AGG (сокращение от *агрегация массива*), которая помещает значения вашего входного столбца в массив.

## Как использовать SQL ARRAY_AGG

Функция ARRAY_AGG имеет следующий синтаксис:

`array_agg( [distinct] <field_name>) [within group (<order_by field>) over ([partition by <field>])`

Несколько замечаний о функциональности этой функции:
- Большая часть синтаксиса из приведенного выше является необязательной, что означает, что функцию ARRAY_AGG можно использовать так же просто, как `array_agg(<field_name>)`, или в более сложном виде как оконную функцию.
- [DISTINCT](/sql-reference/distinct) является необязательным аргументом, который можно передать, чтобы в возвращаемом массиве были только уникальные значения.
- Если входной столбец пуст, возвращаемый массив также будет пустым.
- Поскольку ARRAY_AGG является агрегатной функцией (ах!), вам потребуется оператор GROUP BY в конце вашего запроса, если вы группируете по определенному полю.
- ARRAY_AGG и подобные агрегатные функции могут стать неэффективными или дорогостоящими для вычисления на больших наборах данных, поэтому используйте ARRAY_AGG с умом и действительно понимайте свои случаи использования массивов в ваших наборах данных.

Давайте углубимся в практический пример использования функции ARRAY_AGG.

### Пример SQL ARRAY_AGG

```sql
select
    date_trunc('month', order_date) as order_month,
    array_agg(distinct status) as status_array
from  {{ ref('orders') }}
group by 1
order by 1
```

Этот простой запрос, использующий образец данных из таблицы `orders` [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop), возвращает новый столбец с уникальными статусами заказов по месяцам заказов:

| order_month | status_array |
|:---:|:---:|
| 2018-01-01 | [ "returned", "completed", "return_pending" ] |
| 2018-02-01 | [ "completed", "return_pending" ] |
| 2018-03-01 | [ "completed", "shipped", "placed" ] |
| 2018-04-01 | [ "placed" ] |

Смотрим на результаты запроса — это имеет смысл! Мы ожидаем, что новые заказы, вероятно, не будут иметь возвратов, а старые заказы будут иметь завершенные возвраты.

## Синтаксис SQL ARRAY_AGG в Snowflake, Databricks, BigQuery и Redshift

[Snowflake](https://docs.snowflake.com/en/sql-reference/functions/array_agg.html), [Databricks](https://docs.databricks.com/sql/language-manual/functions/array_agg.html) и [BigQuery](https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions#array_agg) все поддерживают функцию ARRAY_AGG. Однако Redshift поддерживает встроенную [функцию LISTAGG](https://docs.aws.amazon.com/redshift/latest/dg/r_LISTAGG.html), которая может выполнять аналогичную функциональность с ARRAY_AGG. Основное различие заключается в том, что LISTAGG позволяет вам явно выбрать разделитель для разделения списка, в то время как массивы естественным образом разделяются запятыми.

## Случаи использования ARRAY_AGG

Существует слишком много случаев использования функции ARRAY_AGG в ваших моделях dbt, чтобы перечислить их все, но очень вероятно, что ARRAY_AGG используется довольно поздно в вашем <Term id="dag" />, поскольку вы, вероятно, не хотите, чтобы ваши данные были так упакованы ранее в вашем DAG для улучшения модульности и <Term id="dry">сухости</Term>. Несколько случаев использования ARRAY_AGG:

- В [`export_` моделях](https://www.getdbt.com/open-source-data-culture/reverse-etl-playbook), которые используются для отправки данных на платформы с помощью инструмента <Term id="reverse-etl" />, чтобы объединить несколько строк в одну строку. Некоторые платформы на выходе, например, требуют, чтобы определенные значения, которые мы обычно храним как отдельные строки, были одной строкой на клиента или пользователя. ARRAY_AGG удобно объединяет несколько значений столбцов по единственному идентификатору, например, создавая массив всех товаров, которые пользователь когда-либо покупал, и отправляя этот массив на платформу электронной почты для создания индивидуальной email-кампании.
- Похожим образом, как в моделях экспорта, вы можете увидеть использование ARRAY_AGG в [mart tables](/best-practices/how-we-structure/4-marts) для создания окончательных агрегатных массивов по единственной размерности; проблемы с производительностью ARRAY_AGG в этих, вероятно, более крупных таблицах могут быть потенциально обойдены с помощью [инкрементальных моделей в dbt](/docs/build/incremental-models).