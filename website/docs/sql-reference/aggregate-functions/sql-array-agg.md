---
id: array-agg
title: SQL ARRAY_AGG
description: Функция ARRAY_AGG позволяет создавать массив из нескольких значений данных в SQL.
slug: /sql-reference/array-agg
---

<head>
    <title>Работа с функцией SQL ARRAY_AGG</title>
</head>

В любом типичном языке программирования, таком как Python или Javascript, массивы обычно являются неотъемлемой частью и широко используются; когда вы обрабатываете данные в SQL, массивы встречаются немного реже, но являются удобным способом придать вашим данным больше структуры.

Чтобы создать массив из нескольких значений данных в SQL, вы, вероятно, воспользуетесь функцией ARRAY_AGG (сокращение от *агрегация массива*), которая помещает значения вашего входного столбца в массив.

## Как использовать SQL ARRAY_AGG {#how-to-use-sql-array_agg}

Функция ARRAY_AGG имеет следующий синтаксис:

`array_agg( [distinct] <field_name>) [within group (<order_by field>) over ([partition by <field>])`

Несколько замечаний о функциональности этой функции:
- Большинство примеров синтаксиса выше являются необязательными, что означает, что функция ARRAY_AGG может быть такой простой, как `array_agg(<field_name>)`, или использоваться как более сложная оконная функция
- [DISTINCT](/sql-reference/distinct) — это необязательный аргумент, который можно передать, чтобы в возвращаемом массиве были только уникальные значения
- Если входной столбец пуст, возвращаемый массив также будет пустым
- Поскольку ARRAY_AGG является агрегатной функцией (о, ужас!), вам понадобится оператор GROUP BY в конце вашего запроса, если вы группируете по определенному полю
- ARRAY_AGG и аналогичные агрегатные функции могут стать неэффективными или дорогостоящими для вычисления на больших наборах данных, поэтому используйте ARRAY_AGG с умом и действительно понимайте ваши случаи использования массивов в ваших наборах данных

Давайте углубимся в практический пример использования функции ARRAY_AGG.

### Пример SQL ARRAY_AGG {#sql-array_agg-example}

```sql
select
    date_trunc('month', order_date) as order_month,
    array_agg(distinct status) as status_array
from  {{ ref('orders') }}
group by 1
order by 1
```

Этот простой запрос, использующий пример набора данных таблицы `orders` из [Jaffle Shop](https://github.com/dbt-labs/jaffle_shop), возвращает новый столбец с уникальными статусами заказов по месяцам:

| order_month | status_array |
|:---:|:---:|
| 2018-01-01 | [ "returned", "completed", "return_pending" ] |
| 2018-02-01 | [ "completed", "return_pending" ] |
| 2018-03-01 | [ "completed", "shipped", "placed" ] |
| 2018-04-01 | [ "placed" ] |

Смотрим на результаты запроса — это имеет смысл! Мы ожидаем, что у новых заказов, вероятно, не будет возвратов, а у старых заказов возвраты будут завершены.

## Синтаксис SQL ARRAY_AGG в Snowflake, Databricks, BigQuery и Redshift {#sql-array_agg-syntax-in-snowflake-databricks-bigquery-and-redshift}

[Snowflake](https://docs.snowflake.com/en/sql-reference/functions/array_agg.html), [Databricks](https://docs.databricks.com/sql/language-manual/functions/array_agg.html) и [BigQuery](https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions#array_agg) поддерживают функцию ARRAY_AGG. Однако Redshift поддерживает встроенную функцию [LISTAGG](https://docs.aws.amazon.com/redshift/latest/dg/r_LISTAGG.html), которая может выполнять аналогичную функцию ARRAY_AGG. Основное отличие заключается в том, что LISTAGG позволяет явно выбрать разделитель для разделения списка, тогда как массивы по умолчанию разделяются запятыми.

## Примеры использования ARRAY_AGG {#array_agg-use-cases}

Существует слишком много примеров использования функции ARRAY_AGG в ваших моделях dbt, чтобы перечислить их все, но очень вероятно, что ARRAY_AGG используется на более поздних этапах в вашем <Term id="dag" />, так как вы, вероятно, не хотите, чтобы ваши данные были так сильно упакованы на более ранних этапах DAG для улучшения модульности и <Term id="dry">сухости</Term>. Несколько примеров использования ARRAY_AGG на более поздних этапах:

- В [`export_` моделях](https://www.getdbt.com/open-source-data-culture/reverse-etl-playbook), которые используются для отправки данных на платформы с использованием инструмента <Term id="reverse-etl" />, чтобы объединить несколько строк в одну строку. Некоторые платформы, например, требуют, чтобы определенные значения, которые мы обычно храним как отдельные строки, были одной строкой на клиента или пользователя. ARRAY_AGG удобен для объединения нескольких значений столбцов по одному идентификатору, например, создания массива всех товаров, которые пользователь когда-либо покупал, и отправки этого массива на платформу электронной почты для создания индивидуальной кампании.
- Аналогично экспортным моделям, вы можете увидеть использование ARRAY_AGG в [mart таблицах](/best-practices/how-we-structure/4-marts) для создания окончательных агрегированных массивов по одной измерению; проблемы с производительностью ARRAY_AGG в этих, вероятно, больших таблицах могут быть обойдены с использованием [инкрементальных моделей в dbt](/docs/build/incremental-models).