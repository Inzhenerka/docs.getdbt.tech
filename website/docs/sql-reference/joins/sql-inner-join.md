---
id: inner-join
title: SQL INNER JOINS
description: Внутреннее соединение между двумя объектами базы данных возвращает все строки, которые имеют совпадающие ключи соединения; любые ключи, которые не совпадают, исключаются из результата запроса.
slug: /sql-reference/inner-join
---

<head>
    <title>Работа с внутренними соединениями в SQL</title>
</head>

Самое простое и легкое из SQL соединений: скромное внутреннее соединение. Как следует из его названия, внутреннее соединение между двумя объектами базы данных возвращает все строки, которые имеют совпадающие ключи соединения; любые ключи, которые не совпадают, исключаются из результата запроса.

## Как создать внутреннее соединение {#how-to-create-an-inner-join}

Как и для всех соединений, вам понадобятся некоторые объекты базы данных (например, <Term id="table">таблицы</Term>/<Term id="view">представления</Term>), ключи для соединения и [оператор select](/sql-reference/select) для выполнения внутреннего соединения:

```
select
    <fields>
from <table_1> as t1
inner join <table_2> as t2
on t1.id = t2.id 
```

В приведенном выше примере используется только одно поле из каждой таблицы для их соединения; если вы соединяете два объекта базы данных, которые требуют нескольких полей, вы можете использовать операторы AND/OR, а предпочтительнее — <Term id="surrogate-key">суррогатные ключи</Term>. Вы также можете добавить [WHERE](/sql-reference/where), [GROUP BY](/sql-reference/group-by), [ORDER BY](/sql-reference/order-by), [HAVING](/sql-reference/having) и другие операторы после ваших соединений для создания фильтрации, сортировки и выполнения агрегаций.

Как и в любом query, вы можете выполнять сколько угодно joins в рамках одного запроса. Общее практическое правило: старайтесь поддерживать модели данных <Term id="dry">модульными</Term>, регулярно проводя <Term id="dag" />‑аудиты. Если вы соединяете определённые таблицы выше по цепочке, действительно ли эти отдельные таблицы нужны снова ниже по цепочке? Если ваш query включает несколько joins и сложную логику и при этом доступен конечным бизнес‑пользователям, убедитесь, что вы используете table или [incremental materializations](/docs/build/incremental-models).

### Пример внутреннего соединения SQL {#sql-inner-join-example}

Таблица A `car_type`

| user_id | car_type |
|:---:|:---:|
| 1 | van |
| 2 | sedan |
| 3 | truck |

Таблица B `car_color`

| user_id | car_color |
|:---:|:---:|
| 1 | red |
| 3 | green |
| 4 | yellow |

```sql
select
   car_type.user_id as user_id,
   car_type.car_type as type,
   car_color.car_color as color
from {{ ref('car_type') }} as car_type
inner join {{ ref('car_color') }} as car_color
on car_type.user_id = car_color.user_id
```

Этот простой запрос вернет все строки, которые имеют одинаковый `user_id` в обеих таблицах A и B:

| user_id | type | color |
|:---:|:---:|:---:|
| 1 | van | red |
| 3 | truck | green |

Поскольку в Таблице A нет `user_id` = 4 и в Таблице B нет `user_id` = 2, строки с id 2 и 4 (из любой таблицы) исключаются из результатов запроса внутреннего соединения.

## Примеры использования внутреннего соединения SQL {#sql-inner-join-use-cases}

Существует, вероятно, бесчисленное множество сценариев, когда вам может понадобиться внутреннее соединение нескольких таблиц — возможно, у вас есть очень хорошо структурированные таблицы с точно такими же <Term id="primary-key">первичными ключами</Term>, которые действительно должны быть одной большой, широкой таблицей, или вы соединяете две таблицы и не хотите, чтобы были нулевые или отсутствующие значения столбцов, если бы вы использовали левое или правое соединение — все это сильно зависит от ваших исходных данных и конечных случаев использования. Там, где вы не увидите (и не должны видеть) внутренние соединения, это в [стейджинговых моделях](/best-practices/how-we-structure/2-staging), которые используются для очистки и подготовки сырых исходных данных для аналитических целей. Любые соединения в ваших проектах dbt должны происходить на более поздних этапах в [промежуточных](/best-practices/how-we-structure/3-intermediate) и [март-моделях](/best-practices/how-we-structure/4-marts) для улучшения модульности и чистоты DAG.