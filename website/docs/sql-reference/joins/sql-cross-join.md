---
id: cross-join
title: SQL CROSS JOIN
description: Перекрестное соединение обычно берет два столбца между двумя объектами базы данных и создает таблицу, формируя комбинацию всех строк из соединенных таблиц, называемую декартовым произведением.
slug: /sql-reference/cross-join
---

<head>
    <title>Работа с перекрестными соединениями в SQL</title>
</head>

Действительно редко встречающееся, но важное соединение: перекрестное соединение. Большинство вашей аналитической инженерной работы потребует объединения таблиц для создания надежных, широких таблиц, которые в конечном итоге будут доступны конечным бизнес-пользователям. Эти модели обычно создаются с использованием в основном [левых](/sql-reference/left-join) (и некоторых [внутренних](/sql-reference/inner-join)) соединений.

Перекрестное соединение, с другой стороны, обычно берет два столбца между двумя объектами базы данных и создает таблицу, формируя комбинацию всех строк из соединенных таблиц, называемую декартовым произведением. Используйте эту страницу, чтобы понять, как использовать перекрестные соединения и где вы можете их применить в вашем проекте dbt.

## Как создать перекрестное соединение {#how-to-create-a-cross-join}

В отличие от обычных соединений, перекрестные соединения не используют ключи для объединения объектов базы данных:

```
select
    <fields>
from <table_1> as t1
cross join <table_2> as t2
```

Перекрестные соединения — это одна из тех концепций SQL, которые легче понять на конкретном примере, так что давайте перейдем к нему.

### Пример перекрестного соединения SQL {#sql-cross-join-example}

Таблица A `date_spine`

| date |
|:---:|
| 2022-01-01 |
| 2022-01-02 |
| 2022-01-03 |

Таблица B `users`

| user_id |
|:---:|
| 1 |
| 3 |
| 4 |

```sql
select
   users.user_id as user_id,
   date.date as date
from {{ ref('users') }} as users
cross join {{ ref('date_spine') }} as date
order by 1
```

Этот простой запрос вернет декартово произведение всех пользователей и дат, фактически создавая уникальную комбинацию пользователя на каждую дату в строке:

| user_id | type |
|:---:|:---:|
| 1 | 2022-01-01 |
| 1 | 2022-01-02 |
| 1 | 2022-01-03 |
| 2 | 2022-01-01 |
| 2 | 2022-01-02 |
| 2 | 2022-01-03 |
| 3 | 2022-01-01 |
| 3 | 2022-01-02 |
| 3 | 2022-01-03 |

:::tip Генерация суррогатных ключей из перекрестных соединений
В сгенерированной таблице выше уникальный ключ — это комбинация `user_id` и `date` для каждой строки. Чтобы добавить <Term id="primary-key" /> в эту таблицу, вы можете сгенерировать <Term id="surrogate-key" /> с использованием MD5-хэша макроса `generate_surrogate_key` в dbt-utils (например, `{{ dbt_utils.generate_surrogate_key(user_id, type) }}`), который в конечном итоге может быть присоединен к другим таблицам.
:::

## Пример использования перекрестного соединения SQL {#sql-cross-join-use-case}

Когда может быть полезна сгенерированная выше таблица? Кросс‑соединение уникальных дат и пользователей может быть эффективным способом создать базовую таблицу, к которой затем можно присоединять различные счётчики событий, например ключевые события на сайте, в email‑рассылках или в продукте. Такие отчётные таблицы удобно предоставлять конечным бизнес‑пользователям в BI‑инструментах, чтобы анализировать агрегированные показатели — количество событий по дням и пользователям, а также другие полезные метрики.
