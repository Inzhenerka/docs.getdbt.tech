---
title: Настройка базы данных, схемы и псевдонима моделей dbt
id: customize-schema-alias
description: "Узнайте, как правильно настроить ваши макросы generate_schema_name() и generate_alias_name()."
displayText: Узнайте, как настроить имя вашей схемы и псевдоним.
hoverSnippet: Узнайте, как настроить имя вашей схемы и псевдоним.
# time_to_complete: '30 minutes' commenting out until we test
icon: 'guides'
hide_table_of_contents: true
level: 'Advanced'
recently_updated: true
---

<div style={{maxWidth: '900px'}}>

## Введение
Этот гид объясняет, как настроить соглашения о наименовании [схемы](/docs/build/custom-schemas), [базы данных](/docs/build/custom-databases) и [псевдонима](/docs/build/custom-aliases) в dbt в соответствии с вашими требованиями к управлению данными и дизайну.
Когда мы разрабатываем модели dbt и выполняем определенные [команды](https://docs.getdbt.com/reference/dbt-commands) (такие как `dbt run` или `dbt build`), объекты (такие как таблицы и представления) создаются в хранилище данных на основе этих соглашений о наименовании.

:::info Слово о наименовании

Разные хранилища имеют разные названия для _логических баз данных_. Информация в этом документе охватывает "базы данных" в Snowflake, Redshift и Postgres; "проекты" в BigQuery; и "каталоги" в Databricks Unity Catalog.

:::

Следующее — это стандартное поведение dbt "из коробки":

- База данных, в которой создается объект, определяется базой данных, настроенной на [уровне окружения в dbt Cloud](/docs/dbt-cloud-environments) или в файле [`profiles.yml`](/docs/core/connect-data-platform/profiles.yml) в dbt Core.

- Схема зависит от того, определили ли вы [пользовательскую схему](/docs/build/custom-schemas) для модели:
    - Если вы не определили пользовательскую схему, dbt создает объект в стандартной схеме. В dbt Cloud это обычно `dbt_username` для разработки и стандартная схема для окружений развертывания. В dbt Core используется схема, указанная в файле `profiles.yml`.
    - Если вы определяете пользовательскую схему, dbt объединяет ранее упомянутую схему с пользовательской.
    - Например, если настроенная схема — `dbt_myschema`, а пользовательская — `marketing`, объекты будут созданы в `dbt_myschema_marketing`.
    - Обратите внимание, что для автоматизированных CI задач имя схемы происходит от номера задачи и номера PR: `dbt_cloud_pr_<job_id>_<pr_id>`.

- Имя объекта зависит от того, был ли определен [псевдоним](/reference/resource-configs/alias) для модели:
    - Если псевдоним не определен, объект будет создан с тем же именем, что и модель, без `.sql` или `.py` в конце.
        - Например, предположим, что у нас есть модель, файл sql которой называется `fct_orders_complete.sql`, пользовательская схема — `marketing`, и не настроен пользовательский псевдоним. Результирующая модель будет создана в `dbt_myschema_marketing.fct_orders_complete` в среде разработки.
    - Если псевдоним определен, объект будет создан с настроенным псевдонимом.
    - Например, предположим, что у нас есть модель, файл sql которой называется `fct_orders_complete.sql`, пользовательская схема — `marketing`, а псевдоним настроен как `fct_orders`. Результирующая модель будет создана в `dbt_myschema_marketing.fct_orders`.

Эти стандартные правила являются отличной отправной точкой, и многие организации предпочитают придерживаться их без каких-либо настроек.

Стандартные настройки позволяют разработчикам работать в своих изолированных схемах (песочницах) без перезаписи работы друг друга — даже если они работают с одними и теми же таблицами.

## Как настроить это поведение

Хотя стандартное поведение подходит для большинства организаций, бывают случаи, когда этот подход не сработает.

Например, dbt ожидает, что у него есть разрешение на создание схем по мере необходимости (и мы рекомендуем, чтобы пользователи, запускающие dbt, имели эту возможность), но это может быть запрещено в вашей компании.

Или, в зависимости от того, как вы спроектировали свое хранилище, вы можете захотеть минимизировать количество схем в вашей среде разработки (и избежать разрастания схем, не создавая комбинацию всех схем разработчиков и пользовательских схем).

Кроме того, вы можете даже захотеть, чтобы ваши схемы разработки назывались в честь веток функций, а не имен разработчиков.

По этой причине dbt предлагает три макроса для настройки того, какие объекты создаются в хранилище данных:

- [`generate_database_name()`](/docs/build/custom-databases#generate_database_name)
- [`generate_schema_name()`](/docs/build/custom-schemas#how-does-dbt-generate-a-models-schema-name)
- [`generate_alias_name()`](/docs/build/custom-aliases#generate_alias_name)

Перезаписывая один или несколько из этих макросов, мы можем настроить, где создаются объекты dbt в хранилище данных и соответствовать любым существующим требованиям.

:::note Ключевая концепция

Модели, запущенные из двух разных контекстов, должны приводить к уникальным объектам в хранилище данных. Например, разработчик по имени Сюзи работает над улучшениями для `fct_player_stats`, но Даррен разрабатывает против точно такого же объекта.

Чтобы предотвратить перезапись работы друг друга, как Сюзи, так и Даррен должны иметь свои уникальные версии `fct_player_stats` в среде разработки.

Кроме того, версия на этапе подготовки `fct_player_stats` должна существовать в уникальном месте, отдельно от версий разработки и производственной версии.

:::

Мы часто используем следующее при настройке этих макросов:

- В dbt Cloud мы рекомендуем использовать [переменные окружения](/docs/build/environment-variables) для определения, где происходит вызов dbt (dev/stg/prod).
    - Они могут быть установлены на уровне окружения, и все задачи автоматически унаследуют стандартные значения. Мы добавим логику jinja (`if/else/endif`), чтобы определить, происходит ли запуск в dev, prod, CI и т.д.
    
- Или в качестве альтернативы переменным окружения вы можете использовать `target.name`. Для получения дополнительной информации вы можете обратиться к [О переменных целевого назначения](/reference/dbt-jinja-functions/target). 

<Lightbox src="/img/docs/dbt-cloud/using-dbt-cloud/Environment Variables/custom-schema-env-var.png" title="Переменные окружения для пользовательской схемы." />

Чтобы позволить имени базы данных/схемы/объекта зависеть от текущей ветки, вы можете использовать встроенную переменную окружения `DBT_CLOUD_GIT_BRANCH` в dbt Cloud [специальные переменные окружения](/docs/build/environment-variables#special-environment-variables).

## Примеры использования

Вот некоторые типичные примеры, с которыми мы сталкивались с пользователями dbt, использующими эти 3 макроса и различную логику. 

:::note

Обратите внимание, что следующие примеры не являются исчерпывающими и не охватывают все доступные варианты. Эти примеры предназначены для того, чтобы служить шаблонами для разработки ваших собственных поведений. 

:::

- [Использование пользовательской схемы без объединения целевой схемы в производственной среде](/guides/customize-schema-alias?step=3#1-custom-schemas-without-target-schema-concatenation-in-production)
- [Добавление идентификаторов разработчиков к таблицам](/guides/customize-schema-alias?step=3#2-static-schemas-add-developer-identities-to-tables)
- [Использование имени ветки в качестве префикса схемы](/guides/customize-schema-alias?step=3#3-use-branch-name-as-schema-prefix)
- [Использование статической схемы для CI](/guides/customize-schema-alias?step=3#4-use-a-static-schema-for-ci)

### 1. Пользовательские схемы без объединения целевой схемы в производственной среде

Наиболее распространенный случай использования — это использование пользовательской схемы без объединения ее с именем стандартной схемы в производственной среде.

Для этого вы можете создать новый файл с именем `generate_schema_name.sql` в вашей папке макросов со следующим кодом:

<File name='macros/generate_schema_name.sql'>

```jinja
{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}

        {{ default_schema }}

    {%- elif  env_var('DBT_ENV_TYPE','DEV') == 'PROD' -%}
        
        {{ custom_schema_name | trim }}

    {%- else -%}

        {{ default_schema }}_{{ custom_schema_name | trim }}

    {%- endif -%}

{%- endmacro %}
```
</File>

Это создаст следующие результаты для модели с именем `my_model` с пользовательской схемой `marketing`, предотвращая любое пересечение объектов между запусками dbt из разных контекстов.

| Контекст     | Целевая база данных | Целевая схема | Результирующий объект               |
|--------------|:------------------:|:-------------:|:-----------------------------------:|
| Разработчик 1| dev                | dbt_dev1     | dev.dbt_dev1_marketing.my_model     |
| Разработчик 2| dev                | dbt_dev2     | dev.dbt_dev2_marketing.my_model     |
| CI PR 123    | ci                 | dbt_pr_123   | ci.dbt_pr_123_marketing.my_model    |
| CI PR 234    | ci                 | dbt_pr_234   | ci.dbt_pr_234_marketing.my_model    |
| Производство  | prod              | analytics     | prod.marketing.my_model             |

:::note

Мы добавили логику для проверки, происходит ли текущий запуск dbt в производственной среде или нет. Это важно, и мы объясняем, почему в разделе [Что не следует делать](/guides/customize-schema-alias?step=3#what-not-to-do).

:::

### 2. Статические схемы: добавление идентификаторов разработчиков к таблицам

Иногда мы сталкиваемся с ситуациями, когда политика безопасности организации не позволяет разработчикам создавать схемы, и всем разработчикам необходимо разрабатывать в одной схеме.

В этом случае мы можем: 

- Создать новый файл с именем `generate_schema_name.sql` в вашей папке макросов со следующим кодом:

- Изменить `generate_schema_name()`, чтобы использовать одну схему для всех разработчиков, даже если установлена пользовательская схема.
- Обновить `generate_alias_name()`, чтобы добавить псевдоним разработчика и пользовательскую схему в начало имени таблицы в среде разработки.
    - Этот метод не идеален, так как может привести к длинным именам таблиц, но он позволит разработчикам видеть, в какой схеме модель будет создана в производственной среде.

<File name='macros/generate_schema_name.sql'>

```jinja
{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}

        {{ default_schema }}

    {%- elif  env_var('DBT_ENV_TYPE','DEV') != 'CI' -%}
        
        {{ custom_schema_name | trim }}

    {%- else -%}

        {{ default_schema }}_{{ custom_schema_name | trim }}

    {%- endif -%}

{%- endmacro %}
```
</File>

<File name='macros/generate_alias_name.sql'>

```jinja
{% macro generate_alias_name(custom_alias_name=none, node=none) -%}

    {%- if  env_var('DBT_ENV_TYPE','DEV') == 'DEV' -%}

        {%- if custom_alias_name -%}

            {{ target.schema }}__{{ custom_alias_name | trim }}

        {%- elif node.version -%}

            {{ target.schema }}__{{ node.name ~ "_v" ~ (node.version | replace(".", "_")) }}

        {%- else -%}

            {{ target.schema }}__{{ node.name }}

        {%- endif -%}
    
    {%- else -%}

        {%- if custom_alias_name -%}

            {{ custom_alias_name | trim }}

        {%- elif node.version -%}

            {{ return(node.name ~ "_v" ~ (node.version | replace(".", "_"))) }}

        {%- else -%}

            {{ node.name }}

        {%- endif -%}

    {%- endif -%}

{%- endmacro %}
```
</File>

Это создаст следующие результаты для модели с именем `my_model` с пользовательской схемой `marketing`, предотвращая любое пересечение объектов между запусками dbt из разных контекстов.

| Контекст     | Целевая база данных | Целевая схема | Результирующий объект               |
|--------------|:------------------:|:-------------:|:-----------------------------------:|
| Разработчик 1| dev                | dbt_dev1     | dev.marketing.dbt_dev1_my_model     |
| Разработчик 2| dev                | dbt_dev2     | dev.marketing.dbt_dev2_my_model     |
| CI PR 123    | ci                 | dbt_pr_123   | ci.dbt_pr_123_marketing.my_model    |
| CI PR 234    | ci                 | dbt_pr_234   | ci.dbt_pr_234_marketing.my_model    |
| Производство  | prod              | analytics     | prod.marketing.my_model             |

### 3. Использование имени ветки в качестве префикса схемы

Для команд, которые предпочитают изолировать работу на основе ветки функции, вы можете воспользоваться специальной переменной окружения `DBT_CLOUD_GIT_BRANCH`. Обратите внимание, что разработчики будут записывать в одну и ту же схему, когда они находятся на одной и той же ветке функции.

:::note

Переменная `DBT_CLOUD_GIT_BRANCH` доступна только в IDE dbt Cloud, а не в Cloud CLI.

:::

Мы также видели, что некоторые организации предпочитают организовывать свои базы данных разработки по имени ветки. Это требует реализации аналогичной логики в `generate_database_name()` вместо макроса `generate_schema_name()`. По умолчанию dbt не будет автоматически создавать базы данных.

Обратитесь к разделу [Советы и хитрости](https://docs.getdbt.com/guides/customize-schema-alias?step=5), чтобы узнать больше.    

<File name='macros/generate_schema_name.sql'>

```jinja
{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if  env_var('DBT_ENV_TYPE','DEV') == 'DEV' -%}
    
        {#- заменяем недопустимые в именах схем символы на "_" -#}
        {%- set re = modules.re -%}
        {%- set cleaned_branch = re.sub("\W", "_", env_var('DBT_CLOUD_GIT_BRANCH')) -%}
        
        {%- if custom_schema_name is none -%}

            {{ cleaned_branch }}

        {%- else -%}

             {{ cleaned_branch }}_{{ custom_schema_name | trim }}

        {%- endif -%}
        
    {%- else -%}

        {{ default_schema }}_{{ custom_schema_name | trim }}

    {%- endif -%}

{%- endmacro %}
```
</File>

Это создаст следующие результаты для модели с именем `my_model` с пользовательской схемой `marketing`, предотвращая любое пересечение объектов между запусками dbt из разных контекстов.

| Контекст     | Ветка        | Целевая база данных | Целевая схема | Результирующий объект                  |
|--------------|:------------:|:------------------:|:-------------:|:---------------------------------------:|
| Разработчик 1| `featureABC` | dev                | dbt_dev1     | dev.featureABC_marketing.my_model       |
| Разработчик 2| `featureABC` | dev                | dbt_dev2     | dev.featureABC_marketing.my_model       |
| Разработчик 1| `feature123` | dev                | dbt_dev1     | dev.feature123_marketing.my_model       |
| CI PR 123    |              | ci                 | dbt_pr_123   | ci.dbt_pr_123_marketing.my_model        |
| CI PR 234    |              | ci                 | dbt_pr_234   | ci.dbt_pr_234_marketing.my_model        |
| Производство  |              | prod               | analytics     | prod.marketing.my_model                 |

Когда разработчик 1 и разработчик 2 находятся на одной и той же ветке, они создадут один и тот же объект в хранилище данных. Это не должно быть проблемой, так как находясь на одной ветке, код модели будет одинаковым для обоих разработчиков.

### 4. Использование статической схемы для CI 

Некоторые организации предпочитают записывать свои CI задачи в одну схему с идентификатором PR, добавленным в начало имени таблицы. Важно отметить, что это приведет к длинным именам таблиц. 

Для этого вы можете создать новый файл с именем `generate_schema_name.sql` в вашей папке макросов со следующим кодом:

<File name='macros/generate_schema_name.sql'>

```jinja
{% macro generate_schema_name(custom_schema_name=none, node=none) -%}

    {%- set default_schema = target.schema -%}
    
    {# Если задача CI не существует в своем окружении, используйте переменную target.name внутри задачи #}
    {# {%- if target.name == 'CI' -%} #} 
    
    {%- if env_var('DBT_ENV_TYPE','DEV') == 'CI' -%}
        
        ci_schema
        
    {%- elif custom_schema_name is none -%}
        
        {{ default_schema }}
    
    {%- else -%}
        
        {{ default_schema }}_{{ custom_schema_name | trim }}
    
    {%- endif -%}    

{%- endmacro %}
```
</File>

<File name='macros/generate_alias_name.sql'>

```jinja
{% macro generate_alias_name(custom_alias_name=none, node=none) -%}

    {# Если задача CI не существует в своем окружении, используйте переменную target.name внутри задачи #}
    {# {%- if target.name == 'CI' -%} #}   
    {%- if  env_var('DBT_ENV_TYPE','DEV') == 'CI' -%}

        {%- if custom_alias_name -%}

            {{ target.schema }}__{{ node.config.schema }}__{{ custom_alias_name | trim }}

        {%- elif node.version -%}

            {{ target.schema }}__{{ node.config.schema }}__{{ node.name ~ "_v" ~ (node.version | replace(".", "_")) }}

        {%- else -%}

            {{ target.schema }}__{{ node.config.schema }}__{{ node.name }}

        {%- endif -%}
    
    {%- else -%}

        {%- if custom_alias_name -%}

            {{ custom_alias_name | trim }}

        {%- elif node.version -%}

            {{ return(node.name ~ "_v" ~ (node.version | replace(".", "_"))) }}

        {%- else -%}

            {{ node.name }}

        {%- endif -%}

    {%- endif -%}

{%- endmacro %}
```
</File>

Это создаст следующие результаты для модели с именем `my_model` с пользовательской схемой `marketing`, предотвращая любое пересечение объектов между запусками dbt из разных контекстов.

| Контекст     | Целевая база данных | Целевая схема | Результирующий объект                          |
|--------------|:------------------:|:-------------:|:----------------------------------------------: |
| Разработчик 1| dev                | dbt_dev1     | dev.dbt_dev1_marketing.my_model                |
| Разработчик 2| dev                | dbt_dev2     | dev.dbt_dev2_marketing.my_model                |
| CI PR 123    | ci                 | dbt_pr_123   | ci.ci_schema.dbt_pr_123_marketing_my_model     |
| CI PR 234    | ci                 | dbt_pr_234   | ci.ci_schema.dbt_pr_234_marketing_my_model     |
| Производство  | prod              | analytics     | prod.marketing.my_model                        |

## Что не следует делать

Этот раздел предоставит обзор того, чего пользователи должны избегать при настройке своей схемы и псевдонима из-за возможных проблем.

### Обновление generate_schema_name() для постоянного использования пользовательской схемы

Некоторые люди предпочитают использовать только пользовательскую схему, когда она установлена, вместо того чтобы объединять стандартную схему с пользовательской, как это происходит в стандартном поведении.

### Проблема

При изменении стандартного макроса для `generate_schema_name()` это может привести к созданию новой версии.

<File name='macros/generate_schema_name.sql'>

```jinja
{% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none -%}

        {{ default_schema }}

    {%- else -%}
    # Следующее неверно, так как пропускает {{ default_schema }} перед {{ custom_schema_name | trim }}. 
        {{ custom_schema_name | trim }} 

    {%- endif -%}

{%- endmacro %}
```
</File>

Хотя это может дать ожидаемый результат для производственной среды, где используется выделенная база данных, это приведет к конфликтам везде, где люди делят базу данных. 

Давайте рассмотрим пример модели с именем `my_model` с пользовательской схемой `marketing`.

| Контекст     | Целевая база данных | Целевая схема | Результирующий объект               |
|--------------|:------------------:|:-------------:|:-----------------------------------:|
| Производство  | prod              | analytics     | prod.marketing.my_model             |
| Разработчик 1| dev                | dbt_dev1     | dev.marketing.my_model              |
| Разработчик 2| dev                | dbt_dev2     | dev.marketing.my_model              |
| CI PR 123    | ci                 | dbt_pr_123   | ci.marketing.my_model               |
| CI PR 234    | ci                 | dbt_pr_234   | ci.marketing.my_model               |

Мы видим, что как разработчик 1, так и разработчик 2 получают один и тот же объект для `my_model`. Это означает, что если они оба работают над этой моделью одновременно, будет невозможно узнать, является ли версия, находящаяся в хранилище данных, версией разработчика 1 или разработчика 2.

Аналогично, разные PR приведут к созданию одного и того же объекта в хранилище данных. Если разные PR открыты одновременно и изменяют одни и те же модели, это очень вероятно приведет к проблемам, замедляющим весь процесс разработки и продвижения кода.

### Решение

Как описано в предыдущем примере, обновите макрос, чтобы проверить, работает ли dbt в производственной среде. Только в производственной среде мы должны удалить объединение и использовать только пользовательскую схему.

## Советы и хитрости

Этот раздел предоставит несколько полезных советов о том, как правильно настроить ваши макросы `generate_database_name()` и `generate_alias_name()`. 

### Создание несуществующих баз данных из dbt

dbt автоматически попытается создать схему, если она не существует и если объект должен быть создан в ней, но он не будет автоматически пытаться создать базу данных, которая не существует.

Таким образом, если ваша конфигурация `generate_database_name()` указывает на разные базы данных, которые могут не существовать, dbt завершит работу с ошибкой, если вы выполните простую команду `dbt build`. 

Тем не менее, это все еще возможно сделать в dbt, создав несколько макросов, которые будут проверять, существует ли база данных, и если нет, dbt создаст ее. Затем вы можете вызывать эти макросы либо в [шаге `dbt run-operation ...`](/reference/commands/run-operation) в ваших задачах, либо как [`on-run-start` хук](/reference/project-configs/on-run-start-on-run-end).

### Предположение контекста с использованием переменных окружения вместо `target.name`

Мы предпочитаем использовать [переменные окружения](/docs/build/environment-variables) вместо `target.name`. Для дальнейшего чтения ознакомьтесь с ([О переменных целевого назначения](/reference/dbt-jinja-functions/target)), чтобы расшифровать контекст вызова dbt. 

- `target.name` не может быть установлен на уровне окружения. Поэтому каждая задача в окружении должна явно указывать переопределение `target.name`. Если задача не имеет установленного соответствующего значения `target.name`, база данных/схема/псевдоним могут не разрешиться должным образом. В качестве альтернативы значения переменных окружения унаследуются задачами в соответствующих окружениях. Значения переменных окружения также могут быть переопределены в задачах, если это необходимо.

<Lightbox src="/img/docs/dbt-cloud/using-dbt-cloud/custom-schema-env-var-targetname.png" title="Настройка переменной окружения для схемы."/>

- `target.name` требует, чтобы каждый разработчик ввел одно и то же значение (часто 'dev') в разделе имени целевого назначения своих учетных данных для разработки проекта. Если разработчик не установил соответствующее значение имени целевого назначения, их база данных/схема/псевдоним могут не разрешиться должным образом. 

<Lightbox src="/img/docs/dbt-cloud/using-dbt-cloud/development-credentials.png" title="Учетные данные для разработки." width="60%" />

### Всегда обеспечивайте пользовательские схемы

Некоторые пользователи предпочитают обеспечивать пользовательские схемы для всех объектов в своих проектах. Это позволяет избежать записи в непреднамеренные "стандартные" места. Вы можете добавить эту логику в свой макрос `generate_schema_name()`, чтобы [вызывать ошибку компиляции](/reference/dbt-jinja-functions/exceptions), если для объекта не определена пользовательская схема.

<File name='macros/generate_schema_name.sql'>

```jinja
 {% macro generate_schema_name(custom_schema_name, node) -%}

    {%- set default_schema = target.schema -%}
    {%- if custom_schema_name is none and node.resource_type == 'model' -%}
        
        {{ exceptions.raise_compiler_error("Ошибка: Не определена пользовательская схема для модели " ~ node.name ) }}
    
    {%- endif -%}

```
</File>

</div>