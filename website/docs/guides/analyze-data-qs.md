---
title: "Анализируйте данные в dbt"
id: "analyze-your-data"
icon: 'dbt'
hide_table_of_contents: true
tags: ['Analyst', 'dbt platform', 'Quickstart']
intro_text: "Начните с вопроса стейкхолдера и проанализируйте данные, чтобы ответить на него, не написав ни одной строки SQL"
recently_updated: true
---

## Введение {#introduction}

Как аналитик данных, вы играете ключевую роль в преобразовании сложных данных в надёжные и практичные инсайты для вашей команды. С помощью <Constant name="cloud" /> вы можете использовать встроенные инструменты на базе ИИ для создания управляемых data models, изучения того, как они устроены, и даже запуска собственного анализа.

В этом quickstart вы узнаете, как:

* Использовать <Constant name="explorer" /> для просмотра и понимания data models как в dbt, так и в Snowflake data assets  
* Использовать <Constant name="query_page" /> для выполнения запросов с целью исследования и валидации данных  
* Использовать <Constant name="visual_editor" /> для визуального создания собственных data models  
* Повысить уверенность в работе, используя <Constant name="cloud" /> как рабочее пространство, дополненное ИИ  

Подробнее об инструментах, которые вы будете использовать:

* <Constant name="explorer" />: Просматривайте ресурсы проекта (такие как models, tests и metrics), их lineage и шаблоны запросов, чтобы лучше понимать актуальное production‑состояние проекта.  
* <Constant name="query_page" />: Исследуйте, проверяйте и запрашивайте данные с помощью интуитивного, контекстно насыщенного интерфейса, который объединяет технических и бизнес‑пользователей за счёт метаданных, документации, инструментов с ИИ‑поддержкой и мощных возможностей запросов.  
* <Constant name="visual_editor" />: Быстро получайте доступ к данным и трансформируйте их с помощью визуального интерфейса drag‑and‑drop и встроенного ИИ для генерации пользовательского кода.

## Предварительные требования {#prerequisites}

Перед началом убедитесь, что:

* У вас есть доступ и настроенные учётные данные для проекта в <Constant name="cloud" />  
* Ваша команда уже успешно запускала dbt job, поэтому models собраны и готовы к использованию  
* У вас подключён и аутентифицирован git provider  

## Рабочий процесс аналитика {#analyst-workflows}

Кимико, аналитик в Jaffle Shop, замечает, что у компании появилось много новых продаж, и хочет исследовать наиболее важные данные, которые хранятся в их хранилище.

**Вопрос: стейкхолдеру интересно, сколько клиентов вы привлекали помесячно за последние 12 месяцев.**

Кимико задаётся вопросом: «Как мне найти данные в нашем проекте, которые помогут ответить на этот вопрос?»

## Разбор вопроса стейкхолдера

Она переходит в каталог данных — <Constant name="explorer" />, войдя в <Constant name="cloud" /> и нажав <Constant name="explorer" /> в левой панели. Поскольку вопрос касается клиентов, Кимико начинает с поиска по слову “customers” в <Constant name="explorer" />:

<Lightbox src="/img/guides/analyst-qs/catalog-search.png" width="90%" title="Поиск customers в Catalog" />

Она находит model с названием **customers**, которая, возможно, ей подходит. Кимико нажимает **customers**, чтобы открыть model. В описании указано: “Customer overview data Mart offering key details for each unique customer, one row per customer.”

Затем Кимико выбирает **Columns**, чтобы посмотреть, какие колонки используются в этой model.

<Lightbox src="/img/guides/analyst-qs/columns.png" width="90%" title="Колонки в таблице customers" />

Она замечает следующие колонки: `customer_ID`, `customer_names` и `first_ordered_at`.

Колонка `first_ordered_at` особенно привлекает внимание Кимико — она предполагает, что её можно использовать, чтобы определить, сколько клиентов было привлечено на основе даты их первого заказа.

Но сначала она решает поработать с данными напрямую, чтобы лучше их понять.

### Запрос данных в Insights {#explore-a-stakeholder-question}

На **странице Customer model** в <Constant name="explorer" /> Кимико выбирает **Analyze data** в выпадающем меню **Open in...**. Это позволяет выполнять запросы к данным Customer model. После открытия <Constant name="query_page" /> уже содержит подготовленный запрос, готовый к выполнению.

<Lightbox src="/img/guides/analyst-qs/query.png" width="90%" title="Открытый запрос" />

Когда Кимико запускает запрос, она может просмотреть данные, лежащие в его основе. Тот же контекст, который она видела в <Constant name="explorer" />, теперь доступен и в интерфейсе редактирования SQL.

Просматривая данные, она видит информацию по каждому клиенту и снова обращает внимание на колонку `first_ordered_at`. Кимико хочет написать запрос, но её навыки SQL немного подзабыты, поэтому она использует естественный язык в dbt Copilot:

*Сколько новых клиентов мы получили в каждом месяце прошлого года? Я бы хотел(а) использовать мою модель клиентов и поле first ordered at, чтобы выполнить этот анализ.*

dbt Copilot генерирует SQL, который Кимико решает использовать:

```sql
select 
    date_trunc('month', first_ordered_at) as month,
    count(customer_id) as new_customers
from {{ ref('customers') }}
where 
    date_part('year', first_ordered_at) = date_part('year', current_date) - 1
    and customer_type = 'new'
group by 1
order by 1;
```

Кимико нажимает **Replace**, чтобы перенести весь SQL в редактор, заменив исходный запрос. Она запускает новый запрос и просматривает результаты, но решает ещё раз воспользоваться Copilot, чтобы ограничить даты:

*Можем ли мы ограничить даты 2024 годом?*

Она проверяет новый фильтр на 2024 год и повторно запускает запрос:

```sql
select 
    date_trunc('month', first_ordered_at) as month,
    count(customer_id) as new_customers
from {{ ref('customers') }}
where 
    date_part('year', first_ordered_at) = 2024
    and customer_type = 'new'
group by 1
order by 1;
```

Результаты её устраивают, и она нажимает **Details**, чтобы посмотреть отчёт, сгенерированный ИИ, который включает заголовок и описание, исходный SQL и скомпилированный SQL.

<Lightbox src="/img/guides/analyst-qs/details.png" width="90%" title="Таблица детализации отчёта" />

Когда Кимико готова поделиться инсайтом со стейкхолдером, она нажимает **Chart**, чтобы увидеть график, автоматически заполненный данными из вкладки **Data**.

Она добавляет подписи к осям X и Y, например “Month of first order” и “Total new customers”, чтобы сделать итоговый отчёт более понятным. Затем она делает скриншот, чтобы поделиться им со стейкхолдером.

<!-- ![ДОБАВИТЬ КАРТИНКУ Insights-axis-title](/img/analyst-walkthrough/insights-axis-title.png) -->

Кимико часто возвращается к этим данным, поэтому она решает добавить страницу в закладки, нажав **Bookmark** в правом верхнем углу. Также она экспортирует данные в CSV‑файл.

### Визуализация результатов {#query-data-in-insights}

После нескольких разговоров с коллегами Кимико узнаёт, что они выполняют очень похожие разовые запросы. Поэтому она решает взять свой долгоживущий запрос, который ранее добавила в закладки, и превратить его в полноценную dbt model с помощью <Constant name="visual_editor" />. Это позволяет ей делиться результатом с другими, устранять дублирование работы и повышать эффективность команды.

Для этого она открывает запрос в <Constant name="query_page" />, нажимает **Develop**, затем ***Develop in** <Constant name="visual_editor" />. SQL‑запрос открывается в визуальной форме, представленной в виде DAG.

<!-- ![[ДОБАВИТЬ КАРТИНКУ Canvas-overview](/img/analyst-walkthrough/canvas-overview.png) -->

Изучая model, она отмечает, что всё работает как ожидается: данные выбираются из customers, применяется фильтр на 2024 год, даты агрегируются по месяцам. Она запускает model в своей development‑среде и нажимает **Commit**, чтобы создать pull request.

<!-- ![[ДОБАВИТЬ КАРТИНКУ Canvas-commit](/img/analyst-walkthrough/canvas-commit.png) -->

Теперь вся команда Кимико — те, у кого есть такой же доступ, — может запускать эту model и видеть те же результаты! Более того, коллеги могут помогать ей улучшать model по мере усложнения запросов стейкхолдера, и Кимико будет получать пользу от их вклада.

### Запрос становится моделью {#visualize-results}

В дальнейшем Кимико может возвращаться к проекту в <Constant name="explorer" /> и запускать model, чтобы получать самые актуальные результаты. Отсюда она может:

* Вручную запускать model, что также запускает tests и сохраняет версии, позволяя Кимико отслеживать изменения со временем  
* Запускать запланированный job для выполнения dbt model, например, каждый понедельник для отчёта стейкхолдеру  
* Настроить уведомление в Slack на случай сбоя job, чтобы она могла оперативно исправить проблемы  
