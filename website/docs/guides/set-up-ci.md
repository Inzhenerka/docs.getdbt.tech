---
title: "Начало работы с тестами непрерывной интеграции"
description: Реализация среды CI для безопасной проверки проекта.
hoverSnippet: Узнайте, как реализовать среду CI для безопасной проверки проекта.
id: set-up-ci
# time_to_complete: '30 минут' закомментировано до тестирования
icon: 'guides'
hide_table_of_contents: true
tags: ['dbt Cloud', 'Оркестрация', 'CI']
level: 'Средний'
recently_updated: true
---

<div style={{maxWidth: '900px'}}>

## Введение

Проверяя свой код _до_ его выхода в продукцию, вам не придется тратить время на ответы на сообщения от людей, чьи отчеты внезапно перестали работать.

Надежная настройка CI критически важна для предотвращения ненужного простоя и потери доверия. dbt Cloud использует **разумные настройки по умолчанию**, чтобы вы могли быстро и эффективно запустить проект с минимальными затратами времени.

После этого можно будет добавить дополнительные функции, но давайте сначала разберемся с основами.

В этом руководстве мы добавим **CI-среду**, в которой предлагаемые изменения могут быть проверены в контексте всего проекта без влияния на производственные системы. Мы будем использовать один набор учетных данных для развертывания (как в Prod-среде), но модели будут строиться в отдельном месте, чтобы избежать влияния на другие (как в Dev-среде).

Ваш git-поток будет выглядеть следующим образом:
<Lightbox src="/img/best-practices/environment-setup/one-branch-git.png" title="диаграмма git-потока" />

### Предварительные требования

В рамках вашей первоначальной настройки dbt Cloud у вас уже должны быть настроены среды разработки и производства. Давайте вспомним, что делает каждая из них:

- Ваша **среда разработки** управляет IDE. У каждого пользователя есть индивидуальные учетные данные, и сборки происходят в индивидуальной dev-схеме. Ничто из того, что вы делаете здесь, не влияет на ваших коллег.
- Ваша **производственная среда** представляет каноническую версию вашего проекта для downstream-пользователей. Существует единый набор учетных данных для развертывания, и все строится в ваших производственных схемах.

## Создание новой CI-среды

Смотрите [Создание новой среды](/docs/dbt-cloud-environments#create-a-deployment-environment). Среда должна называться **CI**. Как и ваша существующая производственная среда, это будет среда типа Deployment.

При установке схемы в области **Учетные данные развертывания** помните, что dbt Cloud автоматически сгенерирует имя пользовательской схемы для каждого PR, чтобы они не мешали вашим развернутым моделям. Это означает, что вы можете безопасно установить то же имя схемы, что и в вашей производственной задаче.

### 1. Дважды проверьте, что ваша производственная среда идентифицирована

Перейдите в вашу существующую производственную среду и убедитесь, что установлен флажок **Установить как производственную среду**. Это упростит дальнейшую работу.

### 2. Создайте новую задачу в CI-среде

Используйте шаблон **Задача непрерывной интеграции** и назовите задачу **CI Check**.

В настройках выполнения ваша команда будет предустановлена на `dbt build --select state:modified+`. Давайте разберем это:

- [`dbt build`](/reference/commands/build) запускает все узлы (семена, модели, снимки, тесты) одновременно в порядке DAG. Если что-то не удается, узлы, которые зависят от него, будут пропущены.
- Селектор [`state:modified+`](/reference/node-selection/methods#state) означает, что будут запущены только измененные узлы и их дочерние узлы ("Slim CI"). В дополнение к [непотере времени](https://discourse.getdbt.com/t/how-we-sped-up-our-ci-runs-by-10x-using-slim-ci/2603) на сборку и тестирование узлов, которые не были изменены изначально, это значительно снижает вычислительные затраты.

Чтобы dbt мог находить измененные узлы, ему нужно с чем-то сравнивать. dbt Cloud использует последний успешный запуск любой задачи в вашей производственной среде в качестве своего [состояния сравнения](/reference/node-selection/syntax#about-node-selection). Если вы идентифицировали свою производственную среду на Шаге 2, вам не нужно будет это менять. Если нет, выберите правильную среду из выпадающего списка.

:::info Используйте CI для тестирования ваших метрик
Если вы [создали семантические узлы](/docs/build/build-metrics-intro) в вашем проекте dbt, вы можете [проверить их в CI-задаче](/docs/deploy/ci-jobs#semantic-validations-in-ci), чтобы убедиться, что изменения кода, внесенные в модели dbt, не нарушают эти метрики.
:::

### 3. Протестируйте ваш процесс

Вот и все! Есть и другие шаги, которые вы можете предпринять, чтобы быть еще более уверенными в своей работе, такие как проверка структуры на соответствие лучшим практикам и линтинг вашего кода. Для получения дополнительной информации смотрите [Начало работы с тестами непрерывной интеграции](/guides/set-up-ci).

Чтобы протестировать ваш новый поток, создайте новую ветку в IDE dbt Cloud, затем добавьте новый файл или измените существующий. Зафиксируйте изменения, затем создайте новый Pull Request (не черновик). В течение нескольких секунд вы увидите, что в вашем git-провайдере появится новая проверка.

### Важные моменты

- Если вы сделаете новый коммит, пока выполняется CI-запуск на основе старого кода, он будет автоматически отменен и заменен свежим кодом.
- Неограниченное количество CI-задач может выполняться одновременно. Если 10 разработчиков одновременно зафиксируют код в разных PR, каждый получит свою собственную схему, содержащую их изменения. После слияния каждого PR dbt Cloud удалит эту схему.
- CI-задачи никогда не блокируют производственный запуск.

## Принуждение к соблюдению лучших практик с помощью оценщика проектов dbt

Оценщик проектов dbt — это пакет, предназначенный для выявления отклонений от лучших практик, общих для многих проектов dbt, включая моделирование, тестирование, документацию, структуру и проблемы с производительностью. Для введения в пакет прочитайте его [блог о запуске](/blog/align-with-dbt-project-evaluator).

### 1. Установите пакет

Как и со всеми пакетами, добавьте ссылку на `dbt-labs/dbt_project_evaluator` в ваш файл `packages.yml`. Смотрите [dbt Package Hub](https://hub.getdbt.com/dbt-labs/dbt_project_evaluator/latest/) для получения полных инструкций по установке.

### 2. Определите серьезность тестов с помощью переменной окружения

Как указано в [документации](https://dbt-labs.github.io/dbt-project-evaluator/latest/ci-check/), тесты в пакете по умолчанию имеют уровень серьезности `warn`.

Чтобы эти тесты завершались с ошибкой в CI, создайте новую переменную окружения с именем `DBT_PROJECT_EVALUATOR_SEVERITY`. Установите проектный уровень по умолчанию на `warn`, а в CI-среде — на `error`.

В вашем файле `dbt_project.yml` переопределите конфигурацию серьезности:

```yaml
tests:
dbt_project_evaluator:
    +severity: "{{ env_var('DBT_PROJECT_EVALUATOR_SEVERITY', 'warn') }}"
```

### 3. Обновите ваши CI-команды

Поскольку эти тесты должны выполняться только после сборки остальной части вашего проекта, ваша существующая команда CI должна быть обновлена, чтобы исключить пакет dbt_project_evaluator. Затем вы добавите второй шаг, который будет собирать _только_ модели и тесты пакета.

Обновите ваши шаги до:

```bash
dbt build --select state:modified+ --exclude package:dbt_project_evaluator
dbt build --select package:dbt_project_evaluator
```

### 4. Примените любые настройки

В зависимости от состояния вашего проекта, когда вы развернете оценщик, вам может потребоваться пропустить некоторые тесты или разрешить исключения для некоторых областей. Для этого обратитесь к документации по:

- [отключению тестов](https://dbt-labs.github.io/dbt-project-evaluator/latest/customization/customization/)
- [исключению групп моделей из конкретного теста](https://dbt-labs.github.io/dbt-project-evaluator/latest/customization/exceptions/)
- [исключению пакетов или источников/моделей на основе пути](https://dbt-labs.github.io/dbt-project-evaluator/latest/customization/excluding-packages-and-paths/)

Если вы создаете seed для исключения групп моделей из конкретного теста, не забудьте отключить seed по умолчанию и включить `dbt_project_evaluator_exceptions` в вашу вторую команду `dbt build` выше.

## Запуск проверок линтинга с помощью SQLFluff

Проводя [линтинг](/docs/cloud/dbt-cloud-ide/lint-format#lint) вашего проекта во время CI, вы можете гарантировать, что стандарты оформления кода последовательно соблюдаются, не тратя человеческое время на мелкие детали, такие как расстановка запятых.

Ниже приведенные шаги создают действие/конвейер, который использует [SQLFluff](https://docs.sqlfluff.com/en/stable/) для сканирования вашего кода и поиска ошибок линтинга. Если у вас еще нет определенных правил SQLFluff, ознакомьтесь с [нашим рекомендуемым конфигурационным файлом](/best-practices/how-we-style/2-how-we-style-our-sql).

### 1. Создайте файл YAML для определения вашего конвейера

Файлы YAML, определенные ниже, указывают вашей платформе хостинга кода, какие шаги выполнять. В этой настройке вы говорите платформе запускать задачу линтинга SQLFluff каждый раз, когда выполняется коммит.

<Tabs
  defaultValue="github"
  values={[
    { label: 'GitHub', value: 'github', },
    {label: 'GitLab', value: 'gitlab', },
    {label: 'Bitbucket', value: 'bitbucket', },
  ]
}>
<TabItem value="github">

Действия GitHub определяются в каталоге `.github/workflows`. Чтобы определить задачу для вашего действия, добавьте новый файл с именем `lint_on_push.yml` в папку `workflows`. Ваша окончательная структура папок будет выглядеть так:

```sql
my_awesome_project
├── .github
│   ├── workflows
│   │   └── lint_on_push.yml
```

**Ключевые моменты:**

- `on:` определяет, когда конвейер запускается. Этот рабочий процесс будет запускаться каждый раз, когда код отправляется в любую ветку, кроме `main`. Для других вариантов триггеров ознакомьтесь с [документацией GitHub](https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows).
- `runs-on: ubuntu-latest` - это определяет операционную систему, которую мы используем для выполнения задачи.
- `uses:` - когда сервер Ubuntu создается, он полностью пуст. [`checkout`](https://github.com/actions/checkout#checkout-v3) и [`setup-python`](https://github.com/actions/setup-python#setup-python-v3) — это публичные действия GitHub, которые позволяют серверу получить доступ к коду в вашем репозитории и правильно настроить Python.
- `run:` - эти шаги выполняются в командной строке, как если бы вы ввели их сами. Это установит sqlfluff и выполнит линтинг проекта. Обязательно установите правильный `--dialect` для вашего проекта.

Для полного разбора свойств в файле рабочего процесса смотрите [Понимание файла рабочего процесса](https://docs.github.com/en/actions/learn-github-actions/understanding-github-actions#understanding-the-workflow-file) на сайте GitHub.

```yaml
name: линтинг проекта dbt при пуше

on:
  push:
    branches-ignore:
      - 'main'

jobs:
  # эта задача запускает SQLFluff с определенным набором правил
  # обратите внимание, что диалект установлен на Snowflake, поэтому сделайте это специфичным для вашей настройки
  # детали о правилах линтинга: https://docs.sqlfluff.com/en/stable/rules.html
  lint_project:
    name: Запуск линтера SQLFluff
    runs-on: ubuntu-latest
  
    steps:
      - uses: "actions/checkout@v3"
      - uses: "actions/setup-python@v4"
        with:
          python-version: "3.9"
      - name: Установка SQLFluff
        run: "python -m pip install sqlfluff"
      - name: Линтинг проекта
        run: "sqlfluff lint models --dialect snowflake"

```

</TabItem>
<TabItem value="gitlab">

Создайте файл `.gitlab-ci.yml` в вашем **корневом каталоге**, чтобы определить триггеры для выполнения скрипта ниже. Вы поместите код ниже в этот файл.

```sql
my_awesome_project
├── dbt_project.yml
├── .gitlab-ci.yml
```

**Ключевые моменты:**

- `image: python:3.9` - это определяет виртуальный образ, который мы используем для выполнения задачи.
- `rules:` - определяет, когда конвейер запускается. Этот рабочий процесс будет запускаться каждый раз, когда код отправляется в любую ветку, кроме `main`. Для других правил смотрите [документацию GitLab](https://docs.gitlab.com/ee/ci/yaml/#rules).
- `script:` - это то, как мы говорим GitLab-раннеру выполнить определенный выше Python-скрипт.

```yaml
image: python:3.9

stages:
  - pre-build

# эта задача запускает SQLFluff с определенным набором правил
# обратите внимание, что диалект установлен на Snowflake, поэтому сделайте это специфичным для вашей настройки
# детали о правилах линтинга: https://docs.sqlfluff.com/en/stable/rules.html
lint-project:
  stage: pre-build
  rules:
    - if: $CI_PIPELINE_SOURCE == "push" && $CI_COMMIT_BRANCH != 'main'
  script:
    - python -m pip install sqlfluff
    - sqlfluff lint models --dialect snowflake
```

</TabItem>
<TabItem value="bitbucket">

Создайте файл `bitbucket-pipelines.yml` в вашем **корневом каталоге**, чтобы определить триггеры для выполнения скрипта ниже. Вы поместите код ниже в этот файл.

```sql
my_awesome_project
├── bitbucket-pipelines.yml
├── dbt_project.yml
```

**Ключевые моменты:**

- `image: python:3.11.1` - это определяет виртуальный образ, который мы используем для выполнения задачи.
- `'**':` - это используется для фильтрации, когда конвейер запускается. В данном случае мы говорим ему запускаться на каждом событии пуша, и вы можете видеть на строке 12, что мы создаем фиктивный конвейер для `main`. Дополнительную информацию о фильтрации, когда запускается конвейер, можно найти в [документации Bitbucket](https://support.atlassian.com/bitbucket-cloud/docs/pipeline-triggers/).
- `script:` - это то, как мы говорим Bitbucket-раннеру выполнить определенный выше Python-скрипт.

```yaml
image: python:3.11.1


pipelines:
  branches:
    '**': # это устанавливает подстановочный знак для запуска на каждой ветке
      - step:
          name: Линтинг проекта dbt
          script:
            - python -m pip install sqlfluff==0.13.1
            - sqlfluff lint models --dialect snowflake --rules L019,L020,L021,L022

    'main': # переопределите, если ваша ветка по умолчанию не называется "main"
      - step:
          script:
            - python --version
```

</TabItem>
</Tabs>

### 2. Зафиксируйте и отправьте ваши изменения, чтобы убедиться, что все работает

После того как вы закончите создание файлов YAML, зафиксируйте и отправьте ваш код, чтобы запустить ваш конвейер в первый раз. Если все пройдет успешно, вы должны увидеть конвейер на вашей платформе кода. Когда вы нажмете на задачу, вы получите журнал, показывающий, что SQLFluff был запущен. Если ваш код не прошел линтинг, вы получите ошибку в задаче с описанием того, что нужно исправить. Если все прошло проверку линтинга, вы увидите успешный запуск задачи.

<Tabs
  defaultValue="github"
  values={[
    { label: 'GitHub', value: 'github', },
    {label: 'GitLab', value: 'gitlab', },
    {label: 'Bitbucket', value: 'bitbucket', },
  ]
}>
<TabItem value="github">

В вашем репозитории нажмите на вкладку _Actions_

![Изображение, показывающее действие GitHub для линтинга при пуше](/img/guides/orchestration/custom-cicd-pipelines/lint-on-push-github.png)

Пример вывода от SQLFluff в задаче `Запуск линтера SQLFluff`:

![Изображение, показывающее журналы в GitHub для выполнения SQLFluff](/img/guides/orchestration/custom-cicd-pipelines/lint-on-push-logs-github.png)

</TabItem>
<TabItem value="gitlab">

В меню перейдите в *CI/CD > Pipelines*

![Изображение, показывающее действие GitLab для линтинга при пуше](/img/guides/orchestration/custom-cicd-pipelines/lint-on-push-gitlab.png)

Пример вывода от SQLFluff в задаче `Запуск линтера SQLFluff`:

![Изображение, показывающее журналы в GitLab для выполнения SQLFluff](/img/guides/orchestration/custom-cicd-pipelines/lint-on-push-logs-gitlab.png)

</TabItem>
<TabItem value="bitbucket">

В левом меню нажмите на *Pipelines*

![Изображение, показывающее действие Bitbucket для линтинга при пуше](/img/guides/orchestration/custom-cicd-pipelines/lint-on-push-bitbucket.png)

Пример вывода от SQLFluff в задаче `Запуск линтера SQLFluff`:

![Изображение, показывающее журналы в Bitbucket для выполнения SQLFluff](/img/guides/orchestration/custom-cicd-pipelines/lint-on-push-logs-bitbucket.png)

</TabItem>
</Tabs>

## Расширенные возможности: Создание релизного поезда с дополнительными средами

Крупные и сложные предприятия иногда требуют дополнительных уровней проверки перед развертыванием. Узнайте, как добавить эти проверки с помощью dbt Cloud.

:::caution Вы уверены, что это вам нужно?
Этот подход может повысить безопасность релиза, но создает дополнительные ручные шаги в процессе развертывания, а также увеличивает нагрузку на обслуживание.

Таким образом, это может замедлить время, необходимое для внедрения новых функций в продукцию.

Команда Sunrun поддерживала соответствие SOX в развертывании в dbt, сокращая количество сред. Ознакомьтесь с [их презентацией на Coalesce](https://www.youtube.com/watch?v=vmBAO2XN-fM), чтобы узнать больше.
:::

В этом разделе мы добавим новую **QA** среду. Новые функции будут ветвиться от связанной ветки `qa` и сливаться обратно в нее, а член вашей команды (менеджер по релизам) создаст PR против `main`, чтобы его проверили в CI-среде перед выходом в продукцию.

Git-поток будет выглядеть следующим образом:
<Lightbox src="/img/best-practices/environment-setup/many-branch-git.png" title="диаграмма git-потока с промежуточной веткой" />

### Расширенные предварительные требования

- У вас есть **среды разработки**, **CI** и **производства**, как описано в [базовой настройке](/guides/set-up-ci).

### 1. Создайте ветку `release` в вашем git-репозитории

Как упоминалось выше, эта ветка будет существовать дольше любой отдельной функции и будет основой для всей разработки функций в течение определенного времени. Ваша команда может выбрать создание новой ветки для каждого спринта (`qa/sprint-01`, `qa/sprint-02` и т.д.), привязать ее к версии вашего продукта данных (`qa/1.0`, `qa/1.1`) или просто иметь одну активную ветку `qa`, которая будет оставаться активной неопределенно долго.

### 2. Обновите вашу среду разработки, чтобы использовать ветку `qa`

Смотрите [Пользовательское поведение ветки](/docs/dbt-cloud-environments#custom-branch-behavior). Установка `qa` в качестве вашей пользовательской ветки гарантирует, что IDE создаст новые ветки и PR с правильной целью, а не используя `main`.

<Lightbox src="/img/docs/dbt-cloud/cloud-configuring-dbt-cloud/dev-environment-custom-branch.png" title="Демонстрация настройки пользовательской ветки для среды" />

### 3. Создайте новую среду QA

Смотрите [Создание новой среды](/docs/dbt-cloud-environments#create-a-deployment-environment). Среда должна называться **QA**. Как и ваши существующие производственные и CI-среды, это будет среда типа Deployment.

Также установите ее ветку на `qa`.

### 4. Создайте новую задачу

Используйте шаблон **Задача непрерывной интеграции** и назовите задачу **QA Check**.

В настройках выполнения ваша команда будет предустановлена на `dbt build --select state:modified+`. Давайте разберем это:

- [`dbt build`](/reference/commands/build) запускает все узлы (семена, модели, снимки, тесты) одновременно в порядке DAG. Если что-то не удается, узлы, которые зависят от него, будут пропущены.
- Селектор [`state:modified+`](/reference/node-selection/methods#state) означает, что будут запущены только измененные узлы и их дочерние узлы ("Slim CI"). В дополнение к [непотере времени](https://discourse.getdbt.com/t/how-we-sped-up-our-ci-runs-by-10x-using-slim-ci/2603) на сборку и тестирование узлов, которые не были изменены изначально, это значительно снижает вычислительные затраты.

Чтобы dbt мог находить измененные узлы, ему нужно с чем-то сравнивать. Обычно мы используем производственную среду в качестве источника правды, но в этом случае новый код будет сливаться в `qa` задолго до того, как он попадет в ветку `main` и производственную среду. Поэтому мы захотим отложить среду Release на саму себя.

### Дополнительно: также добавьте задачу только для компиляции

dbt Cloud использует последний успешный запуск любой задачи в этой среде в качестве своего [состояния сравнения](/reference/node-selection/syntax#about-node-selection). Если у вас много PR в работе, состояние сравнения может регулярно меняться.

Добавление регулярно запланированной задачи внутри среды QA, единственной командой которой будет `dbt compile`, может регенерировать более стабильный манифест для целей сравнения.

### 5. Протестируйте ваш процесс

Когда менеджер по релизам будет готов выпустить новую версию, он вручную откроет PR из `qa` в `main` в своем git-провайдере (например, GitHub, GitLab, Azure DevOps). dbt Cloud обнаружит новый PR, после чего существующая проверка в CI-среде сработает и выполнится. При использовании [базовой конфигурации](/guides/set-up-ci) возможно инициировать создание PR изнутри IDE dbt Cloud. В рамках этой парадигмы эта кнопка создаст PR, нацеленные на вашу ветку QA.

Чтобы протестировать ваш новый поток, создайте новую ветку в IDE dbt Cloud, затем добавьте новый файл или измените существующий. Зафиксируйте изменения, затем создайте новый Pull Request (не черновик) против вашей ветки `qa`. Вы увидите, как начнут выполняться интеграционные тесты. После их завершения вручную создайте PR против `main`, и в течение нескольких секунд вы увидите, как тесты снова выполняются, но на этот раз с учетом всех изменений из всего кода, который еще не был слит в main.

</div>