---
title: "Создание новых материализаций"
id: create-new-materializations
description: Узнайте, как создать свои собственные материализации.
displayText: Создание новых материализаций
hoverSnippet: Узнайте, как создать свои собственные материализации.
# time_to_complete: '30 минут' закомментировано до тестирования
icon: 'guides'
hide_table_of_contents: true
level: 'Продвинутый'
recently_updated: true
---

<div style={{maxWidth: '900px'}}>

## Введение

Модели <Term id="materialization">материализаций</Term>, с которыми вы знакомы, такие как `table`, `view` и `incremental`, реализованы как макросы в пакете, который распространяется вместе с dbt. Вы можете ознакомиться с [исходным кодом этих материализаций](https://github.com/dbt-labs/dbt-adapters/tree/60005a0a2bd33b61cb65a591bc1604b1b3fd25d5/dbt/include/global_project/macros/materializations). Если вам нужно создать свои собственные материализации, чтение этих файлов будет хорошим началом. Продолжайте читать ниже для глубокого погружения в материализации dbt.

:::caution 

Это продвинутая функция dbt. Дайте нам знать, если вам нужна помощь! Мы всегда рады [пообщаться](http://community.getdbt.com/).

:::

## Создание материализации

Блоки материализации позволяют dbt загружать пользовательские материализации из пакетов. Блоки материализации работают очень похоже на блоки `macro`, с несколькими ключевыми исключениями. Материализации определяются следующим образом:

```sql
{% materialization [имя материализации], ["указанный адаптер" | default] %}
...
{% endmaterialization %}
```

Материализациям можно дать имя, и они могут быть связаны с конкретным адаптером. dbt выберет материализацию, связанную с используемым в данный момент адаптером, если такая существует, или вернется к адаптеру `default`. На практике это выглядит так:

<File name='macros/my_materialization.sql'>

```sql
{% materialization my_materialization_name, default %}
 -- кросс-адаптерная материализация... предположим, что Redshift не поддерживается
{% endmaterialization %}


{% materialization my_materialization_name, adapter='redshift' %}
-- переопределение материализации для Redshift
{% endmaterialization %}
```

</File>

:::info 

Способность dbt динамически выбирать правильную материализацию на основе активной базы данных называется [многофункциональным диспетчеризацией](https://en.wikipedia.org/wiki/Multiple_dispatch). Эта функция открывает целый мир возможностей совместимости между базами данных — если вас это интересует, дайте нам знать в Slack!

:::

### Анатомия материализации

Материализации отвечают за преобразование SQL-запроса модели dbt в преобразованный набор данных в базе данных. Таким образом, материализации обычно имеют следующую структуру:

1. Подготовка базы данных для новой модели
2. Выполнение предварительных хуков
3. Выполнение любого SQL, необходимого для реализации желаемой материализации
4. Выполнение пост-модельных хуков
5. Очистка базы данных по мере необходимости
6. Обновление кэша Relation

Каждая из этих задач объясняется в следующих разделах.

### Подготовка базы данных

Материализации отвечают за создание новых таблиц или <Term id="view">представлений</Term> в базе данных, или за вставку/обновление/удаление данных из существующих таблиц. Таким образом, материализации должны знать о состоянии базы данных, чтобы определить, какой именно SQL им следует выполнять. Вот некоторый псевдокод для фазы "настройки" материализации **<Term id="table" />**:

```sql
-- Обратитесь к материализации таблицы (ссылка выше) для примера реального синтаксиса
-- Этот код не будет работать и предназначен только для демонстрационных целей
{% set existing = adapter.get_relation(this) %}
{% if existing and existing.is_view  %}
  {% do adapter.drop_relation(existing) %}
{% endif %}
```

В этом примере метод `get_relation` используется для получения состояния текущей модели, выполняемой в базе данных. Если модель существует как представление, то это представление удаляется, чтобы освободить место для таблицы, которая будет создана позже в материализации.

Это упрощенный пример, и фаза настройки для материализации может стать довольно сложной! При создании материализации обязательно учитывайте состояние базы данных и любые предоставленные [флаги](/reference/dbt-jinja-functions/flags) (например, `--full-refresh`), чтобы убедиться, что код материализации работает правильно в различных сценариях.

### Выполнение предварительных хуков

Предварительные и пост-хуки могут быть указаны для любой модели — убедитесь, что ваша материализация хорошо работает с этими настройками. Две переменные, `pre_hooks` и `post_hooks`, автоматически внедряются в контекст материализации. Вызывайте эти хуки в соответствующее время с помощью:

```sql
...
{{ run_hooks(pre_hooks) }}
....
```

### Выполнение SQL

Постройте свою материализацию <Term id="dml" /> с учетом различных вариантов существования <Term id="table" />, флагов материализации и т.д. Существует множество [функций адаптера](/reference/dbt-jinja-functions/adapter) и контекстных переменных, которые могут помочь вам в этом. Обязательно ознакомьтесь с разделом Справка на этом сайте для получения полного списка переменных и функций, доступных вам.

### Выполнение пост-хуков

Смотрите раздел выше о предварительных хуках для получения дополнительной информации о выполнении пост-хуков.

### Очистка

Фаза "очистки" материализации обычно переименовывает или удаляет отношения и фиксирует транзакцию, открытую на этапе "подготовки" выше. Например, материализация `table` выполняет следующий код очистки:

```
{{ drop_relation_if_exists(backup_relation) }}
```

Обязательно выполните `commit` транзакцию в фазе очистки материализации с помощью `{{ adapter.commit() }}`. Если вы не зафиксируете эту транзакцию, она будет отменена dbt, и преобразования, примененные в вашей материализации, будут утеряны.

### Обновление кэша Relation

Материализации должны [возвращать](/reference/dbt-jinja-functions/return) список отношений, которые они создали в конце выполнения. dbt будет использовать этот список отношений для обновления кэша отношений, чтобы уменьшить количество запросов, выполняемых против `information_schema` базы данных. Если список отношений не возвращается, dbt выдаст предупреждение о устаревании и выведет созданное отношение из настроенной базы данных, схемы и псевдонима модели.

<File name='macros/my_view_materialization.sql'>

```sql
{%- materialization my_view, default -%}

  {%- set target_relation = api.Relation.create(
        identifier=this.identifier, schema=this.schema, database=this.database,
        type='view') -%}

  -- ... настройка базы данных ...
  -- ... выполнение предварительных хуков...

  -- создание модели
  {% call statement('main') -%}
    {{ create_view_as(target_relation, sql) }}
  {%- endcall %}
  
  -- ... выполнение пост-хуков ...
  -- ... очистка базы данных...

  -- Возврат отношений, созданных в этой материализации
  {{ return({'relations': [target_relation]}) }}

{%- endmaterialization -%}

```

</File>

Если материализация создает только одно отношение, то возвращение этого отношения в конце материализации достаточно для синхронизации кэша Relation dbt. Если материализация *переименовывает* или *удаляет* отношения, отличные от отношения, возвращаемого материализацией, то потребуется дополнительная работа для поддержания синхронизации кэша с базой данных.

Чтобы явно удалить отношение из кэша, используйте [adapter.drop_relation](/reference/dbt-jinja-functions/adapter). Чтобы явно переименовать отношение в кэше, используйте [adapter.rename_relation](/reference/dbt-jinja-functions/adapter). Вызов этих методов предпочтительнее, чем выполнение соответствующего SQL напрямую, так как они изменят кэш по мере необходимости. Если вам действительно нужно выполнить SQL для удаления или переименования отношений напрямую, используйте методы `adapter.cache_dropped` и `adapter.cache_renamed`, чтобы синхронизировать кэш.

## Конфигурация материализации

Материализации поддерживают пользовательскую конфигурацию. Вы, возможно, знакомы с некоторыми из этих конфигураций из материализаций, таких как `unique_key` в [инкрементальных моделях](/docs/build/incremental-models) или `strategy` в [снимках](/docs/build/snapshots).

### Указание параметров конфигурации

Конфигурации материализации могут быть "необязательными" или "обязательными". Если пользователь не предоставляет обязательные конфигурации, dbt выдаст ошибку компиляции. Вы можете определить эти параметры конфигурации с помощью функций `config.get` и `config.require`.

```
# необязательный
config.get('optional_config_name', default="значение по умолчанию") 
# обязательный
config.require('required_config_name')
```

Для получения дополнительной информации о функции `config` в dbt Jinja, смотрите справочник по [config](/reference/dbt-jinja-functions/config).

## Приоритет материализации

dbt выберет макрос материализации в следующем порядке (меньший имеет приоритет):

1. глобальный проект - по умолчанию
2. глобальный проект - специфичный для плагина
3. импортированный пакет - по умолчанию
4. импортированный пакет - специфичный для плагина
5. локальный проект - по умолчанию
6. локальный проект - специфичный для плагина

В каждом из указанных пространств поиска материализация может быть определена только один раз. Два разных импортированных пакета не могут предоставлять одну и ту же материализацию - будет выдана ошибка.

Конкретные материализации можно выбрать, используя нотацию с точками при выборе материализации из контекста.

Мы рекомендуем _не_ переопределять имена материализаций напрямую, а вместо этого использовать префикс или суффикс, чтобы обозначить, что материализация изменяет поведение реализации по умолчанию (например, my_project_incremental).

</div>