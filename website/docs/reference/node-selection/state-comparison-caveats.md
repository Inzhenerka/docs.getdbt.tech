---
title: "Предостережения при сравнении состояний"
---

import StateModified from '/snippets/_state-modified-compare.md';

Метод выбора [`state:`](/reference/node-selection/methods#state) — это мощная функция с множеством сложностей. Ниже приведены некоторые соображения при настройке автоматизированных задач, использующих сравнение состояний.

### Seeds

dbt сохраняет хэш-файл seed-файлов размером менее 1 МиБ. Если содержимое этих seed-файлов изменено, seed будет включен в `state:modified`.

Если seed-файл больше 1 МиБ, dbt не может сравнить его содержимое и выдаст предупреждение. Вместо этого dbt будет использовать только путь к файлу seed для обнаружения изменений. Если путь к файлу изменился, seed будет включен в `state:modified`; если нет, то не будет.

### Макросы

dbt пометит как измененные все ресурсы, которые зависят от измененного макроса или от макроса, который зависит от измененного макроса.

### Переменные

Если модель использует `var` или `env_var` в своем определении, dbt в настоящее время не может определить эту зависимость таким образом, чтобы включить модель в `state:modified`, если значение `var` или `env_var` изменилось. Вероятно, модель будет помечена как измененная, если изменение переменной приведет к другой конфигурации.

### Тесты

Команда `dbt test -s state:modified` будет включать как:
- тесты, которые выбирают из нового/измененного ресурса
- тесты, которые сами по себе новые или измененные

Пока вы добавляете или изменяете тесты одновременно с добавлением или изменением ресурсов (моделей, seed-файлов, снимков), из которых они выбирают, все должно работать так, как вы ожидаете, с "простым" выбором состояния:

```shell
dbt run -s "state:modified"
dbt test -s "state:modified"
```

Однако это может усложниться. Если вы добавите новый тест без изменения его базовой модели или добавите тест, который выбирает из новой модели и старой неизмененной, вам может понадобиться протестировать модель, не запустив ее сначала.

Вы можете отложить ссылки на вышестоящие элементы при тестировании. Например, если тест выбирает из модели, которая не существует как объект базы данных в вашей текущей среде, dbt обратится к другой среде — той, которая определена в вашем манифесте состояния. Это позволяет использовать "простой" выбор состояния без риска сбоя запроса, но может иметь неожиданные последствия для тестов с несколькими родителями. Например, если у вас есть тест `relationships`, который зависит от одной измененной модели и одной неизмененной, запрос теста будет выбирать данные "между" двумя разными средами. Если вы ограничиваете или выбираете данные в разработке и CI, может не иметь смысла проверять целостность ссылок, зная, что есть большая вероятность несоответствия.

Если вы часто используете тесты `relationships` или тесты данных, или часто добавляете тесты без изменения их базовых моделей, рассмотрите возможность настройки критериев выбора для вашей CI-задачи. Например:

```shell
dbt run -s "state:modified"
dbt test -s "state:modified" --exclude "test_name:relationships"
```

### Ложные срабатывания

<VersionBlock firstVersion="1.9">

Чтобы уменьшить количество ложных срабатываний при выборе `state:modified` из-за логики, зависящей от окружения, вы можете установить флаг поведения `state_modified_compare_more_unrendered_values` в значение `True`.

<StateModified features={'/snippets/_state-modified-compare.md'}/>

</VersionBlock>

<VersionBlock lastVersion="1.8">
Сравнение состояний работает путем выявления расхождений между двумя манифестами. Эти расхождения могут быть результатом:

1. Изменений, внесенных в проект в процессе разработки
2. Логики, зависящей от окружения, которая вызывает различное поведение в зависимости от `target`, переменных окружения и т.д., что можно избежать, если вы обновитесь до dbt Core 1.9 и установите флаг поведения `state_modified_compare_more_unrendered_values` в значение `True`.

Сравнение состояний обнаруживает конфигурацию, зависящую от окружения, в `dbt_project.yml`. Эта конфигурация на основе цели не будет зарегистрирована как изменение:

<File name='dbt_project.yml'>

```yml
models:
  +materialized: "{{ 'table' if target.name == 'prod' else 'view' }}"
```

</File>

Конечно, если необработанное выражение Jinja изменено, оно будет помечено как изменение.

Обратите внимание, что на данный момент это улучшенное обнаружение верно _только_ для конфигурации `dbt_project.yml`. Оно не применяется к:
- свойствам ресурсов в `.yml` (включая `sources`)
- конфигурации в файле `config()`

Это означает, что следующая конфигурация, функционально идентичная приведенной выше, _будет_ помечена как изменение при сравнении между целями:

```sql
{{ config(
    materialized = ('table' if target.name == 'prod' else 'view')
) }}
```
</VersionBlock>

### Заключительное замечание

Сравнение состояний — это сложный процесс. Мы надеемся достичь конечной согласованности между всеми вариантами конфигурации, а также предоставить пользователям контроль, необходимый для надежного возврата всех измененных ресурсов и только тех, которые они ожидают. Если вы хотите узнать больше, прочитайте [открытые вопросы с тегом "state"](https://github.com/dbt-labs/dbt-core/issues?q=is%3Aopen+is%3Aissue+label%3Astate) в репозитории dbt.