---
title: "Ограничения при сравнении состояний"
---

import StateModified from '/snippets/_state-modified-compare.md';

Метод выбора [`state:`](/reference/node-selection/methods#state) является мощной функцией, обладающей значительной внутренней сложностью. Ниже приведены несколько моментов, которые следует учитывать при настройке автоматизированных задач, использующих сравнение состояний.

### Seeds

dbt хранит хэш файла seed-файлов, размер которых меньше 1 МиБ. Если содержимое этих seed-файлов изменяется, seed будет включен в `state:modified`.

Если seed-файл превышает 1 МиБ, dbt не может сравнить его содержимое и выдаст соответствующее предупреждение. Вместо этого dbt будет использовать только путь к seed-файлу для обнаружения изменений. Если путь к файлу изменился, seed будет включен в `state:modified`; если нет, то не будет.

### Macros

dbt пометит как измененные любые ресурсы, которые зависят от измененной макроса или от макроса, который зависит от измененной макроса.

### Vars

Если модель использует `var` или `env_var` в своем определении, dbt в настоящее время не может идентифицировать эту зависимость таким образом, чтобы включить модель в `state:modified`, поскольку значение `var` или `env_var` изменилось. Скорее всего, модель будет помечена как измененная, если изменение переменной приведет к другой конфигурации.

### Tests

Команда `dbt test -s state:modified` будет включать как:
- тесты, которые выбирают из нового/измененного ресурса
- тесты, которые сами являются новыми или измененными

При условии, что вы добавляете или изменяете тесты одновременно с добавлением или изменением ресурсов (моделей, seed-файлов, снимков), все должно работать так, как вы ожидаете, с "простым" выбором состояния:

```shell
dbt run -s "state:modified"
dbt test -s "state:modified"
```

Однако это может усложниться. Если вы добавите новый тест, не изменяя его базовую модель, или добавите тест, который выбирает из новой модели и старой неизмененной, вам может потребоваться протестировать модель, не запуская ее сначала.

Вы можете отложить ссылки на вышестоящие элементы при тестировании. Например, если тест выбирает из модели, которая не существует как объект базы данных в вашей текущей среде, dbt будет искать в другой среде — той, которая определена в вашем манифесте состояния. Это позволяет использовать "простой" выбор состояния без риска сбоя запроса, но может иметь некоторые неожиданные последствия для тестов с несколькими родителями. Например, если у вас есть тест `relationships`, который зависит от одной измененной модели и одной неизмененной модели, запрос теста будет выбирать данные "из" двух разных сред. Если вы ограничиваете или отбираете свои данные в разработке и CI, может не иметь смысла тестировать на референциальную целостность, зная, что существует высокая вероятность несоответствия.

Если вы часто используете тесты `relationships` или тесты данных, или часто добавляете тесты, не изменяя их базовые модели, подумайте о том, чтобы изменить критерии выбора вашей CI-задачи. Например:

```shell
dbt run -s "state:modified"
dbt test -s "state:modified" --exclude "test_name:relationships"
```

### Ложные срабатывания

<VersionBlock firstVersion="1.9">

Чтобы уменьшить количество ложных срабатываний при выборе `state:modified` из-за логики, зависящей от окружения, вы можете установить флаг поведения `state_modified_compare_more_unrendered_values` [флаг поведения](/reference/global-configs/behavior-changes#behavior-change-flags) в значение `True`.

<StateModified features={'/snippets/_state-modified-compare.md'}/>

</VersionBlock>

<VersionBlock lastVersion="1.8">
Сравнение состояний работает путем выявления несоответствий между двумя манифестами. Эти несоответствия могут быть результатом:

1. Изменений, внесенных в проект в процессе разработки
2. Логики, зависящей от окружения, которая вызывает различное поведение в зависимости от `target`, переменных окружения и т. д., что можно избежать, если вы обновите до dbt Core 1.9 и установите флаг поведения `state_modified_compare_more_unrendered_values` [флаг поведения](/reference/global-configs/behavior-changes#behavior-change-flags) в значение `True`.

Сравнение состояний обнаруживает конфигурацию, зависящую от окружения, в `dbt_project.yml`. Эта конфигурация, основанная на цели, не будет зарегистрирована как изменение:

<File name='dbt_project.yml'>

```yml
models:
  +materialized: "{{ 'table' if target.name == 'prod' else 'view' }}"
```

</File>

Конечно, если исходное выражение Jinja изменится, оно будет помечено как изменение.

Обратите внимание, что на данный момент это улучшенное обнаружение действительно _только_ для конфигурации `dbt_project.yml`. Оно не применяется к:
- свойствам ресурсов `.yml` (включая `sources`)
- `config()` в файле

Это означает, что следующая конфигурация — функционально идентичная приведенному выше фрагменту — _будет_ помечена как изменение при сравнении между целями:

```sql
{{ config(
    materialized = ('table' if target.name == 'prod' else 'view')
) }}
```
</VersionBlock>

### Заключительная заметка

Сравнение состояний является сложным процессом. Мы надеемся достичь окончательной согласованности между всеми параметрами конфигурации, а также предоставить пользователям контроль, необходимый для надежного возврата всех измененных ресурсов и только тех, которые они ожидают. Если вы хотите узнать больше, прочитайте [открытые проблемы с тегом "state"](https://github.com/dbt-labs/dbt-core/issues?q=is%3Aopen+is%3Aissue+label%3Astate) в репозитории dbt.