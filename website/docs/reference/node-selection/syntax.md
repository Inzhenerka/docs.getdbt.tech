---
title: "Обзор синтаксиса"
---

Синтаксис выбора узлов в dbt позволяет запускать только определенные ресурсы в рамках одного вызова dbt. Этот синтаксис выбора используется для следующих подкоманд:

| команда                         | аргумент(ы)                                                          |
| :------------------------------ | -------------------------------------------------------------------- |
| [run](/reference/commands/run)             | `--select`, `--exclude`, `--selector`, `--defer`                     |
| [test](/reference/commands/test)           | `--select`, `--exclude`, `--selector`, `--defer`                     |
| [seed](/reference/commands/seed)           | `--select`, `--exclude`, `--selector`                                |
| [snapshot](/reference/commands/snapshot)   | `--select`, `--exclude`, `--selector`                                |
| [ls (list)](/reference/commands/list)      | `--select`, `--exclude`, `--selector`, `--resource-type`             |
| [compile](/reference/commands/compile)     | `--select`, `--exclude`, `--selector`, `--inline`                    |
| [freshness](/reference/commands/source)    | `--select`, `--exclude`, `--selector`                                |
| [build](/reference/commands/build)         | `--select`, `--exclude`, `--selector`, `--resource-type`, `--defer`  |
| [docs generate](/reference/commands/cmd-docs) | `--select`, `--exclude`, `--selector`                  |

:::info Узлы и ресурсы

Мы используем термины <a href="https://en.wikipedia.org/wiki/Vertex_(graph_theory)">"узлы"</a> и "ресурсы" взаимозаменяемо. Они охватывают все модели, тесты, источники, семена, снимки, экспозиции и анализы в вашем проекте. Это объекты, которые составляют DAG (ориентированный ациклический граф) dbt.
:::

## Указание ресурсов

По умолчанию команда `dbt run` выполняет _все_ модели в графе зависимостей; `dbt seed` создает все семена, `dbt snapshot` выполняет каждый снимок. Флаг `--select` используется для указания подмножества узлов для выполнения.

Чтобы следовать [стандартам POSIX](https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html) и сделать все более понятным, мы рекомендуем пользователям CLI использовать кавычки при передаче аргументов к опциям `--select` или `--exclude` (включая один или несколько аргументов, разделенных пробелами или запятыми). Неиспользование кавычек может не работать надежно на всех операционных системах, терминалах и пользовательских интерфейсах. Например, `dbt run --select "my_dbt_project_name"` запускает все модели в вашем проекте.

### Как работает выбор?

1. dbt собирает все ресурсы, которые соответствуют одному или нескольким критериям `--select`, в порядке [методов выбора](/reference/node-selection/methods) (например, `tag:`), затем [графических операторов](/reference/node-selection/graph-operators) (например, `+`), и, наконец, операторов множеств ([объединения](/reference/node-selection/set-operators#unions), [пересечения](/reference/node-selection/set-operators#intersections), [исключения](/reference/node-selection/exclude)).

2. Выбранные ресурсы могут быть моделями, источниками, семенами, снимками, тестами. (Тесты также могут быть выбраны "косвенно" через их родительские узлы; см. [примеры выбора тестов](/reference/node-selection/test-selection-examples) для подробностей.)

3. Теперь у dbt есть список все еще выбранных ресурсов различных типов. На последнем этапе он отбрасывает любые ресурсы, которые не соответствуют типу ресурса текущей задачи. (Только семена сохраняются для `dbt seed`, только модели для `dbt run`, только тесты для `dbt test` и так далее.)

## Сокращения

Выберите ресурсы для сборки (запуска, тестирования, семен, снимков) или проверки свежести: `--select`, `-s`

### Примеры

По умолчанию команда `dbt run` выполнит _все_ модели в графе зависимостей. Во время разработки (и развертывания) полезно указывать только подмножество моделей для запуска. Используйте флаг `--select` с `dbt run`, чтобы выбрать подмножество моделей для выполнения. Обратите внимание, что следующие аргументы (`--select`, `--exclude` и `--selector`) также применимы к другим задачам dbt, таким как `test` и `build`.

<Tabs>
<TabItem value="select" label="Примеры флага select">

Флаг `--select` принимает один или несколько аргументов. Каждый аргумент может быть одним из:

1. имя пакета
2. имя модели
3. полностью квалифицированный путь к каталогу моделей
4. метод выбора (`path:`, `tag:`, `config:`, `test_type:`, `test_name:`)

Примеры:

```bash
dbt run --select "my_dbt_project_name"   # запускает все модели в вашем проекте
dbt run --select "my_dbt_model"          # запускает конкретную модель
dbt run --select "path/to/my/models"     # запускает все модели в конкретном каталоге
dbt run --select "my_package.some_model" # запускает конкретную модель в конкретном пакете
dbt run --select "tag:nightly"           # запускает модели с тегом "nightly"
dbt run --select "path/to/models"        # запускает модели, содержащиеся в path/to/models
dbt run --select "path/to/my_model.sql"  # запускает конкретную модель по ее пути
```

</TabItem>

<TabItem value="subset" label="Примеры подмножеств узлов">

dbt поддерживает сокращенный язык для определения подмножеств узлов. Этот язык использует следующие символы:

- оператор плюс [(`+`)](/reference/node-selection/graph-operators#the-plus-operator)
- оператор at [(`@`)](/reference/node-selection/graph-operators#the-at-operator)
- оператор звездочка (`*`)
- оператор запятая (`,`)

Примеры:

```bash
# можно указать несколько аргументов для --select
dbt run --select "my_first_model my_second_model"

# выбрать my_model и всех его детей
dbt run --select "my_model+"     

# выбрать my_model, его детей и родителей его детей
dbt run --models @my_model          

# эти аргументы могут быть проектами, моделями, путями к каталогам, тегами или источниками
dbt run --select "tag:nightly my_model finance.base.*"

# используйте методы и пересечения для более сложных селекторов
dbt run --select "path:marts/finance,tag:nightly,config.materialized:table"
```

</TabItem>

</Tabs>

По мере усложнения вашей логики выбора и затруднения ее ввода в виде аргументов командной строки, рассмотрите возможность использования [yaml селектора](/reference/node-selection/yaml-selectors). Вы можете использовать предопределенное определение с флагом `--selector`. Обратите внимание, что при использовании `--selector` большинство других флагов (в частности, `--select` и `--exclude`) будут игнорироваться.

### Устранение неполадок с помощью команды `ls`

Создание и отладка вашего синтаксиса выбора может быть сложной задачей. Чтобы получить "предварительный просмотр" того, что будет выбрано, мы рекомендуем использовать команду [`list`](/reference/commands/list). Эта команда, в сочетании с вашим синтаксисом выбора, выведет список узлов, которые соответствуют критериям выбора. Команда `dbt ls` поддерживает все типы аргументов синтаксиса выбора, например:

```bash
dbt ls --select "path/to/my/models" # Перечисляет все модели в конкретном каталоге.
dbt ls --select "source_status:fresher+" # Показывает источники, обновленные с момента последнего запуска свежести источников dbt.
dbt ls --select state:modified+ # Отображает узлы, измененные по сравнению с предыдущим состоянием.
dbt ls --select "result:<status>+" state:modified+ --state ./<dbt-artifact-path> # Перечисляет узлы, которые соответствуют определенным [статусам результата](/reference/node-selection/syntax#the-result-status) и были изменены.
```

<Snippet path="discourse-help-feed-header" />
<DiscourseHelpFeed tags="node-selection"/>

## Выбор состояния

Одно из основных предположений о dbt заключается в том, что его операции должны быть **без состояния** и **<Term id="idempotent" />**. То есть не имеет значения, сколько раз модель была запущена ранее, или запускалась ли она вообще. Не имеет значения, запускаете ли вы ее один раз или тысячу раз. При наличии одних и тех же исходных данных вы можете ожидать одинаковый преобразованный результат. Конкретный запуск dbt не должен "знать" о _любом другом_ запуске; ему просто нужно знать о коде в проекте и объектах в вашей базе данных, как они существуют _в данный момент_.

Тем не менее, dbt действительно хранит "состояние" — детализированный, моментный обзор ресурсов проекта (также называемых узлами), объектов базы данных и результатов вызова — в виде своих [артефактов](/docs/deploy/artifacts). Если вы хотите, dbt может использовать эти артефакты для информирования о некоторых операциях. Критически важно, что сами операции по-прежнему без состояния и <Term id="idempotent" />: при наличии одного и того же манифеста и одних и тех же исходных данных dbt будет производить один и тот же преобразованный результат.

dbt может использовать артефакты из предыдущего вызова, если их путь файла передан флагу `--state`. Это предварительное условие для:
- [Селектора `state`](/reference/node-selection/methods#state), с помощью которого dbt может идентифицировать ресурсы, которые являются новыми или измененными, сравнивая код в текущем проекте с манифестом состояния.
- [Отложенного выполнения](/reference/node-selection/defer) в другую среду, с помощью которого dbt может идентифицировать верхние, невыбранные ресурсы, которые не существуют в вашей текущей среде, и вместо этого "отложить" их ссылки на среду, предоставленную манифестом состояния.
- Команды [`dbt clone`](/reference/commands/clone), с помощью которой dbt может клонировать узлы на основе их местоположения в манифесте, предоставленном флагу `--state`.

Вместе селектор [`state`](/reference/node-selection/methods#state) и отложение позволяют реализовать ["тонкий CI"](/best-practices/best-practice-workflows#run-only-modified-models-to-test-changes-slim-ci). Мы ожидаем добавить больше функций в будущих релизах, которые смогут использовать артефакты, переданные флагу `--state`.

### Установление состояния

Состояние и отложение могут быть установлены как переменные окружения, так и флагами CLI:

- `--state` или `DBT_STATE`: путь к файлу
- `--defer` или `DBT_DEFER`: логическое значение

:::warning Устаревший синтаксис

В dbt v1.5 мы устарели оригинальный синтаксис для состояния (`DBT_ARTIFACT_STATE_PATH`) и отложенного выполнения (`DBT_DEFER_TO_STATE`). Хотя dbt поддерживает обратную совместимость со старым синтаксисом, мы удалим его в будущем релизе, который еще не определен.

:::

- `--state` или `DBT_STATE`: путь к файлу
- `--defer` или `DBT_DEFER`: логическое значение
- `--defer-state` или `DBT_DEFER_STATE`: путь к файлу, который будет использоваться только для отложенного выполнения (необязательно)

Если `--defer-state` не указан, отложение будет использовать артефакты, предоставленные `--state`. Это позволяет более детально контролировать случаи, когда вы хотите сравнить с логическим состоянием из одной среды или прошлого момента времени и отложить к примененному состоянию из другой среды или момента времени.

Если указаны как флаг, так и переменная окружения, флаг имеет приоритет.

#### Примечания:
- Артефакты `--state` должны быть совместимы с версиями схемы, которые соответствуют текущей версии dbt.
- Это мощные, сложные функции. Ознакомьтесь с [известными ограничениями и недостатками](/reference/node-selection/state-comparison-caveats) для сравнения состояния.

### Статус "результата"

Еще одним элементом состояния задания является `result` предыдущего вызова dbt. После выполнения `dbt run`, например, dbt создает артефакт `run_results.json`, который содержит время выполнения и статус успеха / ошибки для моделей dbt. Вы можете узнать больше о `run_results.json` на странице ['результаты выполнения'](/reference/artifacts/run-results-json). 

Следующие команды dbt создают артефакты `run_results.json`, результаты которых могут быть использованы в последующих вызовах dbt:  
- `dbt run`
- `dbt test`
- `dbt build` (новинка в версии dbt v0.21.0)
- `dbt seed` 

После выполнения одной из вышеуказанных команд вы можете ссылаться на результаты, добавив селектор к следующей команде следующим образом: 

```bash
# Вы также можете установить переменную окружения DBT_STATE вместо флага --state.
dbt run --select "result:<status>" --defer --state path/to/prod/artifacts
```

Доступные опции зависят от типа ресурса (узла): 

|      `result:\<status>`        | модель | семя | снимок | тест |
|----------------|-------|------|------|----------|
| `result:error`   | ✅  | ✅   | ✅   |  ✅      |
| `result:success` | ✅  | ✅   | ✅   |          |
| `result:skipped` | ✅  |      | ✅   |  ✅      |
| `result:fail`    |     |      |      |  ✅      |
| `result:warn`    |     |      |      |  ✅      |
| `result:pass`    |     |      |      |  ✅      |

### Сочетание селекторов `state` и `result`

Селекторы состояния и результата также могут быть объединены в одном вызове dbt, чтобы захватить ошибки из предыдущего запуска ИЛИ любые новые или измененные модели.

```bash
dbt run --select "result:<status>+" state:modified+ --defer --state ./<dbt-artifact-path>
```

### Статус "source_status"

Еще одним элементом состояния задания является `source_status` предыдущего вызова dbt. После выполнения `dbt source freshness`, например, dbt создает артефакт `sources.json`, который содержит время выполнения и даты `max_loaded_at` для источников dbt. Вы можете узнать больше о `sources.json` на странице ['источники'](/reference/artifacts/sources-json). 

Команда `dbt source freshness` создает артефакт `sources.json`, результаты которого могут быть использованы в последующих вызовах dbt. 

Когда задание выбрано, dbt Cloud отобразит артефакты из последнего успешного выполнения этого задания. Затем dbt использует эти артефакты для определения набора свежих источников. В ваших командах задания вы можете указать dbt запускать и тестировать только на более свежих источниках и их детях, добавив аргумент `source_status:fresher+`. Это требует, чтобы как предыдущее, так и текущее состояния имели доступный артефакт `sources.json`. Или проще говоря, оба состояния задания должны запускать `dbt source freshness`.

После выполнения команды `dbt source freshness` вы можете ссылаться на результаты свежести источников, добавив селектор к следующей команде:

```bash
# Вы также можете установить переменную окружения DBT_ARTIFACT_STATE_PATH вместо флага --state.
dbt source freshness # должен быть запущен снова для сравнения текущего и предыдущего состояния
dbt build --select "source_status:fresher+" --state path/to/prod/artifacts
```
Для получения дополнительных примеров команд обратитесь к [Советам по рабочим процессам](/best-practices/best-practice-workflows#pro-tips-for-workflows).