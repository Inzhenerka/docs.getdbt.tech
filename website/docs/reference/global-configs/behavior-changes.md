---
title: "Изменения в поведении"
id: "behavior-changes"
sidebar: "Изменения в поведении"
---

import StateModified from '/snippets/_state-modified-compare.md';

Большинство флагов существуют для настройки поведения во время выполнения с несколькими допустимыми вариантами. Правильный выбор может варьироваться в зависимости от окружения, предпочтений пользователя или конкретного вызова.

Еще одна категория флагов предоставляет существующим проектам окно миграции для поведения во время выполнения, которое изменяется в новых версиях dbt. Эти флаги помогают достичь баланса между этими целями, которые в противном случае могут находиться в напряжении, путем:
- Предоставления лучшего, более разумного и более последовательного поведения по умолчанию для новых пользователей/проектов.
- Предоставления окна миграции для существующих пользователей/проектов — ничего не меняется за ночь без предупреждения.
- Обеспечения поддерживаемости программного обеспечения dbt. Каждое изменение в поведении требует дополнительного тестирования и когнитивных затрат, что замедляет будущее развитие. Эти флаги существуют для облегчения миграции от "текущего" к "лучшему", а не для того, чтобы оставаться навсегда.

Эти флаги проходят три фазы разработки:
1. **Введение (по умолчанию отключено):** dbt добавляет логику для поддержки как 'старого', так и 'нового' поведения. 'Новое' поведение закрыто за флагом, отключенным по умолчанию, сохраняя старое поведение.
2. **Зрелость (включено по умолчанию):** Значение флага переключается с `false` на `true`, включая новое поведение по умолчанию. Пользователи могут сохранить 'старое' поведение и отказаться от 'нового' поведения, установив флаг в `false` в своих проектах. При этом они могут увидеть предупреждения о устаревании.
3. **Удаление (обычно включено):** После пометки флага для устаревания мы удаляем его вместе со 'старым' поведением, которое он поддерживал, из кодовой базы dbt. Мы стремимся поддерживать большинство флагов неопределенно, но не обязуемся поддерживать их вечно. Если мы решим удалить флаг, мы предоставим значительное предварительное уведомление.

## Что такое изменение поведения?

Один и тот же код проекта dbt и одни и те же команды dbt возвращают один результат до изменения поведения и возвращают другой результат после изменения поведения.

Примеры изменений поведения:
- dbt начинает выдавать ошибку валидации, которую ранее не выдавал.
- dbt изменяет сигнатуру встроенной макроса. Ваш проект имеет собственную переимплементацию этого макроса. Это может привести к ошибкам, поскольку вашей переимплементации будут переданы аргументы, которые она не может принять.
- Адаптер dbt переименовывает или удаляет метод, который ранее был доступен в объекте `{{ adapter }}` в контексте dbt-Jinja.
- dbt вносит разрушающее изменение в контракты метаданных, удаляя обязательное поле, изменяя имя или тип существующего поля или удаляя значение по умолчанию существующего поля ([README](https://github.com/dbt-labs/dbt-core/blob/37d382c8e768d1e72acd767e0afdcb1f0dc5e9c5/core/dbt/artifacts/README.md#breaking-changes)).
- dbt удаляет одно из полей из [структурированных логов](/reference/events-logging#structured-logging).

Следующие ситуации **не являются** изменениями поведения:
- Исправление ошибки, когда предыдущее поведение было дефектным, нежелательным или не задокументированным.
- dbt начинает выдавать предупреждение, которое ранее не выдавал.
- dbt обновляет язык удобочитаемых сообщений в логах событий.
- dbt вносит неразрушающее изменение в контракты метаданных, добавляя новое поле с значением по умолчанию или удаляя поле со значением по умолчанию ([README](https://github.com/dbt-labs/dbt-core/blob/37d382c8e768d1e72acd767e0afdcb1f0dc5e9c5/core/dbt/artifacts/README.md#non-breaking-changes)).

Подавляющее большинство изменений не являются изменениями поведения. Поскольку введение этих изменений не требует никаких действий со стороны пользователей, они включены в непрерывные релизы dbt Cloud и патч-релизы dbt Core.

В отличие от этого, миграции изменений поведения происходят медленно, в течение нескольких месяцев, с помощью флагов изменений поведения. Флаги слабо связаны с конкретной версией времени выполнения dbt. Устанавливая флаги, пользователи контролируют возможность включения (а затем и отключения) этих изменений.

## Флаги изменений поведения

Эти флаги _должны_ быть установлены в словаре `flags` в `dbt_project.yml`. Они настраивают поведения, тесно связанные с кодом проекта, что означает, что их следует определять в системе контроля версий и изменять через запросы на слияние или объединение, с тем же тестированием и рецензированием.

Следующий пример отображает текущие флаги и их текущие значения по умолчанию в последних версиях dbt Cloud и dbt Core. Чтобы отказаться от конкретного изменения поведения, установите значения флага в `False` в `dbt_project.yml`. Вы продолжите видеть предупреждения для устаревших поведений, от которых вы отказались, пока вы либо:

- Не решите проблему (переключив флаг на `True`)
- Не отключите предупреждения, используя флаг `warn_error_options.silence`

Вот пример доступных флагов изменений поведения с их значениями по умолчанию:

<File name='dbt_project.yml'>

```yml
flags:
  require_explicit_package_overrides_for_builtin_materializations: False
  require_model_names_without_spaces: False
  source_freshness_run_project_hooks: False
  restrict_direct_pg_catalog_access: False
  require_yaml_configuration_for_mf_time_spines: False
  require_batched_execution_for_custom_microbatch_strategy: False
```

</File>

Эта таблица описывает, в каком месяце трек "Latest" в dbt Cloud и какая версия dbt Core содержит введение изменения поведения (по умолчанию отключено) или его зрелость (включено по умолчанию).

| Флаг                                                            | dbt Cloud "Latest": Введение | dbt Cloud "Latest": Зрелость | dbt Core: Введение | dbt Core: Зрелость | 
|-----------------------------------------------------------------|------------------|---------------------|-----------------|--------------------|
| [require_explicit_package_overrides_for_builtin_materializations](#package-override-for-built-in-materialization) | 2024.04          | 2024.06             | 1.6.14, 1.7.14  | 1.8.0             |
| [require_resource_names_without_spaces](#no-spaces-in-resource-names)                           | 2024.05          | TBD*                | 1.8.0           | 1.10.0             |
| [source_freshness_run_project_hooks](#project-hooks-with-source-freshness)                              | 2024.03          | TBD*                | 1.8.0           | 1.10.0             |
| [Redshift] [restrict_direct_pg_catalog_access](/reference/global-configs/redshift-changes#the-restrict_direct_pg_catalog_access-flag)    | 2024.09          | TBD*                | dbt-redshift v1.9.0           | 1.9.0             |
| [skip_nodes_if_on_run_start_fails](#failures-in-on-run-start-hooks)                                | 2024.10          | TBD*                | 1.9.0           | TBD*              |
| [state_modified_compare_more_unrendered_values](#source-definitions-for-state)                   | 2024.10          | TBD*                | 1.9.0           | TBD*              |
| [require_yaml_configuration_for_mf_time_spines](#metricflow-time-spine-yaml)                  | 2024.10          | TBD*                | 1.9.0           | TBD*              |
| [require_batched_execution_for_custom_microbatch_strategy](#custom-microbatch-strategy)                  | 2024.11         | TBD*                | 1.9.0           | TBD*              |
| [cumulative_type_params](#cumulative-metrics-parameter)         |   2024.11         | TBD*                 | 1.9.0           | TBD*            |

Когда зрелость dbt Cloud обозначена как "TBD", это означает, что мы еще не определили точную дату, когда значения по умолчанию этих флагов изменятся. Затронутые пользователи будут видеть предупреждения об устаревании в это время, и они получат электронные письма с предварительным уведомлением перед датой зрелости. В это время, если вы видите предупреждение об устаревании, вы можете либо:
- Мигрировать ваш проект, чтобы поддерживать новое поведение, а затем установить флаг в `True`, чтобы прекратить видеть предупреждения.
- Установить флаг в `False`. Вы продолжите видеть предупреждения, и вы сохраните устаревшее поведение даже после даты зрелости (когда значение по умолчанию изменится).

### Ошибки в хуках on-run-start

Флаг по умолчанию установлен в `False`.

Установите флаг `skip_nodes_if_on_run_start_fails` в `True`, чтобы пропустить все выбранные ресурсы от выполнения, если произошла ошибка в хуке `on-run-start`. 

### Определения состояния:изменено

:::info

<StateModified features={'/snippets/_state-modified-compare.md'}/>

:::

Флаг по умолчанию установлен в `False`.

Установите `state_modified_compare_more_unrendered_values` в `True`, чтобы уменьшить количество ложных срабатываний во время проверок `state:modified` (особенно когда конфигурации различаются по целевому окружению, например, `prod` против `dev`).

Установка флага в `True` изменяет сравнение `state:modified`, используя неотрендеренные значения вместо отрендеренных. Это достигается путем сохранения `unrendered_config` во время парсинга модели и `unrendered_database` и `unrendered_schema` конфигураций во время парсинга источника.

### Переопределение пакета для встроенной материализации 

Установка флага `require_explicit_package_overrides_for_builtin_materializations` в `True` предотвращает это автоматическое переопределение. 

Мы устарели поведение, при котором установленные пакеты могли переопределять встроенные материализации без вашего явного согласия. Когда этот флаг установлен в `True`, материализация, определенная в пакете, которая совпадает с именем встроенной материализации, больше не будет включена в порядок поиска и разрешения. В отличие от макросов, материализации не используют `search_order`, определенный в конфигурации `dispatch` проекта.

Встроенные материализации: `'view'`, `'table'`, `'incremental'`, `'materialized_view'` для моделей, а также `'test'`, `'unit'`, `'snapshot'`, `'seed'` и `'clone'`.

Вы все еще можете явно переопределить встроенные материализации в пользу материализации, определенной в пакете, переопределив встроенную материализацию в вашем корневом проекте и обернув реализацию пакета.

<File name='macros/materialization_view.sql'>

```sql
{% materialization view, snowflake %}
  {{ return(my_installed_package_name.materialization_view_snowflake()) }}
{% endmaterialization %}
```

</File>

В будущем мы можем расширить конфигурацию уровня проекта [`dispatch` конфигурация](/reference/project-configs/dispatch-config), чтобы поддерживать список авторизованных пакетов для переопределения встроенной материализации.

<VersionBlock lastVersion="1.7">

Следующие флаги были введены в будущей версии dbt Core. Если вы все еще используете более старую версию, то у вас поведение по умолчанию (когда каждый флаг установлен в `False`). 

</VersionBlock>

### Без пробелов в именах ресурсов

Флаг `require_resource_names_without_spaces` требует использования имен ресурсов без пробелов. 

Имена ресурсов dbt (модели, источники и т.д.) должны содержать буквы, цифры и подчеркивания. Мы настоятельно не рекомендуем использовать другие символы, особенно пробелы. В связи с этим мы устарели поддержку пробелов в именах ресурсов. Когда флаг `require_resource_names_without_spaces` установлен в `True`, dbt выдаст исключение (вместо предупреждения об устаревании), если обнаружит пробел в имени ресурса.

<File name='models/model name with spaces.sql'>

```sql
-- Этот файл модели следует переименовать в model_name_with_underscores.sql
```

</File>

### Хуки проекта с актуальностью источника 

Установите флаг `source_freshness_run_project_hooks` в `True`, чтобы включить "хуки проекта" ([`on-run-start` / `on-run-end`](/reference/project-configs/on-run-start-on-run-end)) в выполнение команды `dbt source freshness`.

Если у вас есть конкретные хуки проекта [`on-run-start` / `on-run-end`](/reference/project-configs/on-run-start-on-run-end), которые не должны выполняться до/после команды `source freshness`, вы можете добавить условную проверку к этим хукам:

<File name='dbt_project.yml'>

```yaml
on-run-start:
  - '{{ ... if flags.WHICH != 'freshness' }}'
```
</File>


### YAML для временной спины MetricFlow
Флаг `require_yaml_configuration_for_mf_time_spines` по умолчанию установлен в `False`.

В предыдущих версиях (dbt Core 1.8 и ранее) конфигурация временной спины MetricFlow хранилась в файле `metricflow_time_spine.sql`.

Когда флаг установлен в `True`, dbt продолжит поддерживать конфигурацию SQL файла. Когда флаг установлен в `False`, dbt выдаст предупреждение об устаревании, если обнаружит конфигурацию временной спины MetricFlow в SQL файле. 

Файл YAML для MetricFlow должен содержать поле `time_spine:`. Смотрите [MetricFlow timespine](/docs/build/metricflow-time-spine) для получения дополнительных сведений. 

### Пользовательская стратегия микропакетов
Флаг `require_batched_execution_for_custom_microbatch_strategy` по умолчанию установлен в `False` и имеет значение только в том случае, если у вас уже есть пользовательский макрос микропакетов в вашем проекте. Если у вас нет пользовательского макроса микропакетов, вам не нужно устанавливать этот флаг, так как dbt будет автоматически обрабатывать микропакетирование для любой модели, использующей [стратегию микропакетов](/docs/build/incremental-microbatch#how-microbatch-compares-to-other-incremental-strategies).

Установите флаг в `True`, если у вас есть настроенный макрос микропакетов в вашем проекте. Когда флаг установлен в `True`, dbt будет выполнять пользовательскую стратегию микропакетов партиями. 

Если у вас есть пользовательский макрос микропакетов, и флаг оставлен как `False`, dbt выдаст предупреждение об устаревании.

Ранее пользователям нужно было устанавливать переменную окружения `DBT_EXPERIMENTAL_MICROBATCH` в `True`, чтобы предотвратить непреднамеренные взаимодействия с существующими пользовательскими стратегиями инкрементального обновления. Но это больше не требуется, так как установка `DBT_EXPERIMENTAL_MICROBATCH` больше не повлияет на функциональность времени выполнения.

### Кумулятивные метрики

[Кумулятивные метрики](/docs/build/cumulative#parameters) вложены под полем `cumulative_type_params` в [треке релиза dbt Cloud "Latest"](/docs/dbt-versions/cloud-release-tracks), dbt Core v1.9 и новее. В настоящее время dbt будет предупреждать пользователей, если у них кумулятивные метрики неправильно вложены. Чтобы обеспечить новый формат (что приведет к ошибке вместо предупреждения), установите `require_nested_cumulative_type_params` в `True`.

Используйте следующую метрику, настроенную с синтаксисом до v1.9, в качестве примера:

```yaml

    type: cumulative
    type_params:
      measure: order_count
      window: 7 days

```

Если вы выполните `dbt parse` с этим синтаксисом на Core v1.9 или [треке релиза dbt Cloud "Latest"](/docs/dbt-versions/cloud-release-tracks), вы получите предупреждение, например: 

```bash

15:36:22  [WARNING]: Кумулятивные поля `type_params.window` и
`type_params.grain_to_date` были перемещены и вскоре будут устаревшими. Пожалуйста,
вложите эти значения под `type_params.cumulative_type_params.window` и
`type_params.cumulative_type_params.grain_to_date`. Смотрите документацию по
изменениям поведения:
https://docs.getdbt.com/reference/global-configs/behavior-changes.

```

Если вы установите `require_nested_cumulative_type_params` в `True` и повторно выполните `dbt parse`, вы теперь получите ошибку, например:

```bash

21:39:18  Кумулятивные поля `type_params.window` и `type_params.grain_to_date` должны быть вложены под `type_params.cumulative_type_params.window` и `type_params.cumulative_type_params.grain_to_date`. Неверные метрики: orders_last_7_days. Смотрите документацию по изменениям поведения: https://docs.getdbt.com/reference/global-configs/behavior-changes.

```

После обновления метрики она будет работать как ожидалось:

```yaml

    type: cumulative
    type_params:
      measure:
        name: order_count
      cumulative_type_params:
        window: 7 days

```