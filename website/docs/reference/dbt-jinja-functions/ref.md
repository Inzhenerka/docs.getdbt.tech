---
title: "О функции ref"
sidebar_label: "ref"
id: "ref"
description: "Прочтите это руководство, чтобы понять функцию ref в Jinja в dbt."
keyword: dbt mesh, зависимости проекта, ref, перекрестные ссылки на проекты
---

```sql
select * from {{ ref("node_name") }}
```

## Определение

Эта функция:
- Возвращает [Relation](/reference/dbt-classes#relation) для [модели](/docs/build/models), [seed](/docs/build/seeds) или [snapshot](/docs/build/snapshots)
- Создает зависимости между ссылочным узлом и текущей моделью, что полезно для документации и [выбора узлов](/reference/node-selection/syntax)
- Компилируется в полное имя объекта в базе данных

Самая важная функция в dbt — это `ref()`; невозможно построить даже умеренно сложные модели без нее. `ref()` — это способ ссылаться на одну модель внутри другой. Это очень распространенное поведение, так как обычно модели строятся так, чтобы "накладываться" друг на друга. Вот как это выглядит на практике:

<File name='model_a.sql'>

```sql
select *
from public.raw_data
```

</File>

<File name='model_b.sql'>

```sql
select *
from {{ref('model_a')}}
```

</File>

`ref()` на самом деле выполняет две важные задачи. Во-первых, она интерполирует схему в ваш файл модели, чтобы вы могли изменить схему развертывания через конфигурацию. Во-вторых, она использует эти ссылки между моделями для автоматического построения графа зависимостей. Это позволит dbt развертывать модели в правильном порядке при использовании `dbt run`.

Функция `{{ ref }}` возвращает объект `Relation`, который имеет те же атрибуты `table`, `schema` и `name`, что и [переменная \{\{ this \}\}](/reference/dbt-jinja-functions/this).
  - Примечание &mdash; До версии dbt v1.6, dbt Cloud IDE возвращает `request` как результат `{{ ref.identifier }}`.

## Продвинутое использование ref

### Версионированный ref

Функция `ref` поддерживает необязательный аргумент - `version` (или `v`).
Когда аргумент версии предоставляется функции `ref`, dbt возвращает объект `Relation`, соответствующий указанной версии ссылочной модели.

Эта функциональность полезна при ссылке на версионированные модели, которые вносят критические изменения, создавая новые версии, но гарантирует отсутствие критических изменений в существующих версиях модели.

Если аргумент `version` не предоставлен для `ref` версионированной модели, используется последняя версия. Это имеет преимущество автоматического включения последних изменений ссылочной модели, но существует риск включения критических изменений.

#### Пример:
<File name='models/<schema>.yml'>

```yml

models:
  - name: model_name
    latest_version: 2
    versions:
      - v: 2
      - v: 1
```

</File>

```sql
 -- возвращает объект `Relation`, соответствующий версии 1 model_name
select * from {{ ref('model_name', version=1) }}
```

```sql
 -- возвращает объект `Relation`, соответствующий версии 2 (последней версии) model_name
select * from {{ ref('model_name') }}
```

### Ссылка на модели из конкретных проектов

Вы также можете ссылаться на модели из разных проектов, используя двухаргументный вариант функции `ref`. Указав как пространство имен (которое может быть проектом или пакетом), так и имя модели, вы обеспечиваете ясность и избегаете двусмысленности в `ref`. Это также полезно при работе с моделями из различных проектов или пакетов.

При использовании двух аргументов с проектами (не пакетами) вам также нужно установить [зависимости между проектами](/docs/collaborate/govern/project-dependencies).

Следующий синтаксис демонстрирует, как ссылаться на модель из конкретного проекта или пакета:

```sql
select * from {{ ref('project_or_package', 'model_name') }}
```

Мы рекомендуем использовать двухаргументный `ref` всякий раз, когда вы ссылаетесь на модель, определенную в другом пакете или проекте. Хотя это не требуется во всех случаях, это более явно для вас, для dbt и будущих читателей вашего кода.

Мы особенно рекомендуем использовать двухаргументный `ref`, чтобы избежать двусмысленности в случаях, когда имя модели дублируется в нескольких проектах или установленных пакетах. Если вы используете одноаргументный `ref` (только `model_name`), dbt будет искать модель с таким именем в том же пространстве имен (пакет или проект); если он не найдет ни одной, он выдаст ошибку.

**Примечание:** `project_or_package` должно совпадать с `name` проекта/пакета, как определено в его `dbt_project.yml`. Это может отличаться от имени репозитория. Оно никогда не включает имя организации репозитория. Например, если вы используете пакет [`fivetran/stripe`](https://hub.getdbt.com/fivetran/stripe/latest/), имя пакета — `stripe`, а не `fivetran/stripe`.

### Принудительные зависимости

В обычном использовании dbt знает правильный порядок выполнения всех моделей на основе использования функции `ref`. Однако бывают случаи, когда dbt не знает, когда модель должна быть выполнена. Примером этого является случай, когда модель ссылается только на макрос. В этом случае dbt считает, что модель может быть выполнена первой, так как на этапе компиляции явные ссылки не создаются. Чтобы решить эту проблему, вы можете использовать SQL-комментарий вместе с функцией `ref` — dbt поймет зависимость, и скомпилированный запрос все равно будет действительным:

```sql
 -- depends_on: {{ ref('upstream_parent_model') }}

 {{ your_macro('variable') }}
```

dbt увидит `ref` и построит эту модель после указанной ссылки.

Другой пример — когда ссылка появляется внутри условного блока [`is_incremental()`](/docs/build/incremental-models#understand-the-is_incremental-macro). Это происходит потому, что макрос `is_incremental()` всегда возвращает `false` на этапе разбора, поэтому любые ссылки внутри него не могут быть выведены. Чтобы справиться с этим, вы можете использовать SQL-комментарий вне условного блока `is_incremental()`:

```sql
-- depends_on: {{ source('raw', 'orders') }}

{% if is_incremental() %}
select * from {{ source('raw', 'orders') }}
{% endif %}
```