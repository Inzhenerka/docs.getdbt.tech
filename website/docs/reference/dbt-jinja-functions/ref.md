---
title: "О функции ref"
sidebar_label: "ref"
id: "ref"
description: "Прочитайте это руководство, чтобы понять функцию Jinja ref в dbt."
keyword: dbt mesh, зависимости проекта, ref, кросс-проектный ref
---

```sql
select * from {{ ref("node_name") }}
```

## Определение

Эта функция:
- Возвращает [Relation](/reference/dbt-classes#relation) для [модели](/docs/build/models), [seed](/docs/build/seeds) или [snapshot](/docs/build/snapshots)
- Создает зависимости между указанным узлом и текущей моделью, что полезно для документации и [выбора узлов](/reference/node-selection/syntax)
- Компилируется в полное имя объекта в базе данных

Самая важная функция в dbt — это `ref()`; невозможно построить даже умеренно сложные модели без нее. `ref()` — это способ ссылаться на одну модель из другой. Это очень распространенное поведение, так как обычно модели строятся так, чтобы "наслоиться" друг на друга. Вот как это выглядит на практике:

<File name='model_a.sql'>

```sql
select *
from public.raw_data
```

</File>

<File name='model_b.sql'>

```sql
select *
from {{ref('model_a')}}
```

</File>

`ref()` на самом деле выполняет две важные задачи. Во-первых, она интерполирует схему в ваш файл модели, чтобы вы могли изменять схему развертывания через конфигурацию. Во-вторых, она использует эти ссылки между моделями для автоматического построения графа зависимостей. Это позволит dbt развертывать модели в правильном порядке при использовании `dbt run`.

Функция `{{ ref }}` возвращает объект `Relation`, который имеет такие же атрибуты `table`, `schema` и `name`, как и [переменная \{\{ this \}\} ](/reference/dbt-jinja-functions/this).
  - Примечание — До версии dbt v1.6, dbt Cloud IDE возвращает `request` в качестве результата `{{ ref.identifier }}`.

## Расширенное использование ref

### Версионированный ref

Функция `ref` поддерживает необязательный аргумент ключевого слова — `version` (или `v`).
Когда аргумент версии передается функции `ref`, dbt возвращает объект `Relation`, соответствующий указанной версии ссылочной модели.

Эта функциональность полезна при ссылке на версионированные модели, которые вносят разрушающие изменения, создавая новые версии, но гарантирует отсутствие разрушающих изменений для существующих версий модели.

Если аргумент `version` не указан для `ref` версионированной модели, возвращается последняя версия. Это имеет преимущество автоматического включения последних изменений ссылочной модели, но существует риск включения разрушающих изменений.

#### Пример:
<File name='models/<schema>.yml'>

```yml

models:
  - name: model_name
    latest_version: 2
    versions:
      - v: 2
      - v: 1
```

</File>

```sql
 -- возвращает объект `Relation`, соответствующий версии 1 модели model_name
select * from {{ ref('model_name', version=1) }}
```

```sql
 -- возвращает объект `Relation`, соответствующий версии 2 (последней версии) модели model_name
select * from {{ ref('model_name') }}
```

### Ссылки на модели конкретного проекта

Вы также можете ссылаться на модели из разных проектов, используя вариант функции `ref` с двумя аргументами. Указывая как пространство имен (которое может быть проектом или пакетом), так и имя модели, вы обеспечиваете ясность и избегаете двусмысленности в `ref`. Это также полезно при работе с моделями из различных проектов или пакетов.

При использовании двух аргументов с проектами (а не пакетами) вам также необходимо установить [кросс-проектные зависимости](/docs/collaborate/govern/project-dependencies).

Следующий синтаксис демонстрирует, как ссылаться на модель из конкретного проекта или пакета:

```sql
select * from {{ ref('project_or_package', 'model_name') }}
```

Мы рекомендуем использовать `ref` с двумя аргументами всякий раз, когда вы ссылаетесь на модель, определенную в другом пакете или проекте. Хотя это не обязательно во всех случаях, это более явно для вас, для dbt и для будущих читателей вашего кода.

Мы особенно рекомендуем использовать `ref` с двумя аргументами, чтобы избежать двусмысленности в случаях, когда имя модели дублируется в нескольких проектах или установленных пакетах. Если вы используете `ref` с одним аргументом (только `model_name`), dbt будет искать модель с таким именем в том же пространстве имен (пакете или проекте); если он не найдет таковой, будет выдана ошибка.

**Примечание:** `project_or_package` должен соответствовать `name` проекта/пакета, как определено в его `dbt_project.yml`. Это может отличаться от названия репозитория. Он никогда не включает название организации репозитория. Например, если вы используете пакет [`fivetran/stripe`](https://hub.getdbt.com/fivetran/stripe/latest/), имя пакета — `stripe`, а не `fivetran/stripe`.

### Принуждение зависимостей

В обычном использовании dbt знает правильный порядок выполнения всех моделей на основе использования функции `ref`. Однако есть случаи, когда dbt не знает, когда модель должна быть выполнена. Примером этого является ситуация, когда модель ссылается только на макрос. В этом случае dbt считает, что модель может быть выполнена первой, поскольку в момент компиляции не сделаны явные ссылки. Чтобы решить эту проблему, вы можете использовать SQL-комментарий вместе с функцией `ref` — dbt поймет зависимость, и скомпилированный запрос останется действительным:

```sql
 -- depends_on: {{ ref('upstream_parent_model') }}

 {{ your_macro('variable') }}
```

dbt увидит `ref` и построит эту модель после указанной ссылки.

Другим примером является ситуация, когда ссылка появляется внутри условного блока [`is_incremental()`](/docs/build/incremental-models#understand-the-is_incremental-macro). Это связано с тем, что макрос `is_incremental()` всегда возвращает `false` во время разбора, поэтому любые ссылки внутри него не могут быть выведены. Чтобы справиться с этим, вы можете использовать SQL-комментарий вне условного блока `is_incremental()`:

```sql
-- depends_on: {{ source('raw', 'orders') }}

{% if is_incremental() %}
select * from {{ source('raw', 'orders') }}
{% endif %}
```