---
resource_types: [models]
description: "Когда конфигурация контракта применяется, dbt будет гарантировать, что возвращаемый набор данных вашего модели точно соответствует атрибутам, которые вы определили в yaml, таким как имя и тип данных, а также любым дополнительным ограничениям, поддерживаемым платформой данных."
datatype: "{<dictionary>}"
default_value: {enforced: false}
id: "contract"
---

Поддерживается в dbt версии 1.5 и выше.

Когда конфигурация `contract` применяется, dbt будет гарантировать, что возвращаемый набор данных вашей модели точно соответствует атрибутам, которые вы определили в yaml:
- `name` и `data_type` для каждого столбца
- Дополнительные [`constraints`](/reference/resource-properties/constraints), поддерживаемые для этой материализации и платформы данных

Это необходимо для того, чтобы люди, запрашивающие вашу модель в дальнейшем — как внутри, так и вне dbt — имели предсказуемый и согласованный набор столбцов для использования в своих анализах. Даже незначительное изменение типа данных, например, с `boolean` (`true`/`false`) на `integer` (`0`/`1`), может привести к неожиданным сбоям в запросах.

## Поддержка

В настоящее время контракты моделей поддерживаются для:
- SQL моделей (пока не для Python)
- Моделей, материализованных как `table`, `view` и `incremental` (с `on_schema_change: append_new_columns` или `on_schema_change: fail`)
- Наиболее популярных платформ данных — хотя поддержка и применение различных [типов ограничений](/reference/resource-properties/constraints) варьируются в зависимости от платформы

## Псевдонимы типов данных

dbt использует встроенные псевдонимы типов для `data_type`, определенного в вашем YAML. Например, вы можете указать `string` в вашем контракте, и на Postgres/Redshift dbt преобразует его в `text`. Если dbt не распознает имя `data_type` среди своих известных псевдонимов, оно будет передано без изменений. Это включено по умолчанию, но вы можете отключить эту функцию, установив `alias_types` в `false`.

Пример для отключения:

<File name='FOLDER_NAME/FILE_NAME.yml'>

```yml

models:
  - name: my_model
    config:
      contract:
        enforced: true
        alias_types: false  # по умолчанию true

```

</File>

## Размер, точность и масштаб

Когда dbt сравнивает типы данных, он не будет сравнивать детализированные параметры, такие как размер, точность или масштаб. Мы считаем, что вам не стоит беспокоиться о разнице между `varchar(256)` и `varchar(257)`, поскольку это не влияет на опыт пользователей, запрашивающих данные. Вы можете добиться более точного утверждения, [написав или используя пользовательский тест](/best-practices/writing-custom-generic-tests).

Обратите внимание, что вам нужно указать размер varchar или масштаб чисел, в противном случае dbt будет полагаться на значения по умолчанию. Например, если тип `numeric` по умолчанию имеет точность 38 и масштаб 0, то числовой столбец будет хранить 0 цифр справа от десятичной точки (он хранит только целые числа), что может привести к сбою применения контракта. Чтобы избежать этого неявного приведения типов, укажите ваш `data_type` с ненулевым масштабом, например, `numeric(38, 6)`. dbt Core 1.7 и выше выдает предупреждение, если вы не укажете точность и масштаб при указании числового типа данных.

### Пример

<File name='models/dim_customers.yml'>

```yml
models:
  - name: dim_customers
    config:
      materialized: table
      contract:
        enforced: true
    columns:
      - name: customer_id
        data_type: int
        constraints:
          - type: not_null
      - name: customer_name
        data_type: string
      - name: non_integer
        data_type: numeric(38,3)
```

</File>

Предположим, ваша модель определена как:

<File name='models/dim_customers.sql'>

```sql
select
  'abc123' as customer_id,
  'My Best Customer' as customer_name
```

</File>

Когда вы выполните `dbt run` для вашей модели, _до_ того, как dbt материализует ее как таблицу в базе данных, вы увидите эту ошибку:
```txt
20:53:45  Ошибка компиляции в модели dim_customers (models/dim_customers.sql)
20:53:45    У этой модели есть обязательный контракт, который не выполнен.
20:53:45    Пожалуйста, убедитесь, что имя, тип данных и количество столбцов в вашем контракте соответствуют столбцам в определении вашей модели.
20:53:45
20:53:45    | column_name | definition_type | contract_type | mismatch_reason    |
20:53:45    | ----------- | --------------- | ------------- | ------------------ |
20:53:45    | customer_id | TEXT            | INT           | несоответствие типа данных |
20:53:45
20:53:45
20:53:45    > в макросе assert_columns_equivalent (macros/materializations/models/table/columns_spec_ddl.sql)
```

### Инкрементальные модели и `on_schema_change`

Почему требуется, чтобы инкрементальные модели также устанавливали [`on_schema_change`](/docs/build/incremental-models#what-if-the-columns-of-my-incremental-model-change), и почему на `append_new_columns`?

Представьте:
- Вы добавляете новый столбец как в SQL, так и в спецификацию YAML
- Вы не устанавливаете `on_schema_change`, или устанавливаете `on_schema_change: 'ignore'`
- dbt фактически не добавляет этот новый столбец в существующую таблицу — и операция upsert/merge все равно проходит успешно, потому что она выполняется на основе уже существующих "целевых" столбцов (это давно установленное поведение)
- В результате возникает дельта между контрактом, определенным в yaml, и фактической таблицей в базе данных — что означает, что контракт теперь неверен!

Почему `append_new_columns`, а не `sync_all_columns`? Потому что удаление существующих столбцов является нарушением контракта для моделей с контрактом!

## Связанная документация
- [Что такое контракт модели?](/docs/collaborate/govern/model-contracts)
- [Определение `columns`](/reference/resource-properties/columns)
- [Определение `constraints`](/reference/resource-properties/constraints)