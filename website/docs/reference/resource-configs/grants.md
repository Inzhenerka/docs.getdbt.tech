---
resource_types: [models,seeds,snapshots]
datatype: "{<dictionary>}"
default_value: {}
id: "grants"
---

Вы можете управлять доступом к наборам данных, которые вы создаете с помощью dbt, используя права доступа (grants). Чтобы реализовать эти разрешения, определите права доступа в качестве конфигураций ресурсов для каждой модели, семени или снимка. Определите стандартные права доступа, которые применяются ко всему проекту, в вашем `dbt_project.yml`, и определите специфические для модели права доступа в SQL или YAML файле каждой модели.

Конфигурации ресурсов прав доступа позволяют вам применять разрешения во время сборки к определенному набору получателей и модели, семени или снимку. Когда ваша модель, семя или снимок завершает сборку, dbt гарантирует, что права доступа на его представление или таблицу точно соответствуют правам доступа, которые вы настроили.

dbt стремится использовать наиболее эффективный подход при обновлении прав доступа, который варьируется в зависимости от используемого адаптера и того, заменяет ли dbt или обновляет существующий объект. Вы всегда можете проверить журналы отладки для полного набора операторов grant и revoke, которые выполняет dbt.

dbt рекомендует использовать права доступа в качестве конфигураций ресурсов, когда это возможно. В версиях до Core v1.2 вы были ограничены использованием хуков для прав доступа. Иногда вам все же может понадобиться вручную написать операторы прав доступа и выполнить их с помощью хуков. Например, хуки могут быть уместны, если вы хотите:

* Применить права доступа более сложным или индивидуальным образом, чем это может предоставить встроенная функция прав доступа.
* Применить права доступа к другим объектам базы данных, кроме представлений и таблиц.
* Воспользоваться более продвинутыми возможностями разрешений, предлагаемыми вашей платформой данных, для которых dbt (пока что!) не предлагает встроенной поддержки с использованием конфигурации ресурсов.
* Создать более детализированный доступ на уровне строк и столбцов, использовать политики маскирования или применять будущие права доступа.

Для получения дополнительной информации о хуках смотрите [Hooks & operations](/docs/build/hooks-operations).

## Определение

Вы можете использовать поле `grants` для установки разрешений или прав доступа для ресурса. Когда вы `run` модель, `seed` данные или `snapshot` набор данных, dbt выполнит операторы `grant` и/или `revoke`, чтобы гарантировать, что разрешения на объект базы данных соответствуют правам доступа, которые вы настроили для ресурса.

Как и все конфигурации, `grants` будут включены в метаданные проекта dbt, включая [артефакт манифеста](/reference/artifacts/manifest-json).

### Общий синтаксис

Права доступа имеют два ключевых компонента:

* **Привилегия:** Право выполнять конкретное действие или набор действий над объектом в базе данных, например, выбирать данные из таблицы.
* **Получатели:** Один или несколько получателей предоставленных привилегий. Некоторые платформы также называют их "принципалами". Например, получателем может быть пользователь, группа пользователей, роль, занимаемая одним или несколькими пользователями (Snowflake), или сервисная учетная запись (BigQuery/GCP).

## Настройка прав доступа

Вы можете настроить `grants` в `dbt_project.yml`, чтобы применить права доступа ко многим ресурсам сразу — ко всем моделям в вашем проекте, пакету или подпапке — а также вы можете настраивать `grants` по одному для конкретных ресурсов в блоках YAML `config:` или прямо в их `.sql` файлах.

<Tabs
  defaultValue="models"
  values={[
    { label: 'Models', value: 'models', },
    { label: 'Seeds', value: 'seeds', },
    { label: 'Snapshots', value: 'snapshots', },
  ]
}>

<TabItem value="models">

<File name='models/schema.yml'>

```yml
models:
  - name: specific_model
    config:
      grants:
        select: ['reporter', 'bi']
```

</File>

Конфигурацию `grants` также можно определить:

- в блоке конфигурации `models` в `dbt_project.yml`
- в макросе `config()` Jinja в SQL файле модели

Смотрите [configs and properties](/reference/configs-and-properties) для получения подробной информации.

</TabItem>

<TabItem value="seeds">

<File name='seeds/schema.yml'>

```yml
seeds:
  - name: seed_name
    config:
      grants:
        select: ['reporter', 'bi']
```

</File>

Конфигурацию `grants` также можно определить в блоке конфигурации `seeds` в `dbt_project.yml`. Смотрите [configs and properties](/reference/configs-and-properties) для получения подробной информации.

</TabItem>

<TabItem value="snapshots">

<File name='snapshots/schema.yml'>

```yml
snapshots:
  - name: snapshot_name
    config:  
      grants:
        select: ['reporter', 'bi']
```

</File>

Конфигурацию `grants` также можно определить:

- в блоке конфигурации `snapshots` в `dbt_project.yml`
- в макросе `config()` Jinja в SQL блоке снимка

Смотрите [configs and properties](/reference/configs-and-properties) для получения подробной информации.

</TabItem>
</Tabs>

### Наследование конфигурации прав доступа

Когда вы устанавливаете `grants` для одной и той же модели в нескольких местах, таких как `dbt_project.yml` и более специфичном `.sql` или `.yml` файле, поведение по умолчанию dbt заменяет менее специфический набор получателей более специфическим набором получателей. Это поведение "слияния и замены" обновляет каждую привилегию, когда dbt анализирует ваш проект.

Например:

<File name='dbt_project.yml'>

```yml
models:
  +grants:  # В этом случае + не является необязательным, вы должны включить его, чтобы ваш проект был проанализирован.
    select: ['user_a', 'user_b']
```

</File>

<File name='models/specific_model.sql'>

```sql
{{ config(grants = {'select': ['user_c']}) }}
```

</File>

В результате этой конфигурации `specific_model` будет настроен на предоставление привилегии `select` только `user_c`. После выполнения `specific_model` это будет единственная предоставленная привилегия, которую вы увидите в базе данных, и единственный оператор `grant`, который вы найдете в журналах dbt.

Предположим, мы хотели бы _добавить_ `user_c` к существующему списку получателей, получающих привилегию `select` на `specific_model`, а не _заменить_ этот список полностью. Чтобы достичь этого, мы можем использовать символ `+` ("добавление"), предшествующий имени привилегии:

<File name='models/specific_model.sql'>

```sql
{{ config(grants = {'+select': ['user_c']}) }}
```

</File>

Теперь модель будет предоставлять доступ к выборке `user_a`, `user_b` И `user_c`!

**Примечания:**
- Это будет действовать только для привилегий, которые включают префикс `+`. Каждая привилегия контролирует это поведение отдельно. Если бы мы предоставляли другие привилегии, помимо `select`, и эти имена привилегий не имели префикса `+`, они продолжали бы "заменять", а не "добавлять" новых получателей.
- Это использование `+`, контролирующее поведение слияния замены и добавления, отличается от использования `+` в `dbt_project.yml` (показано в примере выше) для определения конфигураций со значениями словаря. Для получения дополнительной информации смотрите [плюс-префикс](https://docs.getdbt.com/reference/resource-configs/plus-prefix).
- `grants` — это первая конфигурация, которая поддерживает префикс `+` для управления поведением слияния конфигураций. В настоящее время это единственная такая конфигурация. Если это окажется полезным, мы можем расширить эту возможность на новые и существующие конфигурации в будущем.

## Общие примеры

Вы можете предоставить каждую привилегию одному получателю или набору нескольких получателей. В этом примере мы предоставляем `select` на этой модели только `bi_user`, чтобы ее можно было запрашивать в нашем инструменте бизнес-аналитики (BI).

<File name='models/table_model.sql'>

```sql
{{ config(materialized = 'table', grants = {
    'select': 'bi_user'
}) }}
```

</File>

Когда dbt выполняет эту модель в первый раз, он создаст таблицу, а затем выполнит код, подобный:
```sql
grant select on schema_name.table_model to bi_user;
```

В этом случае мы создаем инкрементальную модель и предоставляем привилегию `select` двум получателям: `bi_user` и `reporter`.

<File name='models/incremental_model.sql'>

```sql
{{ config(materialized = 'incremental', grants = {
    'select': ['bi_user', 'reporter']
}) }}
```

</File>

Когда dbt выполняет эту модель в первый раз, он создаст таблицу, а затем выполнит код, подобный:
```sql
grant select on schema_name.incremental_model to bi_user, reporter;
```

В последующих запусках dbt будет использовать специфичный для базы данных SQL, чтобы показать уже существующие права доступа на `incremental_model`, а затем определить, нужны ли какие-либо операторы `revoke` или `grant`.

## Требования и примечания, специфичные для базы данных

Хотя мы стараемся стандартизировать термины, которые мы используем для описания различных функций, вы всегда найдете нюансы в разных базах данных. Этот раздел описывает некоторые из этих требований и примечаний, специфичных для базы данных.

В наших примерах выше и ниже вы найдете упоминания о привилегии с именем `select` и получателе с именем `another_user`. Многие базы данных используют эти или подобные термины. Обратите внимание, что ваша база данных может требовать другого синтаксиса для привилегий и получателей; вы должны настроить `grants` в dbt с соответствующими именами для обоих.

<WHCode>

<div warehouse="BigQuery">

В BigQuery "привилегии" называются "ролями", и они принимают форму `roles/service.roleName`. Например, вместо того чтобы предоставлять `select` на модели, вы бы предоставили `roles/bigquery.dataViewer`.

Получатели могут быть пользователями, группами, сервисными учетными записями, доменами — и каждый из них должен быть четко обозначен с помощью префикса. Например, чтобы предоставить доступ к модели `someone@yourcompany.com`, вам нужно указать их как `user:someone@yourcompany.com`.

Мы рекомендуем вам ознакомиться с документацией Google для получения дополнительного контекста:
- [Понимание ролей GCP](https://cloud.google.com/iam/docs/understanding-roles)
- [Как форматировать получателей](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-control-language#user_list)

<Snippet path="grants-vs-access-to" />

### Примеры BigQuery

Предоставление разрешения с использованием SQL и BigQuery:

```sql
{{ config(grants = {'roles/bigquery.dataViewer': ['user:someone@yourcompany.com']}) }}
```

Предоставление разрешения в схеме модели с использованием BigQuery:

<File name='models/schema.yml'>

```yml
models:
  - name: specific_model
    config:
      grants:
        roles/bigquery.dataViewer: ['user:someone@yourcompany.com']
```

</File>

</div>

<div warehouse="Databricks">

- OSS Apache Spark / Delta Lake не поддерживают `grants`.
- Databricks автоматически включает `grants` на SQL конечных точках. Для интерактивных кластеров администраторы должны включить функциональность прав доступа, следуя этим двум шагам настройки в документации Databricks:
  - [Включить контроль доступа к таблицам для вашего рабочего пространства](https://docs.databricks.com/administration-guide/access-control/table-acl.html)
  - [Включить контроль доступа к таблицам для кластера](https://docs.databricks.com/security/access-control/table-acls/table-acl.html)
- Чтобы предоставить `READ_METADATA` или `USAGE`, используйте [post-hooks](https://docs.getdbt.com/reference/resource-configs/pre-hook-post-hook)

</div>

<div warehouse="Redshift">

* Предоставление и отзыв прав полностью поддерживается только для пользователей Redshift (не для [групп](https://docs.aws.amazon.com/redshift/latest/dg/r_Groups.html) или [ролей](https://docs.aws.amazon.com/redshift/latest/dg/r_roles-managing.html)).

</div>

<div warehouse="Snowflake">

* dbt учитывает [`copy_grants` конфигурацию](/reference/resource-configs/snowflake-configs#copying-grants) при расчете, какие права доступа необходимо добавить или удалить.
* Предоставление и отзыв прав полностью поддерживается только для ролей Snowflake (не для [ролей базы данных](https://docs.snowflake.com/user-guide/security-access-control-overview#types-of-roles)).

</div>

</WHCode>