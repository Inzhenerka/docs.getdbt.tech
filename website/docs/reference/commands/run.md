---
title: "О команде dbt run"
sidebar_label: "run"
description: "Прочтите это руководство, чтобы узнать, как команда dbt run может использоваться для выполнения скомпилированных SQL-файлов моделей в целевой базе данных."
id: "run"
---

## Обзор

`dbt run` выполняет скомпилированные SQL-файлы моделей в текущей целевой базе данных. dbt подключается к целевой базе данных и выполняет соответствующий SQL, необходимый для материализации всех моделей данных, используя указанные стратегии <Term id="materialization" />. Модели выполняются в порядке, определенном графом зависимостей, сгенерированным во время компиляции. Интеллектуальное многопоточность используется для минимизации времени выполнения без нарушения зависимостей.

Развертывание новых моделей часто включает уничтожение предыдущих версий этих моделей. В таких случаях `dbt run` минимизирует время, в течение которого модель недоступна, сначала создавая каждую модель с временным именем, затем удаляя существующую модель и переименовывая модель в ее правильное имя. Удаление и переименование происходят в рамках одной транзакции базы данных для адаптеров баз данных, которые поддерживают транзакции.

## Обновление инкрементальных моделей

Если вы укажете флаг `--full-refresh` для `dbt run`, dbt будет обрабатывать инкрементальные модели как модели <Term id="table" />. Это полезно, когда:

1. Схема инкрементальной модели изменяется, и вам нужно ее воссоздать.
2. Вы хотите перепроцессировать всю инкрементальную модель из-за новой логики в коде модели.

<File name='bash'>

```shell
dbt run --full-refresh
```

</File>

Вы также можете указать флаг его коротким именем: `dbt run -f`.

В контексте компиляции dbt этот флаг будет доступен как [flags.FULL_REFRESH](/reference/dbt-jinja-functions/flags). Кроме того, макрос `is_incremental()` вернет `false` для *всех* моделей в ответ, когда указан флаг `--full-refresh`.

<File name='models/example.sql'>

```sql
select * from all_events

-- если таблица уже существует и `--full-refresh` не установлен,
-- то добавляются только новые записи. в противном случае выбираются
-- все записи.
{% if is_incremental() %}
   where collector_tstamp > (
     select coalesce(max(max_tstamp), '0001-01-01') from {{ this }}
   )
{% endif %}
```

</File>

## Запуск конкретных моделей

dbt также позволяет выбрать, какие конкретные модели вы хотите материализовать. Это может быть полезно в особых сценариях, когда вы предпочитаете запускать другой набор моделей в различные интервалы. Это также может быть полезно, когда вы хотите ограничить материализуемые таблицы, пока вы разрабатываете и тестируете новые модели.

Для получения дополнительной информации см. [Документацию по синтаксису выбора моделей](/reference/node-selection/syntax).

Для получения дополнительной информации о запуске родительских или дочерних моделей см. [Документацию по операторам графа](/reference/node-selection/graph-operators).

## Обработка предупреждений как ошибок

См. [глобальные конфигурации](/reference/global-configs/warnings)

## Быстрое завершение при ошибках

См. [глобальные конфигурации](/reference/global-configs/failing-fast)

## Включение или отключение цветных логов

См. [глобальные конфигурации](/reference/global-configs/print-output#print-color)

<VersionBlock firstVersion="1.8">

## Флаг `--empty`

Команда `run` поддерживает флаг `--empty` для построения сухих запусков только со схемой. Флаг `--empty` ограничивает ссылки и источники до нуля строк. dbt все равно выполнит SQL модели в целевом хранилище данных, но избежит дорогостоящих чтений входных данных. Это проверяет зависимости и гарантирует, что ваши модели будут правильно построены.

</VersionBlock>

## Статусы выполнения

При вызове [api list_runs](/dbt-cloud/api-v2#/operations/List%20Runs) вы получите код статуса для каждого выполнения. Доступные коды статуса выполнения следующие:

- Запуск = 1
- Выполнение = 3
- Успех = 10
- Ошибка = 20
- Отменено = 30
- Пропущено = 40