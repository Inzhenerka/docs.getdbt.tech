---
title: "О команде dbt run"
sidebar_label: "run"
description: "Прочитайте это руководство о том, как команда dbt run может быть использована для выполнения скомпилированных SQL файлов моделей против целевой базы данных."
id: "run"
---

## Обзор

`dbt run` выполняет скомпилированные SQL файлы моделей против текущей `target` базы данных. dbt подключается к целевой базе данных и выполняет соответствующий SQL, необходимый для материализации всех моделей данных с использованием указанных <Term id="materialization" /> стратегий. Модели выполняются в порядке, определенном графом зависимостей, сгенерированным во время компиляции. Используется интеллектуальная многопоточность для минимизации времени выполнения без нарушения зависимостей.

Частое развертывание новых моделей включает в себя уничтожение предыдущих версий этих моделей. В таких случаях `dbt run` минимизирует время, в течение которого модель недоступна, сначала создавая каждую модель с временным именем, затем удаляя существующую модель, а затем переименовывая модель в ее правильное имя. Удаление и переименование происходят в рамках одной транзакции базы данных для адаптеров баз данных, которые поддерживают транзакции.

## Обновление инкрементальных моделей

Если вы укажете флаг `--full-refresh` для `dbt run`, dbt будет рассматривать инкрементальные модели как <Term id="table" /> модели. Это полезно, когда

1. Схема инкрементальной модели изменяется, и вам нужно ее воссоздать.
2. Вы хотите повторно обработать всю инкрементальную модель из-за новой логики в коде модели.

<File name='bash'>

```shell
dbt run --full-refresh
```

</File>

Вы также можете указать флаг с помощью его короткого имени: `dbt run -f`.

В контексте компиляции dbt этот флаг будет доступен как [flags.FULL_REFRESH](/reference/dbt-jinja-functions/flags). Кроме того, макрос `is_incremental()` вернет `false` для *всех* моделей в ответ на указание флага `--full-refresh`.

<File name='models/example.sql'>

```sql
select * from all_events

-- если таблица уже существует и `--full-refresh` не
-- установлен, то добавляются только новые записи. в противном
-- случае выбираются все записи.
{% if is_incremental() %}
   where collector_tstamp > (
     select coalesce(max(max_tstamp), '0001-01-01') from {{ this }}
   )
{% endif %}
```

</File>

## Запуск конкретных моделей

dbt также позволяет вам выбрать, какие конкретные модели вы хотите материализовать. Это может быть полезно в особых сценариях, когда вы предпочитаете запускать разные наборы моделей в различные интервалы времени. Это также может быть полезно, когда вы хотите ограничить количество материализованных таблиц, пока разрабатываете и тестируете новые модели.

Для получения дополнительной информации смотрите [Документацию по синтаксису выбора моделей](/reference/node-selection/syntax).

Для получения дополнительной информации о запуске родительских или дочерних моделей конкретных моделей смотрите [Документацию по графовым операторам](/reference/node-selection/graph-operators).

## Рассматривать предупреждения как ошибки

Смотрите [глобальные настройки](/reference/global-configs/warnings)

## Быстрое завершение при ошибках

Смотрите [глобальные настройки](/reference/global-configs/failing-fast)

## Включение или отключение цветных логов

Смотрите [глобальные настройки](/reference/global-configs/print-output#print-color)

<VersionBlock firstVersion="1.8">

## Флаг `--empty`

Команда `run` поддерживает флаг `--empty` для создания схемных только "сухих" запусков. Флаг `--empty` ограничивает количество ссылок и источников до нуля строк. dbt все равно выполнит SQL модели против целевого хранилища данных, но избегает дорогостоящих чтений входных данных. Это проверяет зависимости и гарантирует, что ваши модели будут правильно построены.

</VersionBlock>

## Коды состояния

При вызове [api list_runs](/dbt-cloud/api-v2#/operations/List%20Runs) вы получите код состояния для каждого возвращенного запуска. Доступные коды состояния запуска следующие:

- Starting = 1
- Running = 3
- Success = 10
- Error = 20
- Canceled = 30
- Skipped = 40