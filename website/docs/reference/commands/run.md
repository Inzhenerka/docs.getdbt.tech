---
title: "О команде dbt run"
sidebar_label: "run"
description: "Команда dbt run выполняет скомпилированные SQL-модели dbt в целевой базе данных."
id: "run"
---

## Обзор

Команда `dbt run` применяется **только к моделям**. Она не запускает тесты, снапшоты, сиды или другие типы ресурсов. Для запуска этих операций используйте соответствующие команды dbt, описанные в разделе [dbt commands](/reference/dbt-commands), — например, `dbt test`, `dbt snapshot` или `dbt seed`.  
В качестве альтернативы можно использовать `dbt build` с [селектором типа ресурса](/reference/node-selection/methods#resource_type).

Команду `dbt run` имеет смысл использовать, когда вам нужно построить или перестроить модели в вашем проекте.

### Как работает `dbt run`?

- `dbt run` выполняет скомпилированные SQL-файлы моделей в текущей базе данных `target`.
- dbt подключается к целевой базе данных и выполняет соответствующий SQL, необходимый для материализации всех моделей данных с использованием указанных стратегий <Term id="materialization" />.
- Модели выполняются в порядке, определённом графом зависимостей, сформированным на этапе компиляции. Для минимизации времени выполнения используется интеллектуальная многопоточность без нарушения зависимостей.
- При деплое новых моделей часто требуется удалить предыдущие версии этих моделей. В таких случаях `dbt run` минимизирует простой, сначала создавая каждую модель с временным именем, а затем выполняя удаление и переименование в рамках одной транзакции (для адаптеров, поддерживающих транзакции).

## Обновление инкрементальных моделей

Если вы укажете флаг `--full-refresh` для `dbt run`, dbt будет обрабатывать инкрементальные модели как модели <Term id="table" />. Это полезно, когда:

1. Схема инкрементальной модели изменяется, и вам нужно ее воссоздать.
2. Вы хотите перепроцессировать всю инкрементальную модель из-за новой логики в коде модели.

<File name='bash'>

```shell
dbt run --full-refresh
```

</File>

Вы также можете указать флаг его коротким именем: `dbt run -f`.

В контексте компиляции dbt этот флаг будет доступен как [flags.FULL_REFRESH](/reference/dbt-jinja-functions/flags). Кроме того, макрос `is_incremental()` вернет `false` для *всех* моделей в ответ, когда указан флаг `--full-refresh`.

<File name='models/example.sql'>

```sql
select * from all_events

-- если таблица уже существует и `--full-refresh` не установлен,
-- то добавляются только новые записи. в противном случае выбираются
-- все записи.
{% if is_incremental() %}
   where collector_tstamp > (
     select coalesce(max(max_tstamp), '0001-01-01') from {{ this }}
   )
{% endif %}
```

</File>

## Запуск конкретных моделей

dbt также позволяет выбрать, какие конкретные модели вы хотите материализовать. Это может быть полезно в особых сценариях, когда вы предпочитаете запускать другой набор моделей в различные интервалы. Это также может быть полезно, когда вы хотите ограничить материализуемые таблицы, пока вы разрабатываете и тестируете новые модели.

Для получения дополнительной информации см. [Документацию по синтаксису выбора моделей](/reference/node-selection/syntax).

Для получения дополнительной информации о запуске родительских или дочерних моделей см. [Документацию по операторам графа](/reference/node-selection/graph-operators).

## Обработка предупреждений как ошибок

См. [глобальные конфигурации](/reference/global-configs/warnings)

## Быстрое завершение при ошибках

См. [глобальные конфигурации](/reference/global-configs/failing-fast)

## Включение или отключение цветных логов

См. [глобальные конфигурации](/reference/global-configs/print-output#print-color)


## Флаг `--empty`

Команда `run` поддерживает флаг `--empty` для построения сухих запусков только со схемой. Флаг `--empty` ограничивает ссылки и источники до нуля строк. dbt все равно выполнит SQL модели в целевом хранилище данных, но избежит дорогостоящих чтений входных данных. Это проверяет зависимости и гарантирует, что ваши модели будут правильно построены.

## Коды состояния

При вызове [api list_runs](/dbt-cloud/api-v2#/operations/List%20Runs) вы получите код статуса для каждого выполнения. Доступные коды статуса выполнения следующие:

- Queued = 1 — **В очереди**
- Starting = 2 — **Запускается**
- Running = 3 — **Выполняется**
- Success = 10 — **Успешно завершено**
- Error = 20 — **Ошибка**
- Canceled = 30 — **Отменено**
- Skipped = 40 — **Пропущено**
