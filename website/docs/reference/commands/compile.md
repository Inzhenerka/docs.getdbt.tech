---
title: "О команде dbt compile"
sidebar_label: "compile"
id: "compile"
---

`dbt compile` генерирует исполняемый SQL из исходных файлов `model`, `test` и `analysis`. Вы можете найти эти скомпилированные SQL файлы в директории `target/` вашего проекта dbt.

Команда `compile` полезна для:

1. Визуальной проверки скомпилированного вывода файлов модели. Это полезно для проверки сложной логики jinja или использования макросов.
2. Ручного выполнения скомпилированного SQL. При отладке модели или теста схемы часто полезно выполнить основное выражение `select`, чтобы найти источник ошибки.
3. Компиляции файлов `analysis`. Узнайте больше о файлах анализа [здесь](/docs/build/analyses).

Некоторые распространенные заблуждения:
- `dbt compile` _не является_ предварительным требованием для `dbt run` или других команд сборки. Эти команды сами обрабатывают компиляцию.
- Если вы просто хотите, чтобы dbt прочитал и проверил ваш код проекта, не подключаясь к хранилищу данных, используйте вместо этого `dbt parse`.

### Интерактивная компиляция

Начиная с dbt v1.5, `compile` может быть "интерактивным" в CLI, отображая скомпилированный код узла или произвольного dbt-SQL запроса:
- `--select` конкретный узел _по имени_
- `--inline` произвольный dbt-SQL запрос

Это будет записывать скомпилированный SQL в терминал, помимо записи в директорию `target/`.

Например:

```bash
dbt compile --select "stg_orders"                           
dbt compile --inline "select * from {{ ref('raw_orders') }}"
```

возвращает следующее:

```bash
dbt compile --select "stg_orders"                           

21:17:09  Запуск с dbt=1.7.5
21:17:09  Зарегистрированный адаптер: postgres=1.7.5
21:17:09  Найдено 5 моделей, 3 семени, 20 тестов, 0 источников, 0 экспозиций, 0 метрик, 401 макросов, 0 групп, 0 семантических моделей
21:17:09  
21:17:09 Параллелизм: 24 потока (target='dev')
21:17:09  
21:17:09  Скомпилированный узел 'stg_orders' является:
with source as (
    select * from "jaffle_shop"."main"."raw_orders"

),

renamed as (

    select
        id as order_id,
        user_id as customer_id,
        order_date,
        status

    from source

)

select * from renamed
```

```bash
dbt compile --inline "select * from {{ ref('raw_orders') }}"

18:15:49  Запуск с dbt=1.7.5
18:15:50  Зарегистрированный адаптер: postgres=1.7.5
18:15:50  Найдено 5 моделей, 3 семени, 20 тестов, 0 источников, 0 экспозиций, 0 метрик, 401 макросов, 0 групп, 0 семантических моделей
18:15:50  
18:15:50  Параллелизм: 5 потоков (target='postgres')
18:15:50  
18:15:50  Скомпилированный встроенный узел является:
select * from "jaffle_shop"."main"."raw_orders"
```

Команда обращается к платформе данных для кэширования связанных метаданных и выполнения интроспективных запросов. Используйте флаги:
- `--no-populate-cache`, чтобы отключить начальное заполнение кэша. Если метаданные нужны, это будет промах кэша, что потребует от dbt выполнения запроса на получение метаданных. Это флаг `dbt`, что означает, что вам нужно добавить `dbt` в качестве префикса. Например: `dbt --no-populate-cache`.
- `--no-introspect`, чтобы отключить [интроспективные запросы](/faqs/Warehouse/db-connection-dbt-compile#introspective-queries). dbt выдаст ошибку, если определение модели требует выполнения одного из них. Это флаг `dbt compile`, что означает, что вам нужно добавить `dbt compile` в качестве префикса. Например: `dbt compile --no-introspect`.

### Часто задаваемые вопросы
<FAQ path="Warehouse/db-connection-dbt-compile" />